const V=Object.entries,et=Object.fromEntries,st="ENTRIES",L="KEYS",T="VALUES",_="";class D{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===_)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==_).join("")}value(){return E(this._path).node.get(_)}result(){switch(this._type){case T:return this.value();case L:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,u=o+s,i=new Uint8Array(u*o).fill(s+1);for(let r=0;r<o;++r)i[r]=r;for(let r=1;r<u;++r)i[r*o]=r;return R(e,t,s,n,i,1,o,""),n},R=(e,t,s,n,o,u,i,r)=>{const d=u*i;t:for(const c of e.keys())if(c===_){const a=o[d-1];a<=s&&n.set(r,[e.get(c),a])}else{let a=u;for(let h=0;h<c.length;++h,++a){const g=c[h],m=i*a,p=m-i;let l=o[m];const f=Math.max(0,a-s-1),y=Math.min(i-1,a+s);for(let F=f;F<y;++F){const v=g!==t[F],z=o[p+F]+ +v,A=o[p+F+1]+1,w=o[m+F]+1,j=o[m+F+1]=Math.min(z,A,w);j<l&&(l=j)}if(l>s)continue t}R(e.get(c),t,s,n,o,a,i,r+c)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,u]=O(n);for(const i of o.keys())if(i!==_&&i.startsWith(u)){const r=new Map;return r.set(i.slice(u.length),o.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=k(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){const s=k(this._tree,t);return s!==void 0&&s.has(_)}keys(){return new D(this,L)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,I(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=I(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},k=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return k(e.get(s),t.slice(s.length))},I=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const u of e.keys())if(u!==_&&t[n]===u[0]){const i=Math.min(s-n,u.length);let r=1;for(;r<i&&t[n+r]===u[r];)++r;const d=e.get(u);if(r===u.length)e=d;else{const c=new Map;c.set(u.slice(r),d),e.set(t.slice(n,n+r),c),e.delete(u),e=c}n+=r;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(_),s.size===0)W(n);else if(s.size===1){const[o,u]=s.entries().next().value;q(n,o,u)}}},W=e=>{if(e.length===0)return;const[t,s]=O(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&q(e.slice(0,-1),n,o)}},q=(e,t,s)=>{if(e.length===0)return;const[n,o]=O(e);n.set(o+t,s),n.delete(o)},O=e=>e[e.length-1],ut=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,M="or",$="and",rt="and_not",ct=(e,t)=>{e.includes(t)||e.push(t)},N=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,b=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[M]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:u,match:i}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,i),N(n.terms,u)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:u,terms:i,match:r}=t.get(n);N(o.terms,i),s.set(n,{score:o.score+u,terms:o.terms,match:Object.assign(o.match,r)})}return s},[rt]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,u)=>{const{k:i,b:r,d}=u;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/o)))},at=e=>(t,s,n)=>{const o=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,u=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:o,prefix:u}},H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),u=o.get(t);u==null||u.get(s)==null?H(e,s,t,n):u.get(s)<=1?u.size<=1?o.delete(t):u.delete(s):u.set(s,u.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},gt={k:1.2,b:.7,d:.5},mt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:M,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:gt},pt={combineWith:$,prefix:(e,t,s)=>t===s.length-1},Ft={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},_t={...Ft,...U},K=Symbol("*"),yt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,u]of e._documentIds){const i=n.boostDocument?n.boostDocument(u,"",e._storedFields.get(o)):1;s.set(o,{score:i,terms:[],match:{}})}return s},X=(e,t=M)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},S=(e,t,s,n,o,u,i,r,d=new Map)=>{if(o==null)return d;for(const c of Object.keys(u)){const a=u[c],h=e._fieldIds[c],g=o.get(h);if(g==null)continue;let m=g.size;const p=e._avgFieldLength[h];for(const l of g.keys()){if(!e._documentIds.has(l)){ft(e,h,l,s),m-=1;continue}const f=i?i(e._documentIds.get(l),s,e._storedFields.get(l)):1;if(!f)continue;const y=g.get(l),F=e._fieldLength.get(l)[h],v=dt(y,m,e._documentCount,F,p,r),z=n*a*f*v,A=d.get(l);if(A){A.score+=z,ct(A.terms,t);const w=G(A.match,s);w?w.push(c):A.match[s]=[c]}else d.set(l,{score:z,terms:[t],match:{[s]:[c]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields||e._options.fields).reduce((l,f)=>({...l,[f]:G(n.boost,f)||1}),{}),{boostDocument:u,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:c,prefix:a}={...J.weights,...i},h=e._index.get(t.term),g=S(e,t.term,t.term,1,h,o,u,d);let m,p;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const l=t.fuzzy===!0?.2:t.fuzzy,f=l<1?Math.min(r,Math.round(t.term.length*l)):l;f&&(p=e._index.fuzzyGet(t.term,f))}if(m)for(const[l,f]of m){const y=l.length-t.term.length;if(!y)continue;p?.delete(l);const F=a*l.length/(l.length+.3*y);S(e,t.term,l,F,f,o,u,d,g)}if(p)for(const l of p.keys()){const[f,y]=p.get(l);if(!y)continue;const F=c*l.length/(l.length+y);S(e,t.term,l,F,f,o,u,d,g)}return g},Y=(e,t,s={})=>{if(t===K)return yt(e,s);if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(g=>Y(e,g,a));return X(h,a.combineWith)}const{tokenize:n,processTerm:o,searchOptions:u}=e._options,i={tokenize:n,processTerm:o,...u,...s},{tokenize:r,processTerm:d}=i,c=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(at(i)).map(a=>At(e,a,i));return X(c,i.combineWith)},Q=(e,t,s={})=>{const n=Y(e,t,s),o=[];for(const[u,{score:i,terms:r,match:d}]of n){const c=r.length||1,a={id:e._documentIds.get(u),score:i*c,terms:Object.keys(d),queryTerms:r,match:d};Object.assign(a,e._storedFields.get(u)),(s.filter==null||s.filter(a))&&o.push(a)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:u,terms:i}of Q(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=u,d.count+=1):n.set(r,{score:u,terms:i,count:1})}const o=[];for(const[u,{score:i,terms:r,count:d}]of n)o.push({suggestion:u,terms:r,score:i/d});return o.sort(P),o};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?_t:t.autoVacuum;this._options={...mt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...pt,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[u,i]of n)o[u]=Object.fromEntries(i);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:o,fieldLength:u,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:c},a)=>{if(c!==1&&c!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=b(n),h._idToShortId=new Map,h._fieldIds=o,h._fieldLength=b(u),h._avgFieldLength=i,h._storedFields=b(r),h._dirtCount=d||0,h._index=new C;for(const[g,m]of h._documentIds)h._idToShortId.set(m,g);for(const[g,m]of e){const p=new Map;for(const l of Object.keys(m)){let f=m[l];c===1&&(f=f.ds),p.set(parseInt(l,10),b(f))}h._index.set(g,p)}return h},B=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let u=0,i=0;const r=(c,a=!1)=>{let h="";i===0?h=c.length>20?`… ${c.slice(-20)}`:c:a?h=c.length+i>100?`${c.slice(0,100-i)}… `:c:h=c.length>20?`${c.slice(0,20)} … ${c.slice(-20)}`:c,h&&o.push(h),i+=h.length,a||(o.push(["mark",t]),i+=t.length,i>=100&&o.push(" …"))};let d=s.indexOf(n,u);if(d===-1)return null;for(;d>=0;){const c=d+n.length;if(r(e.slice(u,d)),u=c,i>100)break;d=s.indexOf(n,u)}return i<100&&r(e.slice(u),!0),o},wt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),xt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return Q(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:u,terms:i,score:r}=o,d=u.includes("@"),c=u.includes("#"),[a,h]=u.split(/[#@]/),g=Number(a),m=i.sort((l,f)=>l.length-f.length).filter((l,f)=>i.slice(f+1).every(y=>!y.includes(l))),{contents:p}=n[g]??={title:"",contents:[]};if(d)p.push([{type:"customField",id:g,index:h,display:m.map(l=>o.c.map(f=>B(f,l))).flat().filter(l=>l!==null)},r]);else{const l=m.map(f=>B(o.h,f)).filter(f=>f!==null);if(l.length&&p.push([{type:c?"heading":"title",id:g,...c&&{anchor:h},display:l},r]),"t"in o)for(const f of o.t){const y=m.map(F=>B(f,F)).filter(F=>F!==null);y.length&&p.push([{type:"text",id:g,...c&&{anchor:h},display:y},r])}}}),V(n).sort(([,o],[,u])=>"max"==="total"?wt(o,u):xt(o,u)).map(([o,{title:u,contents:i}])=>{if(!u){const r=ut(t,o);r&&(u=r.h)}return{title:u,contents:i.map(([r])=>r)}})},tt=(e,t,s={})=>{const n=Ct(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},bt=et(V(JSON.parse("{\"/\":{\"documentCount\":90,\"nextId\":90,\"documentIds\":{\"0\":\"1\",\"1\":\"2\",\"2\":\"2@0\",\"3\":\"2@1\",\"4\":\"4\",\"5\":\"5\",\"6\":\"5#_1-被隐藏的过程\",\"7\":\"5#_1-1-预处理\",\"8\":\"5#_1-2-编译\",\"9\":\"5#_1-3-汇编\",\"10\":\"5#_1-4-链接\",\"11\":\"5#_2-静态链接\",\"12\":\"5#_2-1-链接的基本定义\",\"13\":\"5#_2-2-链接的过程\",\"14\":\"5#_2-3-重定位\",\"15\":\"5#_2-4-其它\",\"16\":\"6\",\"17\":\"6#_1-目标文件的格式\",\"18\":\"6#_2-目标文件是什么样的\",\"19\":\"6#_3-挖掘simplesection-o\",\"20\":\"6#_3-1-代码段\",\"21\":\"6#_3-2-数据段和只读数据段\",\"22\":\"6#_3-3-bss段\",\"23\":\"6#_3-3-其它段\",\"24\":\"6#_4-elf文件结构描述\",\"25\":\"6#_4-1-文件头\",\"26\":\"6#_4-1-2-文件类型\",\"27\":\"6#_4-1-3-机器类型\",\"28\":\"6#_4-2-段表\",\"29\":\"6#_4-2-1-段描述符的结构\",\"30\":\"6#_4-2-1-1-段的类型-sh-type\",\"31\":\"6#_4-2-1-2-段的标志位-sh-flags\",\"32\":\"6#_4-2-1-3-段的链接信息-sh-link、sh-info\",\"33\":\"6#_4-3-重定位表\",\"34\":\"6#_4-4-字符串表\",\"35\":\"6#_5-链接的接口-符号-symbol\",\"36\":\"6#_5-1-elf符号表结构\",\"37\":\"6#_5-1-1-符号类型和绑定类型-st-info\",\"38\":\"6#_5-1-2-符号所在段-st-shndx\",\"39\":\"6#_5-1-3-符号值-st-value\",\"40\":\"6#_5-2-特殊符号\",\"41\":\"6#_5-3-1-c-符号修饰\",\"42\":\"6#_5-4-extern-c\",\"43\":\"6#_5-5-强符合与弱符号\",\"44\":\"6#弱引用和强引用\",\"45\":\"6#_5-6-调试信息\",\"46\":\"7\",\"47\":\"7#_1-空间与地址分配\",\"48\":\"7#_1-1-按序叠加\",\"49\":\"7#_1-2-相似段合并\",\"50\":\"7#_1-3-符号地址的确定\",\"51\":\"7#_2-符号解析与重定位\",\"52\":\"7#_2-1-重定位\",\"53\":\"7#修正后的地址\",\"54\":\"7#_2-2-重定位表\",\"55\":\"7#_2-3-符号解析\",\"56\":\"7#_2-4-指令修正方式-参考csapp-原书第七章-7-7\",\"57\":\"7#_3-common块\",\"58\":\"7#_4-静态库链接\",\"59\":\"8\",\"60\":\"8#_1-装载的方式\",\"61\":\"8#_1-1-覆盖装入\",\"62\":\"8#_1-2-页映射\",\"63\":\"8#_2-从操作系统角度看可执行文件的装载\",\"64\":\"8#_2-1-进程的建立\",\"65\":\"8#_2-2-页错误\",\"66\":\"8#_3-进程虚拟空间分布\",\"67\":\"8#_3-1-elf文件链接视图和执行视图\",\"68\":\"8#_3-2-堆和栈\",\"69\":\"8#_3-3-段地址对齐\",\"70\":\"8#_3-4-进程栈初始化\",\"71\":\"9\",\"72\":\"9#_1-什么是动态链接\",\"73\":\"9#_2-简单的动态链接例子\",\"74\":\"9#_3-地址无关代码\",\"75\":\"9#_3-1-固定装载地址的困扰\",\"76\":\"9#_3-2-装载时重定位\",\"77\":\"9#_3-3-地址无关代码\",\"78\":\"9#_3-4-共享模块的全局变量问题\",\"79\":\"9#_3-5-数据段地址无关性\",\"80\":\"9#_4-延迟绑定-plt\",\"81\":\"9#_5-动态链接相关结构\",\"82\":\"9#_5-1-interp-段\",\"83\":\"9#_5-2-dynamic-段\",\"84\":\"9#_5-3-动态符号表\",\"85\":\"9#_5-4-动态链接重定位表\",\"86\":\"9#_5-5-动态链接时进程堆栈初始化信息\",\"87\":\"9#_6-动态链接的步骤和实现\",\"88\":\"9#_7-hook\",\"89\":\"10\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1],\"1\":[2],\"2\":[null,null,2],\"3\":[null,null,2],\"4\":[2],\"5\":[2],\"6\":[2,24],\"7\":[2,36],\"8\":[3,21],\"9\":[3,11],\"10\":[3,4],\"11\":[2],\"12\":[3,6],\"13\":[2,3],\"14\":[3,31],\"15\":[3,6],\"16\":[2],\"17\":[2,57],\"18\":[2,39],\"19\":[3,111],\"20\":[3,204],\"21\":[3,25],\"22\":[2,77],\"23\":[2,1],\"24\":[2,15],\"25\":[3,127],\"26\":[4,1],\"27\":[4,1],\"28\":[3,152],\"29\":[4,67],\"30\":[7,8],\"31\":[7,5],\"32\":[9,8],\"33\":[3,29],\"34\":[2,17],\"35\":[5,73],\"36\":[3,31],\"37\":[6,7],\"38\":[7,8],\"39\":[7,83],\"40\":[3,61],\"41\":[5,69],\"42\":[5,31],\"43\":[2,62],\"44\":[1,56],\"45\":[3,2],\"46\":[2,19],\"47\":[2,3],\"48\":[2,19],\"49\":[3,218],\"50\":[3,30],\"51\":[2],\"52\":[3,104],\"53\":[1,121],\"54\":[2,107],\"55\":[3,165],\"56\":[7,74],\"57\":[2,39],\"58\":[2,43],\"59\":[2],\"60\":[2],\"61\":[2,8],\"62\":[3,4],\"63\":[2],\"64\":[3,54],\"65\":[2,18],\"66\":[2],\"67\":[3,404],\"68\":[3,92],\"69\":[2,40],\"70\":[3,23],\"71\":[2],\"72\":[2,10],\"73\":[2,315],\"74\":[2],\"75\":[3,47],\"76\":[3,27],\"77\":[2,376],\"78\":[3,62],\"79\":[3,29],\"80\":[4,207],\"81\":[2,43],\"82\":[4,68],\"83\":[4,177],\"84\":[3,132],\"85\":[3,160],\"86\":[2,113],\"87\":[2],\"88\":[2],\"89\":[1,3]},\"averageFieldLength\":[2.911111111111111,59.64686241688366,1],\"storedFields\":{\"0\":{\"h\":\"介绍页\"},\"1\":{\"h\":\"c/c++\"},\"2\":{\"c\":[\"c/c++\"]},\"3\":{\"c\":[\"c/c++\"]},\"4\":{\"h\":\"链接、装载和库\"},\"5\":{\"h\":\"第一章 编译和链接\"},\"6\":{\"h\":\"1. 被隐藏的过程\",\"t\":[\"// hello.c #include <stdio.h> int main() { printf(\\\"hello world\\\\n\\\"); return 0; }\",\"使用gcc生成可执行文件\",\"$> gcc hello.c -o hello $> ./hello Hello World\",\"gcc生成可执行文件的四个步骤\",\"预处理\",\"编译\",\"汇编\",\"链接\"]},\"7\":{\"h\":\"1.1 预处理\",\"t\":[\"1. 展开所有宏定义 (#define) 2. 处理所有预编译指令 (#if #ifdef #elif #else #endif) 3. 处理#include预编译指令,将被包含的文件插入到该预处理指令的位置。递归的执行 4. 删除所有注释 5. 添加行号和文件名标号。比如 #2 \\\"hello.c\\\" 2, 以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。 6. 保留所有的#pragma编译指令，因为编译器需要使用它们。\",\"生成预处理文件 *.i\",\"$> gcc -E hello.c -o hello.i 或者 $> cpp hello.c > hello.i\"]},\"8\":{\"h\":\"1.2 编译\",\"t\":[\"将预处理文件经过一系列词法分析、语法分析、语义分析及优化后生成汇编的过程。程序构建的核心。 生成汇编文件 .s\",\"$> gcc -S hello.i -o hello.s 或者 $> /usr/lib/gcc/x86_64-linux-gnu/11/cc1 hello.i\"]},\"9\":{\"h\":\"1.3 汇编\",\"t\":[\"将每一条汇编指令翻译成对应机器码的过程。 生成目标文件（或者中间目标文件）*.o\",\"$> as hello.s -o hello.o 或者 $> gcc -c hello.s -o hello.o\"]},\"10\":{\"h\":\"1.4 链接\",\"t\":[\"通过使用链接器(ld)链接一堆文件生成最终的可执行文件的过程。 如hello文件\"]},\"11\":{\"h\":\"2. 静态链接\"},\"12\":{\"h\":\"2.1 链接的基本定义\",\"t\":[\"将每个源代码模块独立编译，然后安装需要将他们“组装”起来的过程被称为链接。 链接的本质就是把一些指令对其它符号地址的引用加以修改。\"]},\"13\":{\"h\":\"2.2 链接的过程\",\"t\":[\"地址和空间分配、符号决议和重定位。\"]},\"14\":{\"h\":\"2.3 重定位\",\"t\":[\"在链接过程中，对定义在其它目标文件中的函数调用的指令需要被重新调整，对使用定义在其它目标文件中的变量也是如此。 比如: 有目标文件A有全局变量var 对目标文件B有 movq 0x2a, var c7 05 00 00 00 00 2a movq $0x2a,0x0(%rip) 由于编译目标文件B时无法确认var的目标地址，所以编译器在无法确认var地址的情况下，只能将movq指令的目标地址置0， 等待链接器再将目标文件A和B链接起来时再将其修正。 例如A和B链接后，变量var的地址确认为0x1000，那么链接器将会把这个指令的目标地址部分修改为0x1000。 这个地址修正的过程也被叫做“重定位(Relocation)”，每个要修正的地方叫一个“重定位入口(Relocation Entry)”。 重定位所做的就是给程序中每个这样的绝对地址引用的地址进行修正。\"]},\"15\":{\"h\":\"2.4 其它\",\"t\":[\"运行时库：支撑程序运行的基本函数集合。 库：一组目标文件(.o后缀的文件)的包\"]},\"16\":{\"h\":\"第二章 目标文件\"},\"17\":{\"h\":\"1. 目标文件的格式\",\"t\":[\"Linux下的主流文件存储格式为ELF，通过file指令可以查看文件的存储格式。\",\"$> file foobar.o foobar.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped $> file /bin/bash /bin/bash: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=2f77b36371c214e11670c7d9d92727e9a49f626b, for GNU/Linux 3.2.0, stripped file /lib32/ld-linux.so.2 /lib32/ld-linux.so.2: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), static-pie linked, BuildID[sha1]=595f7870a8165b3eb04c9ebda08a8ccba6f742c2, stripped\",\"ELF文件标准里采用ELF格式的文件:\",\"可重定位文件 Linux的 *.o文件 静态链接库\",\"可执行文件\",\"共享目标文件 Linux的 *.so文件\",\"核心转储文件 Linux下的 core dump\"]},\"18\":{\"h\":\"2. 目标文件是什么样的\",\"t\":[\"目标文件将信息按不同的属性进行存储，通常称之为节(section)或者段(segment)\",\"提示\",\"源代码编译后的机器指令经常放于代码段(.text) 全局变量和局部静态变量经常存放于数据段(.data)\",\" ELF文件的开头是一个“文件头”，描述了整个文件的文件属性。\",\"是否可执行\",\"是否静态链接\",\"是否动态链接\",\"入口地址\",\"目标硬件\",\"目标操作系统\",\"等等\",\"文件头同时包括一个段表\",\"提示\",\"段表用来描述一个文件中各个段的数组。段表描述了文件中各个段在文件中的偏移位置及段的属性等，从段表中可以得到每个的段的所有信息。 .data section: 已初始化的全局变量和局部静态变量 .bss section: 未初始化的全局变量和局部静态变量(默认值为0),初始化为0的全局变量和局部静态变量 .bss段只是为未初始化的全局变量和局部静态变量预留位置而已(记录所有为初始或者初始化为0的全局变量和静态变量的大小总和)，所以在文件中也不占据空间\",\"分段的好处\",\" 可以防止程序被恶意篡改\",\" 利用缓存，提高CPU的缓存命中\",\" 节省内存空间(内存共享比如libc的动态链接库)\"]},\"19\":{\"h\":\"3. 挖掘SimpleSection.o\",\"t\":[\"int printf(const char *format, ...); int global_init_var = 84; int global_uninit_var; void func1(int i) { printf(\\\"%d\\\\n\\\", i); } int main() { static int static_var = 85; static int static_var2; int a = 1; int b; func1(static_var + static_var2 + a + b); return 0; }\",\"提示\",\"使用objdump -h指令打印ELF文件的各个段的基本信息 -x 参数可以打印更多信息\",\"$> objdump -h SimpleSection.o SimpleSection.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000064 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000008 0000000000000000 0000000000000000 000000a4 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000008 0000000000000000 0000000000000000 000000ac 2**2 ALLOC 3 .rodata 00000004 0000000000000000 0000000000000000 000000ac 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 00000027 0000000000000000 0000000000000000 000000b0 2**0 CONTENTS, READONLY 5 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000d7 2**0 CONTENTS, READONLY 6 .note.gnu.property 00000020 0000000000000000 0000000000000000 000000d8 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 7 .eh_frame 00000058 0000000000000000 0000000000000000 000000f8 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\",\"注\",\".rodata: 只读数据段 .comment: 注释信息段 .note.GNU-stack: 堆栈提示段 Size: 段的长度 File Offset: 段所在的位置(段偏移) CONTENTS: 该段在文件中存在(bss段没有表示bss段在ELF文件中不存在内容。.note.GNU-stack虽然有但是长度为0，认为它在ELF文件中也不存在)\",\"使用size指令查看ELF文件的代码段、数据段和bss段。\",\"$> size SimpleSection.o text data bss dec hex filename 224 8 8 240 f0 SimpleSection.o\"]},\"20\":{\"h\":\"3.1 代码段\",\"t\":[\"$> objdump -s -d SimpleSection.o SimpleSection.o: file format elf64-x86-64 Contents of section .text: 0000 f30f1efa 554889e5 4883ec10 897dfc8b ....UH..H....}.. 0010 45fc89c6 488d0500 00000048 89c7b800 E...H......H.... 0020 000000e8 00000000 90c9c3f3 0f1efa55 ...............U 0030 4889e548 83ec10c7 45f80100 00008b15 H..H....E....... 0040 00000000 8b050000 000001c2 8b45f801 .............E.. 0050 c28b45fc 01d089c7 e8000000 00b80000 ..E............. 0060 0000c9c3 .... Contents of section .data: 0000 54000000 55000000 T...U... Contents of section .rodata: 0000 25640a00 %d.. Contents of section .comment: 0000 00474343 3a202855 62756e74 75203133 .GCC: (Ubuntu 13 0010 2e322e30 2d323375 62756e74 75342920 .2.0-23ubuntu4) 0020 31332e32 2e3000 13.2.0. Contents of section .note.gnu.property: 0000 04000000 10000000 05000000 474e5500 ............GNU. 0010 020000c0 04000000 03000000 00000000 ................ Contents of section .eh_frame: 0000 14000000 00000000 017a5200 01781001 .........zR..x.. 0010 1b0c0708 90010000 1c000000 1c000000 ................ 0020 00000000 2b000000 00450e10 8602430d ....+....E....C. 0030 06620c07 08000000 1c000000 3c000000 .b..........<... 0040 00000000 39000000 00450e10 8602430d ....9....E....C. 0050 06700c07 08000000 .p...... Disassembly of section .text: 0000000000000000 <func1>: 0: f3 0f 1e fa endbr64 4: 55 push %rbp 5: 48 89 e5 mov %rsp,%rbp 8: 48 83 ec 10 sub $0x10,%rsp c: 89 7d fc mov %edi,-0x4(%rbp) f: 8b 45 fc mov -0x4(%rbp),%eax 12: 89 c6 mov %eax,%esi 14: 48 8d 05 00 00 00 00 lea 0x0(%rip),%rax # 1b <func1+0x1b> 1b: 48 89 c7 mov %rax,%rdi 1e: b8 00 00 00 00 mov $0x0,%eax 23: e8 00 00 00 00 call 28 <func1+0x28> 28: 90 nop 29: c9 leave 2a: c3 ret 000000000000002b <main>: 2b: f3 0f 1e fa endbr64 2f: 55 push %rbp 30: 48 89 e5 mov %rsp,%rbp 33: 48 83 ec 10 sub $0x10,%rsp 37: c7 45 f8 01 00 00 00 movl $0x1,-0x8(%rbp) 3e: 8b 15 00 00 00 00 mov 0x0(%rip),%edx # 44 <main+0x19> 44: 8b 05 00 00 00 00 mov 0x0(%rip),%eax # 4a <main+0x1f> 4a: 01 c2 add %eax,%edx 4c: 8b 45 f8 mov -0x8(%rbp),%eax 4f: 01 c2 add %eax,%edx 51: 8b 45 fc mov -0x4(%rbp),%eax 54: 01 d0 add %edx,%eax 56: 89 c7 mov %eax,%edi 58: e8 00 00 00 00 call 5d <main+0x32> 5d: b8 00 00 00 00 mov $0x0,%eax 62: c9 leave 63: c3 ret\",\"提示\",\"-s: 将所有段的内容以十六进制的方式打印 -d: 将所有包含指令的段反汇编\"]},\"21\":{\"h\":\"3.2 数据段和只读数据段\",\"t\":[\"提示\",\".data section: 已初始化的全局变量和局部静态变量\",\"SimpleSection.c代码中一共有两个这样的变量(global_init_var, static_var),所以.data段的大小正好为8个字节。\",\"提示\",\".rodata section: 存放只读数据(const变量,字符串字面量)\",\"SimpleSection.c代码中用在调用printf时用到了字符字面量\\\"%d\\\\n\\\",它是一种只读数据,所以它被放到了.rodata段。所以.rodata段的大小正好为四字节(字符串结尾包含字符串结束符)。\"]},\"22\":{\"h\":\"3.3 bss段\",\"t\":[\"提示\",\".bss section: 未初始化的全局变量和局部静态变量(默认值为0),初始化为0的全局变量和局部静态变量\",\"SimpleSection.c代码中一共有两个这样的变量(global_uninit_var, static_var2),所以.data段的大小正好为8个字节。\",\"提示\",\"可以给gcc选项加入-fcommon使未初始化的全局变量被定义为一个\\\"COMMON\\\"符号，注意对于初始化为0的全局变量则不行。\",\"$> gcc -c SimpleSection.c -fcommon $> readelf -s SimpleSection.o Symbol table '.symtab' contains 13 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS SimpleSection.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 .text 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 .data 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 .bss 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 .rodata 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_var.1 7: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 static_var2.0 8: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var 9: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_uninit_var 10: 0000000000000000 43 FUNC GLOBAL DEFAULT 1 func1 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 12: 000000000000002b 57 FUNC GLOBAL DEFAULT 1 main\"]},\"23\":{\"h\":\"3.3 其它段\",\"t\":[\"其它段\"]},\"24\":{\"h\":\"4. ELF文件结构描述\",\"t\":[\"注\",\"ELF目标文件的最前部是ELF文件头（ELF Header）,它包含了描述整个文件的基本属性。仅接着是ELF各个段。其中ELF文件中与段有关的重要结构就是段表（Section Header Table），该表描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。\",\"ELF文件结构\"]},\"25\":{\"h\":\"4.1 文件头\",\"t\":[\"通过使用readelf -h指令即可查看ELF文件头\",\"$> readelf -h SimpleSection.o ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: REL (Relocatable file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x0 Start of program headers: 0 (bytes into file) Start of section headers: 1032 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 0 (bytes) Number of program headers: 0 Size of section headers: 64 (bytes) Number of section headers: 14 Section header string table index: 13\",\"ELF文件头定义了\",\"ELF魔数\",\"文件机器字节长度\",\"数据存储方式\",\"版本\",\"运行平台\",\"ABI版本\",\"ELF重定位类型\",\"硬件平台\",\"硬件平台版本\",\"入口地址\",\"程序入口和长度\",\"段表位置和长度\",\"段数量\",\"// /usr/include/elf.h typedef struct { unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */ } Elf64_Ehdr;\",\"ELF文件头结构成员含义\"]},\"26\":{\"h\":\"4.1.2 文件类型\",\"t\":[\"文件类型\"]},\"27\":{\"h\":\"4.1.3 机器类型\",\"t\":[\"机器类型\"]},\"28\":{\"h\":\"4.2 段表\",\"t\":[\"提示\",\"段表用于保存这些段的基本属性结构。\",\"使用objdump -h来查看ELF文件中包含的段，但是只是把ELF文件中关键的段显示了出来。可以使用readelf -S指令来显示ELF文件的各种段表结构\",\"$> readelf -S SimpleSection.o There are 14 section headers, starting at offset 0x408: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .text PROGBITS 0000000000000000 00000040 0000000000000064 0000000000000000 AX 0 0 1 [ 2] .rela.text RELA 0000000000000000 000002e8 0000000000000078 0000000000000018 I 11 1 8 [ 3] .data PROGBITS 0000000000000000 000000a4 0000000000000008 0000000000000000 WA 0 0 4 [ 4] .bss NOBITS 0000000000000000 000000ac 0000000000000004 0000000000000000 WA 0 0 4 [ 5] .rodata PROGBITS 0000000000000000 000000ac 0000000000000004 0000000000000000 A 0 0 1 [ 6] .comment PROGBITS 0000000000000000 000000b0 0000000000000027 0000000000000001 MS 0 0 1 [ 7] .note.GNU-stack PROGBITS 0000000000000000 000000d7 0000000000000000 0000000000000000 0 0 1 [ 8] .note.gnu.pr[...] NOTE 0000000000000000 000000d8 0000000000000020 0000000000000000 A 0 0 8 [ 9] .eh_frame PROGBITS 0000000000000000 000000f8 0000000000000058 0000000000000000 A 0 0 8 [10] .rela.eh_frame RELA 0000000000000000 00000360 0000000000000030 0000000000000018 I 11 9 8 [11] .symtab SYMTAB 0000000000000000 00000150 0000000000000138 0000000000000018 12 8 8 [12] .strtab STRTAB 0000000000000000 00000288 0000000000000060 0000000000000000 0 0 1 [13] .shstrtab STRTAB 0000000000000000 00000390 0000000000000074 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), l (large), p (processor specific)\",\"提示\",\"段表的结构以Elf64_Shdr结构的数组形式进行存储,数组元素个数为段个数，每个Elf64_Shdr对应一个段属性描述。所以每个Elf64_Shdr又被称为段描述符。 第一个元素是无效段描述符，它的类型为\\\"NULL\\\"，除此之外每个描述符对应一个段。所以SimpleSection.o共有10个有效段。\"]},\"29\":{\"h\":\"4.2.1 段描述符的结构\",\"t\":[\"// /usr/include/elf.h typedef struct { Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */ } Elf64_Shdr;\",\" 段表结构解析\",\"注\",\"elf文件头中指出了段表位于文件的偏移(Elf64_Ehdr的e_shoff元素)为1032(0x408)，代码段(.text)位于elf文件头后所以elf文件头的大小正好为代码段的偏移0x40(64)字节，段表的最后一个元素(.shstrtab)的偏移量为0x390文件大小为0x74。而0x408 = 0x390 + 0x74 + 0x04正好是段表在elf文件中的偏移(之所以+0x04是因为内存对齐的原因)。\"]},\"30\":{\"h\":\"4.2.1.1 段的类型(sh_type)\",\"t\":[\"提示\",\"对于编译器和链接器来说，主要决定段的属性的是段的类型(sh_type)和段的标志位(sh_flags)\",\"段的类型\"]},\"31\":{\"h\":\"4.2.1.2 段的标志位(sh_flags)\",\"t\":[\"提示\",\"决定了该段在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。\",\"段的标志位\"]},\"32\":{\"h\":\"4.2.1.3 段的链接信息(sh_link、sh_info)\",\"t\":[\"提示\",\"只有段的类型是与链接(动态链接、静态链接、重定位表、符号表等)相关时这两个成员才会有意义。\",\"段的链接信息\"]},\"33\":{\"h\":\"4.3 重定位表\",\"t\":[\"提示\",\"在SimpleSection.o中有一个叫做\\\".rela.text\\\"的段, 它的类型(sh_type)为\\\"SH_RELA\\\", 也就是说它是一个重定位表。 对于每个需要重定位的段，都会有一个相应的重定位表。比如\\\".rela.text\\\"是\\\".text\\\"的重定位表。 一个重定位表同时也是elf的一个段, 那么这个段的类型(sh_type)就是\\\"SHL_REL\\\", 它的\\\"sh_link\\\"表示符号表的下标, \\\"sh_info\\\"表示它作用于那个段。\",\"重定位表\"]},\"34\":{\"h\":\"4.4 字符串表\",\"t\":[\"提示\",\"elf文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。 .strtab: 字符串表(string table) .shstrtab: 段表字符串表(section header string table)\"]},\"35\":{\"h\":\"5. 链接的接口-符号(Symbol)\",\"t\":[\"提示\",\"链接的过程就是把多个不同的目标文件之间相互衔接的过程。这个相互衔接的过程实际上是目标文件之间对地址的引用。 比如文件B用到了目标A中的函数\\\"foo\\\", 那么我们就称文件A定义(define)了函数\\\"foo\\\", 称目标文件B引用(refrence)了目标文件A中的函数\\\"foo\\\"。这两个概念同样适用于变量。 在链接中将函数和变量称为符号(Symbol), 函数名和变量名称为符号名(Symbol Name)符号是链接中的粘合剂, 整个链接的过程基于符号才能正确完成。 每一个目标文件都有一个相应的符号表(Symbol Table)对符号进行管理, 该表记录了目标文件中所用的所有符号。每个定义的符号都有一个对应的值, 叫做符号值(Symbol Value), 对于变量和函数来说, 符号值就是它们的地址。除了函数和变量外，还存在其它几种不常用的符号。\",\"定义在目标文件的全局符号，可以被其它目标文件引用\",\"在本文件中引用的全局符号，却没有在本文件中定义，一般叫做外部符号(External Symbol)，也被称为符号引用\",\"段名，由编译器生成，它的值就是该段的起始地址。(.text, .data)\",\"局部符号，只在编译器内部可见。(SimpleSection.o文件的static_var和static_var2)\",\"行号信息，即目标文件指令与源代码中代码行的对应关系，可选。\",\"使用nm指令查看符号结果\",\"$> nm SimpleSection.o 0000000000000000 T func1 0000000000000000 D global_init_var 0000000000000004 C global_uninit_var 000000000000002b T main U printf 0000000000000004 d static_var.1 0000000000000000 b static_var2.0\"]},\"36\":{\"h\":\"5.1 ELF符号表结构\",\"t\":[\"// /usr/include/elf.h typedef struct { Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym;\",\"ELF符号表结构\"]},\"37\":{\"h\":\"5.1.1 符号类型和绑定类型(st_info)\",\"t\":[\"提示\",\"低4位表示符号类型(Symbol Type), 高28位表示符号绑定信息(Symbol Binding)\",\"符号类型和绑定\"]},\"38\":{\"h\":\"5.1.2 符号所在段(st_shndx)\",\"t\":[\"提示\",\"如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标，如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值会有些特殊。\",\"符号所在段\"]},\"39\":{\"h\":\"5.1.3 符号值(st_value)\",\"t\":[\"提示\",\"每个符号都有一个对应的值，如果这个符号是一个函数或变量的定义，那么符号的值就是这个函数或变量的地址。\",\"在目标文件中，如果是符号的定义并且该符号不是“COMMON块”类型的，则st_value表示该符号在段中的偏移。比如SimpleSection.o中的\\\"func1\\\"、\\\"main\\\"、\\\"global_init_var\\\"。\",\"在目标文件中，如果符号是\\\"COMMON块\\\"，st_value表示该符号的对齐属性。比如SimpleSection.o中的\\\"global_uninit_var\\\"。\",\"在可执行文件中，st_value表示符号的虚拟地址。 使用readelf -s查看符号表\",\"# 注意编译时使用了-fcommon编译选项 $> readelf -s SimpleSection.o Symbol table '.symtab' contains 13 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS SimpleSection.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 .text 3: 0000000000000000 0 SECTION LOCAL DEFAULT 3 .data 4: 0000000000000000 0 SECTION LOCAL DEFAULT 4 .bss 5: 0000000000000000 0 SECTION LOCAL DEFAULT 5 .rodata 6: 0000000000000004 4 OBJECT LOCAL DEFAULT 3 static_var.1 7: 0000000000000000 4 OBJECT LOCAL DEFAULT 4 static_var2.0 8: 0000000000000000 4 OBJECT GLOBAL DEFAULT 3 global_init_var 9: 0000000000000004 4 OBJECT GLOBAL DEFAULT COM global_uninit_var 10: 0000000000000000 43 FUNC GLOBAL DEFAULT 1 func1 11: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND printf 12: 000000000000002b 57 FUNC GLOBAL DEFAULT 1 main\"]},\"40\":{\"h\":\"5.2 特殊符号\",\"t\":[\"// SpecialSymbol.c #include <stdio.h> extern char __executable_start[]; extern char etext[], _etext[], __etext[]; extern char edata[], _edata[]; extern char end[], _end[]; int main() { printf(\\\"Executable Start %X\\\\n\\\", __executable_start); printf(\\\"Text End %X %X %X\\\\n\\\", etext, _etext, __etext); printf(\\\"Data End %X %X\\\\n\\\", edata, _edata); printf(\\\"Executable End %X %X\\\\n\\\", end, _end); return 0; }\",\"$> ./SpecialSymbol Executable Start 9004000 Text End 9005205 9005205 9005205 Data End 9008010 9008010 Executable End 9008018 9008018\",\"提示\",\"__executable_start: 程序起始地址，注意不是入口地址。 etext, _etext, __etext: 代码段结束地址。 edata, edata: 数据段结束地址。 end, end: 程序结束地址。 地址都为虚拟地址。 ### 5.3 符号修饰与函数签名 [!tip] UNIX下c语言规定：c语言源代码文件中的所有全局的变量和函数经过编译后，相应的符号名前加上下划线\\\"\\\"。比如一个c函数\\\"foo\\\"，当它经过编译后的符号名就为\\\"foo\\\"。但是当程序规模很大时仍然会出现明明冲突的问题，于是像c++增加了==命名空间(namespace)==的方法来解决多模块的符号冲突问题。 现在的Linux下的GCC编译器中，默认情况下已经去掉了在c语言符号前加\\\"\\\"的这种方式。GCC编译器也可以通过==\\\"-fleading-underscore\\\"或者\\\"-fno-leading-underscore\\\"==来打开和关闭是否在c语言符号前加上\\\"\\\"\"]},\"41\":{\"h\":\"5.3.1 c++ 符号修饰\",\"t\":[\"int func(int); float func(float); class C { int func(int); class C2{ int func(int); }; }; namespace N { int func(int); class C { int func(int); }; };\",\"注\",\"函数签名(Function Signature): 包含了一个函数的信息，包括函数名、参数类型、它所在的类和名称空间及其它信息。 名称修饰(Name Decoration): 在编译器及连接器处理符号时，使用某种名称修饰的方法，使得每个函数签名对应一个修饰后名称(Decorated Name)。\",\"c++名称修饰\",\"提示\",\"所有符号都以\\\"_Z\\\"开头，对于嵌套的名字(在名称空间或在类里面的)，后面紧跟\\\"N\\\"，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以\\\"E\\\"结尾。比如N::C::func经过名称修饰后就是_ZN1N1C4funcE。对于一个函数来说，它的参数列表紧跟在\\\"E\\\"后面，对于int类型来说,字母就是\\\"i\\\"。所以整个N::C::func(int)函数签名经过修饰为_ZN1N1C4funcEi。\",\"注\",\"可以通过\\\"c++filt\\\"的工具来解析被修饰的名称。\",\"$> c++filt _ZN1N1C4funcEi N::C::func(int)\",\"提示\",\"c++中的全局变量和静态变量也有同样的机制。比如foo命名空间下的bar变量(foo::bar)，经过修饰后的名字为: _ZN3far3barE。可以注意到变量的类型并没有加入到修饰后的名称中去。所以不论这个变量是整形还是浮点型甚至是全局对象，它的名称都是一样的。 名称修饰机制也被用来防止静态变量的名字冲突。比如main()函数里面的静态变量foo，和func()函数的静态变量foo会被GCC编译器会将他们修饰为：_ZZ4mainE3foo和_ZZ4funcE3foo。\"]},\"42\":{\"h\":\"5.4 extern \\\"C\\\"\",\"t\":[\"注\",\"c++编译器会将extern \\\"C\\\"的大括号内部的代码当作c语言代码处理。所以c++名称修饰会对其不起作用。\",\"// func和var不会被c++的名称修饰规则修饰。 extern \\\"C\\\" { int func(int); int var; } // 或者写成 extern \\\"C\\\" int func(int); extern \\\"C\\\" int var;\",\"// ManualNameMangling.cc // g++ ManualNameMangling.cc -o ManualNameMangling #include <stdio.h> namespace myname { int var = 42; } extern \\\"C\\\" double _ZN6myname3varE; int main() { printf(\\\"%d\\\\n\\\", myname::var); return 0; }\",\"$> ./ManualNameMangling 42\"]},\"43\":{\"h\":\"5.5 强符合与弱符号\",\"t\":[\"注\",\"深入理解计算机系统(csapp)一书中也有讲解。了解本小节将有助于帮助理解链接过程中为什么会出现重复定义的问题。\",\"// a.c int global = 1; // b.c int global = 2; // 由于global重复定义链接时将会出现重定义错误。\",\"符号的定义通常被称为强符号(Strong Symbol)。有些符号的定义也被称为弱符号(Weak Symbol)\",\"注\",\"c/c++编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。可以通过GCC编译器提供的\\\"attribute((weak))\\\" 来定义任何一个强符号为弱符号。 需要注意的是：强符号和弱符号都是针对定义的，不是针对符号的引用。\",\"extern int ext; // 这是一个引用，所以即不是强符号也不是弱符号。 int weak; // 弱符号 int strong = 1; // 强符号 __attribute__((weak)) weak2 = 2; // 弱符号 // 强符号 int main() { return 0; }\",\"连接器按如下规则处理与选择被多次定义的全局符号\",\"提示\",\"不允许被多次定义(既不同的目标文件中不能有同名的强符号)，如果出现多个强符号定义，则链接器报符号重定义错误。\",\"如果一个符号在某个文件中是强符号，在其它文件为弱符号，那么选强符号。\",\"如果一个符号在所有目标文件中都是弱符号，那么选其中占用空间最大的一个。比如文件A声明符号(未初始化)global为int(4byte)，目标文件B声明符号(未初始化)global为double(8byte)。当A和B链接时，符号global占8byte。(最好不要这样负责会出现一些意想不到的bug，而且很难发现)\"]},\"44\":{\"h\":\"弱引用和强引用\",\"t\":[\"提示\",\"强引用(Strong Reference): 对外部目标文件的符号引用在目标文件被最终链接成可执行文件时，他们需要被正确决议，如果没有找到该符号的定义，链接器就会报服啊后未定义的错误，这种被称为强引用(Strong Reference)。弱引用(Weak Reference): 在处理弱引用时，如果该符号有定义，则连接器将该符号的引用决议；如果该符号未被定义，则连接器对于该引用不报错。 对于未定义的弱引用，连接器默认其为0，或者是一个特殊的值，以便于程序代码能够识别。\",\"// 通过使用__attribute__ ((weakref))声明对一个外部函数的引用为弱引用。 __attribute__ ((weakref)) void foo(); int main() { if (foo) foo(); }\",\"// pthread.c // 通过使用__attribute__ ((weakref))判断是否链接到pthread库。 #include <stdio.h> #include <pthread.h> int pthread_create(pthread_t *, const pthread_attr_t *, void *(*)(void *), void *) __attribute__ ((weak)); int main() { if (pthread_create) { printf(\\\"This is multi-thread version!\\\\n\\\"); } else { printf(\\\"This is single-thread version!\\\\n\\\"); } }\",\"$> gcc pthread.c -o pt $> ./pt This is single-thread version! $> gcc pthread.c -o pt -lpthread $> ./pt This is multi-thread version!\"]},\"45\":{\"h\":\"5.6 调试信息\",\"t\":[\"注\",\"可以使用readelf查看debug相关的段\"]},\"46\":{\"h\":\"第三章 静态链接\",\"t\":[\"// a.c extern int shared; int main() { int a = 100; swap(&a, &shared); return 0; } // b.c int shared = 1; void swap(int *a, int *b) { *a ^= *b ^= *a ^= *b; }\",\"$> gcc -c a.c b.c -O2\"]},\"47\":{\"h\":\"1. 空间与地址分配\",\"t\":[\"注\",\"链接的过程就是将几个输入目标文件加工合并成一个输出文件的过程。\"]},\"48\":{\"h\":\"1.1 按序叠加\",\"t\":[\"注\",\"什么是按序叠加？ 就是将各个目标文件依次合并。但是这样会有些问题，当输入文件很多时，如果每个段都分别有.text段、.data段和.bss段，那最后输出文件将会有成百上千零散的段。这种做法是很浪费内存空间的（主要原因是内存对齐），对于x86的硬件来说，段的装载地址和空间的对齐单位是页，也就是4096字节。就算一个段只有1字节的大小，那这个段也要占据4096字节的内存大小。这会导致大量的内存碎片。\",\"按序叠加内存分配\"]},\"49\":{\"h\":\"1.2 相似段合并\",\"t\":[\"注\",\"什么是相似段合并？ 就是将相同性质的段进行合并，比如将所有输入文件的\\\".text\\\"合并到输出文件的\\\".text\\\"段，接着是\\\".data\\\"段，\\\".bss\\\"段等。\",\"相似段合并\",\"重要\",\".bss段在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。所以链接器在合并各个段的同时，也将\\\".bss\\\"段合并，同时分配虚拟空间。 关于地址和空间的两个含义：\",\"输出的可执行文件中的空间。\",\"装载后的虚拟地址中的虚拟地址空间。 对于\\\".text\\\"和\\\".data\\\"，它们在文件中和虚拟地址都要分配空间，对于\\\".bss\\\"这样的段，分配空间只局限与虚拟地址空间，因为它在文件中并没有内容。\",\"重要\",\"两步链接\",\"空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。这一步连接器将能够获得所有输入目标文件的段长度，并且将它们合并，计算输出文件中各个段合并后的长度和位置，并建立映射关系。\",\"符号解析与重定位 使用上一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。\",\"使用objdump指令查看链接前后的地址分配情况。\",\"# VMA: 虚拟地址 LMA: 加载地址 $> objdump -h a.o a.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000058 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000000 0000000000000000 0000000000000000 00000098 2**0 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 00000098 2**0 ALLOC 3 .comment 00000027 0000000000000000 0000000000000000 00000098 2**0 CONTENTS, READONLY 4 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000bf 2**0 CONTENTS, READONLY 5 .note.gnu.property 00000020 0000000000000000 0000000000000000 000000c0 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .eh_frame 00000038 0000000000000000 0000000000000000 000000e0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA $> objdump -h b.o b.o: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .text 0000004f 0000000000000000 0000000000000000 00000040 2**0 CONTENTS, ALLOC, LOAD, READONLY, CODE 1 .data 00000004 0000000000000000 0000000000000000 00000090 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000000 0000000000000000 0000000000000000 00000094 2**0 ALLOC 3 .comment 00000027 0000000000000000 0000000000000000 00000094 2**0 CONTENTS, READONLY 4 .note.GNU-stack 00000000 0000000000000000 0000000000000000 000000bb 2**0 CONTENTS, READONLY 5 .note.gnu.property 00000020 0000000000000000 0000000000000000 000000c0 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .eh_frame 00000038 0000000000000000 0000000000000000 000000e0 2**3 CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA $> objdump -h ab ab: file format elf64-x86-64 Sections: Idx Name Size VMA LMA File off Algn 0 .interp 0000001c 0000000000000318 0000000000000318 00000318 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 1 .note.gnu.property 00000030 0000000000000338 0000000000000338 00000338 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 2 .note.gnu.build-id 00000024 0000000000000368 0000000000000368 00000368 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 3 .note.ABI-tag 00000020 000000000000038c 000000000000038c 0000038c 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .gnu.hash 00000024 00000000000003b0 00000000000003b0 000003b0 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 5 .dynsym 000000a8 00000000000003d8 00000000000003d8 000003d8 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 6 .dynstr 000000a3 0000000000000480 0000000000000480 00000480 2**0 CONTENTS, ALLOC, LOAD, READONLY, DATA 7 .gnu.version 0000000e 0000000000000524 0000000000000524 00000524 2**1 CONTENTS, ALLOC, LOAD, READONLY, DATA 8 .gnu.version_r 00000040 0000000000000538 0000000000000538 00000538 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 9 .rela.dyn 000000c0 0000000000000578 0000000000000578 00000578 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 10 .rela.plt 00000018 0000000000000638 0000000000000638 00000638 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 11 .init 0000001b 0000000000001000 0000000000001000 00001000 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 12 .plt 00000020 0000000000001020 0000000000001020 00001020 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 13 .plt.got 00000010 0000000000001040 0000000000001040 00001040 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 14 .plt.sec 00000010 0000000000001050 0000000000001050 00001050 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 15 .text 00000190 0000000000001060 0000000000001060 00001060 2**4 CONTENTS, ALLOC, LOAD, READONLY, CODE 16 .fini 0000000d 00000000000011f0 00000000000011f0 000011f0 2**2 CONTENTS, ALLOC, LOAD, READONLY, CODE 17 .rodata 00000004 0000000000002000 0000000000002000 00002000 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 18 .eh_frame_hdr 0000003c 0000000000002004 0000000000002004 00002004 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 19 .eh_frame 000000cc 0000000000002040 0000000000002040 00002040 2**3 CONTENTS, ALLOC, LOAD, READONLY, DATA 20 .init_array 00000008 0000000000003db8 0000000000003db8 00002db8 2**3 CONTENTS, ALLOC, LOAD, DATA 21 .fini_array 00000008 0000000000003dc0 0000000000003dc0 00002dc0 2**3 CONTENTS, ALLOC, LOAD, DATA 22 .dynamic 000001f0 0000000000003dc8 0000000000003dc8 00002dc8 2**3 CONTENTS, ALLOC, LOAD, DATA 23 .got 00000048 0000000000003fb8 0000000000003fb8 00002fb8 2**3 CONTENTS, ALLOC, LOAD, DATA 24 .data 00000014 0000000000004000 0000000000004000 00003000 2**3 CONTENTS, ALLOC, LOAD, DATA 25 .bss 00000004 0000000000004014 0000000000004014 00003014 2**0 ALLOC 26 .comment 00000026 0000000000000000 0000000000000000 00003014 2**0 CONTENTS, READONLY\"]},\"50\":{\"h\":\"1.3 符号地址的确定\",\"t\":[\"注\",\"在第一步的扫描和空间分配阶段，各个段在链接后的虚拟地址空间已经确定。比如\\\".text\\\"段的起始地址为0x0000000000001060，\\\".data\\\"段的起始地址为0x0000000000004000。因为各个符号在段内的相对位置时固定的，所以这时\\\"main\\\"、\\\"shared\\\"和\\\"swap\\\"的地址也已经确定了，连接器通过给每个符号加上一个偏移量，使它们能够调整到正确的虚拟地址。比如我们假设\\\"a.o\\\"中的\\\"main\\\"函数相对于\\\"a.o\\\"的\\\".text\\\"段的偏移量为X，但是经过链接合并后，\\\"a.o\\\"的\\\".text\\\"段位于虚拟地址空间0x0000000000001060(这里是链接成可执行文件ab后在可执行文件ab中的偏移量)，那么\\\"main\\\"函数的虚拟地址应该是0x0000000000001060+X。\"]},\"51\":{\"h\":\"2. 符号解析与重定位\"},\"52\":{\"h\":\"2.1 重定位\",\"t\":[\"注\",\"使用objdump -d查看反汇编结果\",\"$> objdump -d a.o a.o: file format elf64-x86-64 Disassembly of section .text.startup: 0000000000000000 <main>: 0: f3 0f 1e fa endbr64 4: 48 83 ec 18 sub $0x18,%rsp 8: 48 8d 35 00 00 00 00 lea 0x0(%rip),%rsi # f <main+0xf> 将shared地址写入第二个参数 f: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 16: 00 00 18: 48 89 44 24 08 mov %rax,0x8(%rsp) 1d: 31 c0 xor %eax,%eax 1f: 48 8d 7c 24 04 lea 0x4(%rsp),%rdi 24: c7 44 24 04 64 00 00 movl $0x64,0x4(%rsp) 2b: 00 2c: e8 00 00 00 00 call 31 <main+0x31> 31: 48 8b 44 24 08 mov 0x8(%rsp),%rax 36: 64 48 2b 04 25 28 00 sub %fs:0x28,%rax 3d: 00 00 3f: 75 07 jne 48 <main+0x48> 41: 31 c0 xor %eax,%eax 43: 48 83 c4 18 add $0x18,%rsp 47: c3 ret 48: e8 00 00 00 00 call 4d <main+0x4d>\",\"由于此时还并没有进行链接（即没有执行链接的第一步：虚拟地址内存分配）所以main的起始地址为0。 shared地址在反汇编代码的0x08字节处标记为0(8:48 8d 35 00 00 00 00 lea 0x0(%rip),%rsi)后面四字节就是该指令的下一条指令的偏移量。 swap调用处的地址在反汇编代码的0x2c字节处同样被标记为0(2c:e8 00 00 00 00 call 31 <main+0x31>)后面四个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。 此时的指令地址时暂时的，真正的地址计算工作留给了连接器。连接器在完成第一步的虚拟内存分配后就可以确定所有符号的虚拟地址了。\"]},\"53\":{\"h\":\"修正后的地址\",\"t\":[\"重要\",\"$> objdump -d ab ab: file format elf64-x86-64 ... # 截取了部分 Disassembly of section .text: 0000000000001060 <main>: 1060: f3 0f 1e fa endbr64 1064: 48 83 ec 18 sub $0x18,%rsp 1068: 48 8d 35 a1 2f 00 00 lea 0x2fa1(%rip),%rsi # 4010 <shared> 106f: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax 1076: 00 00 1078: 48 89 44 24 08 mov %rax,0x8(%rsp) 107d: 31 c0 xor %eax,%eax 107f: 48 8d 7c 24 04 lea 0x4(%rsp),%rdi 1084: c7 44 24 04 64 00 00 movl $0x64,0x4(%rsp) 108b: 00 108c: e8 0f 01 00 00 call 11a0 <swap> 1091: 48 8b 44 24 08 mov 0x8(%rsp),%rax 1096: 64 48 2b 04 25 28 00 sub %fs:0x28,%rax 109d: 00 00 109f: 75 07 jne 10a8 <main+0x48> 10a1: 31 c0 xor %eax,%eax 10a3: 48 83 c4 18 add $0x18,%rsp 10a7: c3 ret 10a8: e8 a3 ff ff ff call 1050 <__stack_chk_fail@plt> 10ad: 0f 1f 00 nopl (%rax) ...\",\"经过修正后\\\"shared\\\"和\\\"swap\\\"地址分别为0x4010和0x11a0\",\"shared的地址: 0x106f + 0x2fa1 = 0x4010 1068: 48 8d 35 a1 2f 00 00 lea 0x2fa1(%rip),%rsi 106f: 64 48 8b 04 25 28 00 mov %fs:0x28,%rax swap的地址: 0x1091 + 0x010f = 0x11a0 108c: e8 0f 01 00 00 call 11a0 <swap> 1091: 48 8b 44 24 08 mov 0x8(%rsp),%rax\"]},\"54\":{\"h\":\"2.2 重定位表\",\"t\":[\"注\",\"使用objdump/readelf指令可以查看重定位文件。因为重定位表其实就是elf文件中的一个段，因此又被称为重定位段，比如代码段\\\".text\\\"如果有要重定位的地方，那么会有一个相应的叫\\\".rel.text\\\"的段保存了代码段的重定位表，同理\\\".data\\\"也会有一个叫\\\".rel.data\\\"的段。\",\"# a.o中所有要重定位的地方，既“a.o”所有引用到的外部符号。 $> bjdump -r a.o a.o: file format elf64-x86-64 RELOCATION RECORDS FOR [.text.startup]: OFFSET TYPE VALUE 000000000000000b R_X86_64_PC32 shared-0x0000000000000004 # pc（下一条指令） - 0x04 000000000000002d R_X86_64_PLT32 swap-0x0000000000000004 0000000000000049 R_X86_64_PLT32 __stack_chk_fail-0x0000000000000004 RELOCATION RECORDS FOR [.eh_frame]: OFFSET TYPE VALUE 0000000000000020 R_X86_64_PC32 .text.startup $> readelf -r a.o Relocation section '.rela.text.startup' at offset 0x1e8 contains 3 entries: Offset Info Type Sym. Value Sym. Name + Addend 00000000000b 000400000002 R_X86_64_PC32 0000000000000000 shared - 4 00000000002d 000500000004 R_X86_64_PLT32 0000000000000000 swap - 4 000000000049 000600000004 R_X86_64_PLT32 0000000000000000 __stack_chk_fail - 4 Relocation section '.rela.eh_frame' at offset 0x230 contains 1 entry: Offset Info Type Sym. Value Sym. Name + Addend 000000000020 000200000002 R_X86_64_PC32 0000000000000000 .text.startup + 0\",\"每一个被重定位的地方叫一个重定位入口(Relocation Entry)，其中每个重定位表包含了一下信息：\",\"重定位入口的偏移(offset)，表示该入口在要被重定位段中的位置。\",\"该重定位表作用的elf文件中的那个段RELOCATION RECORDS FOR [.text.startup](比如这个就是代码段)。\",\"// 重定位表的结构 typedef struct { Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ } Elf64_Rel;\",\"重定位表结构\"]},\"55\":{\"h\":\"2.3 符号解析\",\"t\":[\"# 符号未定义错误 (未正确链接目标文件或者库文件导致) $> gcc a.c a.c: In function ‘main’: a.c:5:3: warning: implicit declaration of function ‘swap’ [-Wimplicit-function-declaration] 5 | swap(&a, &shared); | ^~~~ /usr/bin/ld: /tmp/ccwmM6Jl.o: warning: relocation against `shared' in read-only section `.text' /usr/bin/ld: /tmp/ccwmM6Jl.o: in function `main': a.c:(.text+0x29): undefined reference to `shared' /usr/bin/ld: a.c:(.text+0x39): undefined reference to `swap' /usr/bin/ld: warning: creating DT_TEXTREL in a PIE collect2: error: ld returned 1 exit status\",\"注\",\"重定位的过程也伴随着符号解析的过程。每个目标文件都可能定义一些符号，也可能引用其它目标文件的符号。重定位过程中，每个重定位入口都是对一个符号的引用，那么当连接器需要对某个符号的引用进行重定位时，就要确定这个符号的目的地址。这时候连接器就会查找所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。\",\"注\",\"需要补充的一点是linux链接器在符号解析阶段，链接器是从左到右按照它们在编译器取得程序命令行上出现的顺序来扫描可重定位目标文件和存档文件(静态库)的。链接器维护一个可重定位目标文件的集合E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号集合U（即引用了但尚未定义的符号），以及一个在前面输入文件中已定义的符号集合D。\",\"·对于命令行上的每个输入文件 f, 链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E, 修改U和D来反映f中的符号定义和引用，并继续下一个输入文件。\",\"·如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员m, 定义了一个符号来解析U中的一个引用，那将m加到么就E中，并且链接器修改U和D来反映m中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D都不再发生变化。此时，任何不包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。\",\"·如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位E中的目标文件，构建输出的可执行文件。\",\"这样的解析通常会伴随一个顺序问题，比如文件foo.c依赖与liba.a。当输入指令如下时就会出现符号未定义错误。\",\"# 错误的 $> gcc -static ./liba.a foo.c # 正确的 $> gcc -static foo.c ./liba.a\",\"因为链接器时从左到右开始扫描的，而静态库文件（存档文件）liba.a先于foo.c文件所以就会执行上述的存档文件的操作导致foo.c依赖的文件不会并入集合中。最终导致符号未定义行为，特别是出现相互依赖的库文件时更容易出现这种错误。 foo.c 依赖 liba.a, liba.a 依赖 libb.a, libb.a 依赖 liba.a\",\"# 错误的 $> gcc -static foo.c ./liba.a ./libb.a # 正确的 $> gcc -static foo.c ./liba.a ./libb.a ./liba.a\",\"csapp 第七章 7.6.3\",\"使用readelf -s指令查看a.o的符号表:\",\"$> readelf -s a.o Symbol table '.symtab' contains 7 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 FILE LOCAL DEFAULT ABS a.c 2: 0000000000000000 0 SECTION LOCAL DEFAULT 1 .text 3: 0000000000000000 88 FUNC GLOBAL DEFAULT 1 main 4: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND shared 5: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND swap 6: 0000000000000000 0 NOTYPE GLOBAL DEFAULT UND __stack_chk_fail\",\"重要\",\"GLOBAL类型的符号，除了\\\"main\\\"函数是定义在代码段之外，其它几个\\\"shared\\\"，\\\"swap\\\"，\\\"__stack_chk_fail\\\"都是UND（undefined）未定义的类型，这种未定义的符号都是该目标文件的重定位项。所以在链接器扫描完所有的输入目标文件后，所有这些未定义的符号都应该能在全局符号表中找到，否则链接就会报符号未定义错误。\"]},\"56\":{\"h\":\"2.4 指令修正方式(参考csapp，原书第七章 7.7)\",\"t\":[\"// csapp提到的另一种重定位结构 // r_addend: 有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。 typedef struct { Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ Elf64_Sxword r_addend; /* Addend */ } Elf64_Rela;\",\"elf定义了32种不同的重定位类型。我们只关心其中两种最基本的重定位类型：\",\"R_X86_64_PC32。重定位一个使用32位PC相对地址的引用。一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址，PC值通常是下一条指令在内存中的值。\",\"R_X86_64_32。重定位一个使用32位绝对地址的引用。CPU直接使用在指令中编码的32值作为有效地址，不需要进一步修改。\",\"重要\",\"这两种重定位类型支持x86-64小型代码模型(small code model)，该模型假设可执行目标文件中的代码和数据的总体大小小于2GB，因此在运行时可以用32位PC相对地址来访问。GCC默认使用小型代码模型。大于2GB的程序可以使用-mcmodel=medium(中型代码模型)和-mcmodel=large(大型代码模型)标志来编译。\",\"foreach section s { foreach relocation entry r { refptr = s + r.offset; // 需要修改的重定位地址 if (r.type == R_X86_64_PC32) { refaddr = ADDR(s) + r.offset; // 运行时引用符号的地址 *refptr = (unsigned)(ADDR(r.symbol) + r.addend - refaddr); // 被引用的符号地址 + 修正值 - 运行时引用符号地址。 } if (r.type == R_X86_64_32) { *refptr = (unsigned)(ADDR(r.symbol) + r.addend); } } }\"]},\"57\":{\"h\":\"3. COMMON块\",\"t\":[\"注\",\"COMMON块的机制来源于Fortran，早期的Fortran没有动态分配空间的机制，所以必须事先声明它所需的临时使用空间的大小。Fortran把这种空间叫COMMON块，当不同的目标文件需要的COMMON块空间大小不一致时，以最大的那块为准。 现代的链接机制在处理弱符号时，采用的就是与COMMON块一样的机制。当然COMMON块的链接规则仅仅是针对弱符号的，如果其中有一个符号为强符号时，那么最终输出结果中的符号所占空间与强符号相同。 值得注意的是，如果链接过程中有弱符号大于强符号所使用的内存大小，那么链接器通常会给出警告。 /usr/bin/ld: warning: alignment 4 of symbol `global' in /tmp/ccjFgL1Q.o is smaller than 8 in /tmp/ccVEFqSm.o\",\"另外值得注意的是可能有些编译器并不是将弱符号使用COMMON块，而是使用的bss段，因此会报重定义错误。此时可以给编译选项加上--common选项即可。\"]},\"58\":{\"h\":\"4. 静态库链接\",\"t\":[\"注\",\"静态库可以简单的看成一组目标文件的集合，既很多目标文件经过压缩打包后形成的一个文件。\",\"使用\\\"ar\\\"工具查看这个文件包含了那些目标文件：\",\"$> ar -t /usr/lib/x86_64-linux-gnu/libc.a\",\"使用objdump指令查看某个符号在那个文件中\",\"$> objdump -t /usr/lib/x86_64-linux-gnu/libc.a | grep vprintf vprintf.o: file format elf64-x86-64 0000000000000000 g F .text 0000000000000018 __vprintf 0000000000000000 g F .text 0000000000000018 vprintf 0000000000000160 g F .text 00000000000001c9 .hidden __obstack_vprintf_internal 0000000000000330 g F .text 00000000000001c4 __obstack_vprintf 0000000000000330 w F .text 00000000000001c4 obstack_vprintf vprintf_chk.o: file format elf64-x86-64 0000000000000000 g F .text 0000000000000019 ___vprintf_chk 0000000000000000 g F .text 0000000000000019 __vprintf_chk 0000000000000000 *UND* 0000000000000000 .hidden __obstack_vprintf_internal 0000000000000000 g F .text 000000000000001c __obstack_vprintf_chk 0000000000000000 *UND* 0000000000000000 .hidden __obstack_vprintf_interna\"]},\"59\":{\"h\":\"第四章 可执行文件的装载\"},\"60\":{\"h\":\"1. 装载的方式\"},\"61\":{\"h\":\"1.1 覆盖装入\",\"t\":[\"注\",\"覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手工将程序分割成若干块，然后编写一个小的辅助代码工具来管理这些模块何时应该驻留内存何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器(Overlay Manager)。\"]},\"62\":{\"h\":\"1.2 页映射\",\"t\":[\"注\",\"建议阅读csapp 第九章 虚拟内存\"]},\"63\":{\"h\":\"2. 从操作系统角度看可执行文件的装载\"},\"64\":{\"h\":\"2.1 进程的建立\",\"t\":[\"创建一个独立的虚拟地址空间。\",\"创建虚拟地址空间实际上只是分配一个页目录(Page Directory)就可以了，甚至不需要设置页映射关系。这些映射关系可以等到页错误时再进行映射。这一步中映射的是虚拟空间到实际物理内存的映射关系。\",\"读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。\",\"这一步所做的是虚拟空间与可执行文件的映射关系。当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正确运行。所以当操作系统捕获到也错误发生时，应当知道所需的页在可执行文件中的那一个位置。这就是传统意义的“装载”过程。\",\"假设我们的ELF可执行文件只有一个代码段\\\".text\\\"，它的虚拟地址为0x08048000，它在文件中的大小为0x000e1，对齐为0x1000。由于虚拟存储的也映射都是以页为单位，在32为的Intel IA32下一般为4096字节，所以32位ELF的对齐粒度为0x1000。所以.text段对齐后实际占用的虚拟内存大小为0x1000。一旦该可执行文件被装载，可执行文件与执行该可执行文件进程的虚拟空间映射关系如下： 这种映射关系只是保存在操作系统内部的一个数据结构。linux中将进程虚拟空间中的一个段叫做虚拟内存区域(VAM, Virtual Memory Area)。操作系统创建进程后，会在进程相应的数据结构中设置一个.text段的VMA；它在虚拟空间中的地址为0x08040800~0x08049000，它对应ELF文件中偏移为0的.text，它的属性为只读。\",\"将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。\",\"从进程的角度看这一步可以简单的认为操作系统执行了一条跳转指令，直接跳转到可执行文件的入口地址(ELF文件头中保存有入口地址)。\"]},\"65\":{\"h\":\"2.2 页错误\",\"t\":[\"注\",\"进程建立完成后，其实可执行文件的真正指令和数据都没有被装入到内存中。操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚拟内存之间的映射关系。当CPU开始执行指令时，会发现对应页面是一个空页面，从而触发页错误(Page Fault)。CPU将控制权交给操作系统，操作系统处理页错误时，就会使用装载过程的中建立的可执行文件与虚拟内存的映射关系从而找到空页所在的VMA，计算出相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程与中该虚拟内存页与分配的物理内存页建立映射关系，然后把控制权返还给进程，进程从刚才页错误的位置重新开始执行。\",\"页错误\"]},\"66\":{\"h\":\"3. 进程虚拟空间分布\"},\"67\":{\"h\":\"3.1 ELF文件链接视图和执行视图\",\"t\":[\"重要\",\"从操作系统装载可执行文件的角度看，它只关心一些和装载相关的问题，最主要的时段的权限（可读、可写和可执行）。\",\"以代码段为代表的权限为可读可执行段\",\"以数据段和bss段位代表的权限为可读可写段\",\"以只读数据为代表的权限为只读段\",\"那么我们可以对于相同的段，把它们合并到一起当作一个段进行映射。比如有两个段分别叫\\\".text\\\"和\\\".init\\\"，它们包含的分别是程序的可执行代码和初始化代码，并且它们的权限相同，都是可读可执行。假设.text为4097字节，.init为512字节，这两个段分别映射的话要占用三个页面，但是，如果将它们合并成一起映射的话只需要两个页面。\",\"注\",\"ELF可执行文件引入了一个概念叫做“segment”，一个“segment”包含一个或多个属性类似的“section”。比如上面提到的“.text”段和“.init”段合并在一起看做是一个“segment”，那么装载的时候就可以将它们看作一个整体一起映射，也就是所映射之后在进程虚拟内存中只有一个相对应的vma，而不是两个，这样做的好处是可以明显减少页面内部内存碎片，从而节省内存空间。\",\"// SectionMapping.c #include <unistd.h> int main() { while (1) { sleep(1000); } return 0; } // gcc -static SectionMapping.c -o SectionMapping.elf\",\"$> gcc -static SectionMapping.c -o SectionMapping.elf $> readelf -S SectionMapping.elf There are 28 section headers, starting at offset 0xbf510: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .note.gnu.pr[...] NOTE 0000000000400270 00000270 0000000000000030 0000000000000000 A 0 0 8 [ 2] .note.gnu.bu[...] NOTE 00000000004002a0 000002a0 0000000000000024 0000000000000000 A 0 0 4 [ 3] .note.ABI-tag NOTE 00000000004002c4 000002c4 0000000000000020 0000000000000000 A 0 0 4 [ 4] .rela.plt RELA 00000000004002e8 000002e8 0000000000000210 0000000000000018 AI 0 20 8 [ 5] .init PROGBITS 0000000000401000 00001000 000000000000001b 0000000000000000 AX 0 0 4 [ 6] .plt PROGBITS 0000000000401020 00001020 0000000000000160 0000000000000000 AX 0 0 16 [ 7] .text PROGBITS 0000000000401180 00001180 000000000007d521 0000000000000000 AX 0 0 64 [ 8] .fini PROGBITS 000000000047e6a4 0007e6a4 000000000000000d 0000000000000000 AX 0 0 4 [ 9] .rodata PROGBITS 000000000047f000 0007f000 000000000001c1a4 0000000000000000 A 0 0 32 [10] .stapsdt.base PROGBITS 000000000049b1a4 0009b1a4 0000000000000001 0000000000000000 A 0 0 1 [11] rodata.cst32 PROGBITS 000000000049b1c0 0009b1c0 0000000000000060 0000000000000020 AM 0 0 32 [12] .eh_frame PROGBITS 000000000049b220 0009b220 00000000000096f0 0000000000000000 A 0 0 8 [13] .gcc_except_table PROGBITS 00000000004a4910 000a4910 00000000000000dc 0000000000000000 A 0 0 1 [14] .tdata PROGBITS 00000000004a5f50 000a4f50 0000000000000018 0000000000000000 WAT 0 0 8 [15] .tbss NOBITS 00000000004a5f68 000a4f68 0000000000000040 0000000000000000 WAT 0 0 8 [16] .init_array INIT_ARRAY 00000000004a5f68 000a4f68 0000000000000008 0000000000000008 WA 0 0 8 [17] .fini_array FINI_ARRAY 00000000004a5f70 000a4f70 0000000000000010 0000000000000008 WA 0 0 8 [18] .data.rel.ro PROGBITS 00000000004a5f80 000a4f80 0000000000003fc8 0000000000000000 WA 0 0 32 [19] .got PROGBITS 00000000004a9f48 000a8f48 0000000000000090 0000000000000000 WA 0 0 8 [20] .got.plt PROGBITS 00000000004a9fe8 000a8fe8 00000000000000c8 0000000000000008 WA 0 0 8 [21] .data PROGBITS 00000000004aa0c0 000a90c0 0000000000001a08 0000000000000000 WA 0 0 32 [22] .bss NOBITS 00000000004abae0 000aaac8 0000000000005768 0000000000000000 WA 0 0 32 [23] .comment PROGBITS 0000000000000000 000aaac8 0000000000000026 0000000000000001 MS 0 0 1 [24] .note.stapsdt NOTE 0000000000000000 000aaaf0 00000000000015a0 0000000000000000 0 0 4 [25] .symtab SYMTAB 0000000000000000 000ac090 000000000000bc10 0000000000000018 26 711 8 [26] .strtab STRTAB 0000000000000000 000b7ca0 000000000000775f 0000000000000000 0 0 1 [27] .shstrtab STRTAB 0000000000000000 000bf3ff 000000000000010c 0000000000000000 0 0 1 Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), R (retain), D (mbind), l (large), p (processor specific)\",\"使用readelf -l指令查看ELF文件的“segment”。正如描述“section”属性的结构叫做段表，描述“segment”的结构叫程序头(Program Header)。\",\"$> readelf -l SectionMapping.elf Elf file type is EXEC (Executable file) Entry point 0x401720 There are 10 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000400000 0x0000000000400000 0x00000000000004f8 0x00000000000004f8 R 0x1000 LOAD 0x0000000000001000 0x0000000000401000 0x0000000000401000 0x000000000007d6b1 0x000000000007d6b1 R E 0x1000 LOAD 0x000000000007f000 0x000000000047f000 0x000000000047f000 0x00000000000259ec 0x00000000000259ec R 0x1000 LOAD 0x00000000000a4f50 0x00000000004a5f50 0x00000000004a5f50 0x0000000000005b78 0x000000000000b2f8 RW 0x1000 NOTE 0x0000000000000270 0x0000000000400270 0x0000000000400270 0x0000000000000030 0x0000000000000030 R 0x8 NOTE 0x00000000000002a0 0x00000000004002a0 0x00000000004002a0 0x0000000000000044 0x0000000000000044 R 0x4 TLS 0x00000000000a4f50 0x00000000004a5f50 0x00000000004a5f50 0x0000000000000018 0x0000000000000058 R 0x8 GNU_PROPERTY 0x0000000000000270 0x0000000000400270 0x0000000000400270 0x0000000000000030 0x0000000000000030 R 0x8 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x00000000000a4f50 0x00000000004a5f50 0x00000000004a5f50 0x00000000000040b0 0x00000000000040b0 R 0x1 Section to Segment mapping: Segment Sections... 00 .note.gnu.property .note.gnu.build-id .note.ABI-tag .rela.plt 01 .init .plt .text .fini 02 .rodata .stapsdt.base rodata.cst32 .eh_frame .gcc_except_table 03 .tdata .init_array .fini_array .data.rel.ro .got .got.plt .data .bss 04 .note.gnu.property 05 .note.gnu.build-id .note.ABI-tag 06 .tdata .tbss 07 .note.gnu.property 08 09 .tdata .init_array .fini_array .data.rel.ro .got # 这个可执行文件共有10个segment。从装载的角度看，我们只关心“LOAD”类型的segment，因为只有它是需要被映射的，其它类型的都是装载时起辅助作用。\",\"“segment”和“section”是从不同角度来划分同一个elf文件。这个在elf中被称为不同的视图(view)，从“section”的角度来看elf文件就是链接视图(linking view)，从“segment“的角度来看就是执行视图(exectuion view)。\",\"elf可执行文件与进程虚拟空间映射关系\",\"elf可执行文件有一个专门的数据结构叫做==程序头表(program header table)==用来保存”segment“的信息。因为elf目标文件不需要被装载，所以它没有程序头表，而可执行文件和共享库文件都有。和段表结构一样，程序头表也是一个结构体数组。\",\"// elf.h typedef struct { Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */ } Elf64_Phdr;\",\" 对于“LOAD”类型的“segment”来说，p_memsz的值不可以小于p_filesz，否则就是不合理的。如果p_memsz大于p_filesz，就表示该“segment”在内存中所分配的空间大小超过文件中实际的大小，这部分“多余“的部分则全部填充为”0“。因此我们在构造elf可执行文件时不需要再额外设立bss的”segment“了，可以把数据”segment“的p_memsz扩大，那些额外的部分就是bss。\"]},\"68\":{\"h\":\"3.2 堆和栈\",\"t\":[\"查看可执行文件的堆栈。\",\"$> ./SectionMapping.elf & [1] 669 $> cat /proc/669/maps 00400000-00401000 r--p 00000000 08:10 116178 /home/far/worker/linker/chapter04/SectionMapping.elf 00401000-0047f000 r-xp 00001000 08:10 116178 /home/far/worker/linker/chapter04/SectionMapping.elf 0047f000-004a5000 r--p 0007f000 08:10 116178 /home/far/worker/linker/chapter04/SectionMapping.elf 004a5000-004aa000 r--p 000a4000 08:10 116178 /home/far/worker/linker/chapter04/SectionMapping.elf 004aa000-004ac000 rw-p 000a9000 08:10 116178 /home/far/worker/linker/chapter04/SectionMapping.elf 004ac000-004b2000 rw-p 00000000 00:00 0 01ebb000-01edd000 rw-p 00000000 00:00 0 [heap] 7ffdee8a2000-7ffdee8c3000 rw-p 00000000 00:00 0 [stack] 7ffdee99f000-7ffdee9a3000 r--p 00000000 00:00 0 [vvar] 7ffdee9a3000-7ffdee9a4000 r-xp 00000000 00:00 0 [vdso]\",\"注\",\"第一列是VMA的地址范围；第二列是VMA的权限，“r”表示可读，“w”表示可写，“x”表示可执行，“p”表示私有(COW, Copy on Write)。“s”表示共享。第三列是偏移，表示VMA对应的segment在可执行文件中的偏移；第四列表示可执行文件所在设备的主设备号和次设备号；第五列表示可执行文件的节点号。最后一列是可执行文件的路径。\",\"观察到进程中10个VMA中只有前五个是映射到可执行文件中的两个segment。另外三个所在的设备号和次设备号以及文件节点都是0，则表示它们没有映射到文件中，这种VMA叫做匿名虚拟内存区域(Anonymous Virtual Memory Area)。\",\"重要\",\"操作系统通过给进程空间划出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。\",\"代码VMA，可读可执行，有映像文件\",\"数据VAM，可读可写可执行，有映像文件\",\"堆VMA，可读可写可执行，无映像文件，匿名，可向上扩展\",\"栈VMA，可读可写、不可执行，无映像文件，匿名，可向下扩展。\",\"ELF与Linux进程虚拟空间映射关系\"]},\"69\":{\"h\":\"3.3 段地址对齐\",\"t\":[\"段\",\"长度\",\"偏移\",\"权限\",\"seg0\",\"127\",\"34\",\"可读可执行\",\"seg1\",\"9899\",\"164\",\"可读可写\",\"seg2\",\"1988\",\"只读\",\"使用最简单的映射将每个段分开映射，对于长度不足一页的按一页占用。所以整个可执行文件只有12014字节却占用了5个页，即20480字节，空间使用率只有58.6%。为了解决这个问题unix系统让那些各个段接壤部分共享一个物理页，然后将该物理页分别映射两次。比如seg0和seg1的接壤部分的那个物理页，系统将它们映射两份到虚拟地址空间，一份seg0，另一份seg1，其它的页都按照正常的页进行映射。unix系统将elf的文件头也看做是系统的一个段，将其映射到进程的地址空间，这样做的好处是进程中的某一段区域就是整个elf文件的映射，对于一些必须要访问elf文件头的操作（比如动态链接器就必须读取elf文件头）可以直接通过读写内存地址空间进行。在这种情况下，内存空间得到了充分利用，本来需要5个物理页的现在只需要3个物理页。这种映射情况下对于一个物理页来说可能同时包含多个段。\",\"物理页普通映射\",\"物理页多次映射\"]},\"70\":{\"h\":\"3.4 进程栈初始化\",\"t\":[\"假设系统中有两环境变量:\",\"HOME=/home/user\",\"PATH=/usr/bin 执行指令\",\"$> prog 123\",\" 栈指针寄存器esp（x86_64应该为rip）指向的位置是初始化以后堆栈的顶部，最前面四个字节表示命令行参数的数量，即\\\"prog\\\"和\\\"123\\\"，紧接的就是指向这两个参数字符串的指针，后面跟一个0，接着是两个指向环境变量的字符串的指针，后面紧跟一个0表示结束。\"]},\"71\":{\"h\":\"第五章 动态链接\"},\"72\":{\"h\":\"1. 什么是动态链接\",\"t\":[\"重要\",\"把链接的过程推迟到运行时进行，这就是动态链接(Dynamic Linking)的基本思想。 需要注意的是，程序与动态库之间真正的链接工作是由动态链接器完成的，而不静态链接器ld完成。\"]},\"73\":{\"h\":\"2. 简单的动态链接例子\",\"t\":[\"// Program1.c #include \\\"Lib.h\\\" int main() { foobar(1); return 0; } // Program2.c #include \\\"Lib.h\\\" int main() { foobar(2); return 0; } // Lib.c #include <stdio.h> void foobar(int i) { printf(\\\"Printing from Lib.so %d\\\\n\\\", i); } // Lib.h #ifndef __LIB_H__ #define __LIB_H__ void foobar(int i); #endif\",\"使用GCC将Lib.c编译成一个共享对象文件:\",\"# shared 表示产生共享对象 # -fPIC 表示生成位置无关代码 $> gcc -fPIC -shared -o Lib.so Lib.c # 分别编译链接Program1和Program2 $> gcc -o Program1 Program1.c ./Lib.so $> gcc -o Program2 Program2.c ./Lib.so\",\"动态链接过程\",\"重要\",\"Lib.c被链接成Lib.so共享对象文件，Program1.c被编译成Program1.o之后，链接成为可指向文件Program1。但是和静态链接不同的是，Program1.o被链接成可执行文件这一步。在静态链接中，链接过程会把Program1.o和Lib.o链接到一起，并且输出可执行文件Program1。但是对于动态链接，Lib.o没有被链接起来，链接的输入目标只有Program1.o。但是命令行中又发现Lib.so也参与了链接过程？ 当程序模块Program1.c被编译成Program1.o时，编译器还不知道foobar()函数的地址。当链接器将Program1.o链接成可执行文件时，这时候链接器必须确定foobar()函数的性质。如果foobar()函数是一个定义于静态目标模块中的函数，那么链接器将会按照静态链接的规则，将Program1.o中的foobar()地址引用重定位。如果foobar()是一个定义在动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号，不对其进行地址重定位，把这个过程保留到装载时进行。 对于链接器是如何知道foobar()函数的引用是一个静态符号还是动态符号？这其实就是我们要用到Lib.so的原因。Lib.so保留了完整的符号信息（因为运行时进行动态链接还需要使用符号信息），把Lib.so也作为链接的输入文件之一，链接器在解析符号时就可以知道：foobar()函数是一个定义在Lib.so的动态符号。这样链接器就可以堆foobar()函数的引用进行特殊处理，使它成为一个对动态符号的引用。\",\"动态链接程序运行时地址空间分布\",\"注\",\"对于静态链接的可执行文件，整个进程只有可执行文件需要被映射。但是对于动态链接来说，除了可执行文件之外，还有它所依赖的共享目标文件。\",\"对Lib.c的foobar()函数进行修改\",\"// Lib.c #include <stdio.h> #include <unistd.h> void foobar(int i) { printf(\\\"Printing from Lib.so %d\\\\n\\\", i); sleep(-1); }\",\"$> ./Program1 & [1] 10370 Printing from Lib.so 1 $> cat /proc/10370/maps 5611c3c79000-5611c3c7a000 r--p 00000000 08:10 117001 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Program1 5611c3c7a000-5611c3c7b000 r-xp 00001000 08:10 117001 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Program1 5611c3c7b000-5611c3c7c000 r--p 00002000 08:10 117001 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Program1 5611c3c7c000-5611c3c7d000 r--p 00002000 08:10 117001 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Program1 5611c3c7d000-5611c3c7e000 rw-p 00003000 08:10 117001 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Program1 5611c5450000-5611c5471000 rw-p 00000000 00:00 0 [heap] 7f066eb09000-7f066eb0c000 rw-p 00000000 00:00 0 7f066eb0c000-7f066eb34000 r--p 00000000 08:10 49449 /usr/lib/x86_64-linux-gnu/libc.so.6 7f066eb34000-7f066ecbc000 r-xp 00028000 08:10 49449 /usr/lib/x86_64-linux-gnu/libc.so.6 7f066ecbc000-7f066ed0b000 r--p 001b0000 08:10 49449 /usr/lib/x86_64-linux-gnu/libc.so.6 7f066ed0b000-7f066ed0f000 r--p 001fe000 08:10 49449 /usr/lib/x86_64-linux-gnu/libc.so.6 7f066ed0f000-7f066ed11000 rw-p 00202000 08:10 49449 /usr/lib/x86_64-linux-gnu/libc.so.6 7f066ed11000-7f066ed1e000 rw-p 00000000 00:00 0 7f066ed25000-7f066ed26000 r--p 00000000 08:10 116994 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Lib.so 7f066ed26000-7f066ed27000 r-xp 00001000 08:10 116994 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Lib.so 7f066ed27000-7f066ed28000 r--p 00002000 08:10 116994 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Lib.so 7f066ed28000-7f066ed29000 r--p 00002000 08:10 116994 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Lib.so 7f066ed29000-7f066ed2a000 rw-p 00003000 08:10 116994 /home/far/worker/linker/chapter04/SimpleDynamicalLinking/Lib.so 7f066ed2a000-7f066ed2c000 rw-p 00000000 00:00 0 7f066ed2c000-7f066ed2d000 r--p 00000000 08:10 49446 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f066ed2d000-7f066ed58000 r-xp 00001000 08:10 49446 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f066ed58000-7f066ed62000 r--p 0002c000 08:10 49446 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f066ed62000-7f066ed64000 r--p 00036000 08:10 49446 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7f066ed64000-7f066ed66000 rw-p 00038000 08:10 49446 /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 7ffe6cfa3000-7ffe6cfc4000 rw-p 00000000 00:00 0 [stack] 7ffe6cfe6000-7ffe6cfea000 r--p 00000000 00:00 0 [vvar] 7ffe6cfea000-7ffe6cfeb000 r-xp 00000000 00:00 0 [vdso] $> kill 10370 [1] + 10370 terminated ./Program1\",\"观察到整个虚拟地址空间中，多出了几个文件的映射。Lib.so与Program1一样，它们都是被操作系统用同样的方法映射至进程的虚拟地址空间。Program1除了使用Lib.so外，还是用到了动态链接形式的C语言运行时库(/usr/lib/x86_64-linux-gnu/libc.so.6)。还有Linux下的动态链接器(/usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2)。动态链接器和普通共享对象一样被映射到进程的地址空间，在系统开始运行Program1之前，首先将控制权交给动态链接器，由它完成所有的动态链接工作后再把控制权交给Program1，最后开始执行。\",\"通过readelf查看Lib.so的装载属性:\",\"$> readelf -l Lib.so Elf file type is DYN (Shared object file) Entry point 0x0 There are 11 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000560 0x0000000000000560 R 0x1000 LOAD 0x0000000000001000 0x0000000000001000 0x0000000000001000 0x000000000000017d 0x000000000000017d R E 0x1000 LOAD 0x0000000000002000 0x0000000000002000 0x0000000000002000 0x00000000000000dc 0x00000000000000dc R 0x1000 LOAD 0x0000000000002df8 0x0000000000003df8 0x0000000000003df8 0x0000000000000220 0x0000000000000228 RW 0x1000 DYNAMIC 0x0000000000002e08 0x0000000000003e08 0x0000000000003e08 0x00000000000001c0 0x00000000000001c0 RW 0x8 NOTE 0x00000000000002a8 0x00000000000002a8 0x00000000000002a8 0x0000000000000020 0x0000000000000020 R 0x8 NOTE 0x00000000000002c8 0x00000000000002c8 0x00000000000002c8 0x0000000000000024 0x0000000000000024 R 0x4 GNU_PROPERTY 0x00000000000002a8 0x00000000000002a8 0x00000000000002a8 0x0000000000000020 0x0000000000000020 R 0x8 GNU_EH_FRAME 0x000000000000201c 0x000000000000201c 0x000000000000201c 0x000000000000002c 0x000000000000002c R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000002df8 0x0000000000003df8 0x0000000000003df8 0x0000000000000208 0x0000000000000208 R 0x1 Section to Segment mapping: Segment Sections... 00 .note.gnu.property .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 01 .init .plt .plt.got .plt.sec .text .fini 02 .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .dynamic .got .got.plt .data .bss 04 .dynamic 05 .note.gnu.property 06 .note.gnu.build-id 07 .note.gnu.property 08 .eh_frame_hdr 09 10 .init_array .fini_array .dynamic .got\",\"注\",\"除了文件类型与普通程序不同之外，其它几乎与普通程序一样。还有一点不同的是，动态链接模块的装载地址是从地址0x0000000000000000开始的。我们知道这个地址是无效地址，并且从上面的进程虚拟空间分布看到，Lib.so的最终装载地址并不是0x0000000000000000，而是0x7f066ed25000。从这一点可以推断，共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址空间的空闲情况，动态的分配一块足够大小的地址空间给相应的共享对象。\"]},\"74\":{\"h\":\"3. 地址无关代码\"},\"75\":{\"h\":\"3.1 固定装载地址的困扰\",\"t\":[\"注\",\"为了实现动态链接，我们首先会遇到的问题是共享对象地址冲突问题。在动态链接的情况下，如果不同的模块目标装载地址都一样是不行的。而对于单个程序来说，我们可以手工指定各个模块的地址，比如0x1000到0x2000分配给模块A，把地址0x2000到0x3000分配给模块B。但是，如果某个模块被多个程序使用，或者多个模块被多个程序使用呢？这将会使得管理这些模块的地址将是一件无比繁琐的事情。 例如程序program1使用了模块B，但是没有使用模块A，所以他认为地址0x1000到0x2000的地址是空闲的，余数分配给了另一个模块C。这样C和原先的模块A的目标地址就冲突了，任何人以后将不能在同一个程序里面使用模块A和C。这种做法就叫做静态共享库(Static Shared Library)。相比于静态链接，静态共享库的做法就是将程序的各个模块统一交给操作系统管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。 静态共享库的目标地址导致了很多问题，除了地址冲突外，静态共享库的升级也是问题，因为升级后的共享库必须保持共享库中全局函数和变量地址的不变，如果应用程序在链接时已经绑定了这些地址，一旦变更，就必须重新链接应用程序，否则就会引起应用程序崩溃。即使升级静态共享库后保持原有的函数和变量地址不变，只是增加了一些全局函数或变量，也会受到限制，因为静态共享库被分配到的虚拟地址空间是有限的，不能增长太多，否则就会超出被分配的空间。 为了解决这个模块装载地址固定的问题，我们设想是否可以让共享对象在任意地址加载？既共享对象在编译时不能假设自己在进程虚拟地址空间中的位置。对于可执行文件基本可以确定自己在进程虚拟空间中的起始位置，因为可执行文件往往是第一个被加载的文件。\"]},\"76\":{\"h\":\"3.2 装载时重定位\",\"t\":[\"重要\",\"在链接时，对所有绝对地址的引用不做重定位，而把这一步推迟到装载时完成。一旦模块装载地址确定，既目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 静态链接时的重定位被称为链接时重定位(Link Time Relocation)，而现在这种情况通常被称为装载时重定位(Load Time Relocation)。 装载时重定位的问题：动态链接模块被装载至虚拟空间后，指令部分是在多个进程之间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令部分对于每个进程来说可能会被映射到每个进程的不同虚拟空间，从而导致这些地址对每个进程来说是不同的。而对于可修改数据部分来说每个进程都有不同的副本，所以可以使用装载时重定位的方法来处理。 Linux的GCC编译器支持这种装载时重定位的方法，在编译时可以只使用-shared选项而不使用-fPIC选项。\"]},\"77\":{\"h\":\"3.3 地址无关代码\",\"t\":[\"注\",\"装载时重定位是解决动态模块中没有绝对地址应用的办法之一，但是有一个很大的缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。 现在我们希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以我们只需要将指令中那些需要被修改的部分进行剥离，和数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。这种方案就是地址无关代码(PIC, Position-Independent Code)。\",\"将共享对象中的地址引用按照是否跨模块分为: 模块内部引用和模块外部引用。\",\"按照不同的引用方式又分为：指令引用和数据访问。\",\"因此有如下方式:\",\"模块内部的函数调用、跳转等。\",\"模块内部的数据访问，比如模块中定义的全局变量、静态变量。\",\"模块外部的函数调用、跳转等。\",\"模块外部的数据访问，比如其它模块中定义的全局变量。\",\"bar为非静态函数时\",\"// pic.c static int a; extern int b; extern void ext(); void bar() { a = 1; // 模块内部数据访问 b = 2; // 模块外部数据访问 } void foo() { bar(); // 模块内部函数调用 ext(); // 模块外部函数调用 }\",\"$> gcc -shared -fPIC pic.c -o libpic.so\",\"Disassembly of section .plt.sec: 0000000000001060 <ext@plt>: 1060: f3 0f 1e fa endbr64 1064: ff 25 96 2f 00 00 jmp *0x2f96(%rip) # 4000 <ext> 106a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000001070 <bar@plt>: 1070: f3 0f 1e fa endbr64 1074: ff 25 8e 2f 00 00 jmp *0x2f8e(%rip) # 4008 <bar+0x2ecf> 107a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000001139 <bar>: 1139: f3 0f 1e fa endbr64 113d: c7 05 d5 2e 00 00 01 movl $0x1,0x2ed5(%rip) # 401c <a> 1144: 00 00 00 1147: 48 8b 05 72 2e 00 00 mov 0x2e72(%rip),%rax # 3fc0 <b> 114e: c7 00 02 00 00 00 movl $0x2,(%rax) 1154: c3 ret 0000000000001155 <foo>: 1155: f3 0f 1e fa endbr64 1159: 48 83 ec 08 sub $0x8,%rsp 115d: b8 00 00 00 00 mov $0x0,%eax 1162: e8 09 ff ff ff call 1070 <bar@plt> 1167: b8 00 00 00 00 mov $0x0,%eax 116c: e8 ef fe ff ff call 1060 <ext@plt> 1171: 48 83 c4 08 add $0x8,%rsp 1175: c3 ret\",\"bar静态函数时\",\"static int a; extern int b; extern void ext(); static void bar() { a = 1; // 模块内部数据访问 b = 2; // 模块外部数据访问 } void foo() { bar(); // 模块内部函数调用 ext(); // 模块外部函数调用 }\",\"$> gcc -shared -fPIC pic.c -o libpic.so\",\"0000000000001119 <bar>: 1119: c7 05 f1 2e 00 00 01 movl $0x1,0x2ef1(%rip) # 4014 <a> 1120: 00 00 00 1123: 48 8b 05 96 2e 00 00 mov 0x2e96(%rip),%rax # 3fc0 <b> 112a: c7 00 02 00 00 00 movl $0x2,(%rax) 1130: c3 ret 0000000000001131 <foo>: 1131: f3 0f 1e fa endbr64 1135: 48 83 ec 08 sub $0x8,%rsp 1139: b8 00 00 00 00 mov $0x0,%eax 113e: e8 d6 ff ff ff call 1119 <bar> 1143: b8 00 00 00 00 mov $0x0,%eax 1148: e8 03 ff ff ff call 1050 <ext@plt> 114d: 48 83 c4 08 add $0x8,%rsp 1151: c3 ret\",\"类型一 模块内部调用或跳转\",\"注\",\"根据objdump反汇编后得到的结果和书中列出的不太一样。实际汇编得到的结果是使用了共享对象全局符号介入(Global Symbol Interposition)。在动态链接的实现中会提到。 但是当你讲bar函数修改为静态成员函数时就是书中想要的结果(或许是书中的纰漏吧，作为补充我在这里给出了书中想要的效果)。\",\"这种情况是最简单的，因为被调用的函数与调用者都在同一个模块，所以它们之间的相对位置是固定的，所以这种情况会比较简单。对于现代系统来说，模块内部的跳转、函数调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。\",\"类型二 模块内部数据访问 任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，那么只需要相对于当前指令(PC值)加上固定的偏移量就可以访问模块内部数据了。例如函数bar中的一段反汇编代码:\",\"# %rip既是对应的PC值(当前执行的下一条指令) 113d: c7 05 d5 2e 00 00 01 movl $0x1,0x2ed5(%rip) # 401c <a> 1144: 00 00 00 # a内存地址进行了一次内存对齐，所以需要补0所以%rip实际值为0x1147 1147: 48 8b 05 72 2e 00 00 mov 0x2e72(%rip),%rax # 3fc0 <b>\",\"假设该模块经过加载后位于虚拟内存的0x10000000处，那变量a所在的虚拟内存地址为: 0x2ed5 + 0x1147 + 0x10000000 = 0x1000401c。 而通过查看符号表信息可以得到变量a所在elf文件中的位置:\",\"$> readelf -s libpic.so # 只显示了部分数据 ... ymbol table '.symtab' contains 29 entries: Num: Value Size Type Bind Vis Ndx Name ... 10: 000000000000401c 4 OBJECT LOCAL DEFAULT 22 a ... ...\",\"类型三 模块间数据访问 要使得代码地址无关，基本的思想是把和地址相关的部分放到数据段里面，很明显，这些其它模块的全局变量的地址是和模块装载地址相关的。elf的做法是在数据段里面创建一个指向这些变量的指针数组，也被称为全局偏移表(Global Offset Table, GOT)，当代码需要引用该变量时，可以通过GOT中相对应的项间接引用。如图:\",\"模块间数据访问\",\"当指令需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。\",\"重要\",\"GOT是如何实现指令的地址无关性的。模块在编译时可以确定模块内部变量相对于当前指令的偏移，那么我们也可以在编译时确定GOT相对于当前指令的偏移。确定GOT的位置和上面的访问变量a的方法基本一样，通过得到PC值然后加上偏移量，就可以得到GOT的位置。然后我们根据变量地址在GOT中的偏移量就可以得到变量的地址，当然GOT中每个地址对应于哪个变量是由编译器决定的，比如第一个地址对应变量b，第二个变量对应变量c等。\",\"假设共享库被加载到0x100000000的位置，观察函数bar()的反汇编代码。为访问变量b，程序首先计算出变量b的地址在GOT中的位置，即0x10000000 + 0x114e + 0x2e72 = 0x10003fc0\",\"查看GOT位置\",\"$> readelf -S libpic.so There are 27 section headers, starting at offset 0x3548: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align ... [19] .got PROGBITS 0000000000003fc0 00002fc0 0000000000000028 0000000000000008 WA 0 0 8 ...\",\"GOT在文件中的偏移为0x3fc0。查看动态链接时重定位项。\",\"$> readelf -r libpic.so Relocation section '.rela.dyn' at offset 0x458 contains 8 entries: Offset Info Type Sym. Value Sym. Name + Addend ... 000000003fc0 000200000006 R_X86_64_GLOB_DAT 0000000000000000 b + 0 ...\",\"观察到变量b的地址需要重定位，它位于0x3fc0，也就是GOT中偏移0，相当于是GOT中的第一项（每8字节一项）正好对应通过指令计算出的偏移量0x114e + 0x2e72 = 0x3fc0。\",\"类型四 模块间调用、跳转 对于模块间调用和跳转，同样可以采用类型三的方法来解决。但是不同的是，GOT中相应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过GOT中的项进行间接跳转基本原理如下图(这是原书可出的可能会和实际不同，但是不影响我们进行分析):\",\"模块间调用、跳转\",\"0000000000001060 <ext@plt>: 1060: f3 0f 1e fa endbr64 1064: ff 25 96 2f 00 00 jmp *0x2f96(%rip) # 4000 <ext> 106a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1) 0000000000001155 <foo>: 1155: f3 0f 1e fa endbr64 1159: 48 83 ec 08 sub $0x8,%rsp 115d: b8 00 00 00 00 mov $0x0,%eax 1162: e8 09 ff ff ff call 1070 <bar@plt> 1167: b8 00 00 00 00 mov $0x0,%eax 116c: e8 ef fe ff ff call 1060 <ext@plt> 1171: 48 83 c4 08 add $0x8,%rsp 1175: c3 ret\",\"观察到调用ext()函数时跳转到了\\\"ext@plt\\\"调用，而该函数内部实现依旧是跳转到GOT表中通过间接跳转实现对函数的调用(0x1064代码处调用)。\",\"注\",\"通过实际的分析发现函数的GOT表并不在.got段中而是在一个名为.got.plt段中(延迟绑定)这是对模块间调用、跳转的一种优化。\",\"-fpic和-fPIC 从功能上来说完全一样，都是生成地址无关代码，“-fPIC”生成的代码要大，而“f-pic”生成的代码要小，而且较快。但是由于地址无关代码都是和硬件平台相关的，不同的平台有着不同的实现，“-fpic”在某些平台上会有一些限制，比如全局符号的数量或者代码的长度等，而“-fPIC”则没有这样的限制。所以为了方便，绝大多数情况下都使用”-fPIC“。\",\"PIC和PIE 一个以地址无关方式编译的可执行文件被称为地址无关可执行文件(PIE, Position-Independent Executable)。对应GCC选项\\\"-fpie\\\"或\\\"-fPIE\\\"。\"]},\"78\":{\"h\":\"3.4 共享模块的全局变量问题\",\"t\":[\"当一个模块引用了一个定义在共享对象的全局变量的时比如一个共享对象定义了一个全局变量global，而模块module.c是这样引用的：\",\"extern int global; int foo() { global = 1; }\",\"当编译器编译moudule.c时，无法根据这个上下文判断global是定义在同一个模块的其它目标文件还是定义在另一个模块当中，既无法判断是否为跨模块间的调用。\",\"假设module.c是程序可执行文件的一部分，那么这种情况下，由于程序主模块的代码并不是地址无关代码，也就是说代码不会使用这种PIC机制，它引用这个全局变量的方式和普通数据访问方式一样，编译器会产生这样的代码：\",\"movq $0x1, XXXXXXXXXXXXXXXX # XXXXXXXXXXXXXXXX为global的地址。\",\"由于可执行文件在运行时并不进行代码重定位，所以变量的地址必须在链接过程中确定下来。为了能够使得链接过程正常进行，链接器会在创建可执行文件时，在它的\\\".bss\\\"段创建一个global变量的副本。那么现在global变量定义在原先的共享对象中，而在可执行文件的\\\".bss\\\"段还有一个副本。如果同一个变量同时存在于多个位置中，这在程序实际运行过程中肯定是不可行的。\",\"如何解决？那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本。ELF共享库在编译时，默认都把定义在模块内部的全局变量当作定义在其它模块的全局变量，也就是类型四 模块间变量访问，通过GOT来实现变量访问。当共享模块被装载时，如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中的相应地址指向该副本，这样该变量在运行时实际上最终只有一个实例。如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本；如果该全局变量在程序主模块中没有副本，那么GOT中相应地址就指向模块内部的该变量副本。\",\"如果module.c是共享对象的一部分，那么GCC编译器在-fPIC的情况下，就会把对global的调用按照跨模块模式产生代码。因为编译器无法确定对global的引用是跨模块的还是模块内部的。即使是模块内部的，还是会产生跨模块代码，因为global可能被可执行文件引用，从而使得共享模块中对global的引用要执行可执行文件中的globa副本。\"]},\"79\":{\"h\":\"3.5 数据段地址无关性\",\"t\":[\"static int a; static int *p = &a;\",\"如果某个共享对象里有这样一段代码，那么p的地址就是一个绝对地址，它指向变量a，而变量a的地址会随着共享对象的装载地址改变而改变。\",\"对于数据段来说，它在每个进程都有一份独立的副本，所以并不担心被进程改变。从这点来看，我们可以选择装载时重定位的方法来解决数据段中绝对地址引用问题。对于共享对象来说，如果数据段中有绝对地址引用，那么编译器和链接器就会产生一个重定位表，这个重定位表里面里面包含了“R_X86_64_GLOB_DAT\\\"类型的重定位入口，用于解决上述问题。当动态链接器装载共享对象时，如果发现该共享对象有这样的重定位入口，那么动态链接器就会对该共享对象进行重定位。\"]},\"80\":{\"h\":\"4. 延迟绑定(PLT)\",\"t\":[\"动态链接库比静态链接慢的主要原因：\",\"动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址，对于模块间的调用也要先定位GOT，然后再进行间接跳转。\",\"动态链接的链接工作在运行时完成，即程序开始执行时，动态链接器都要进行一次链接工作，动态链接器会寻找斌装载所需要的共享对象，然后进行符号查找地址重定位等工作。\",\"延迟绑定实现 在动态链接下，程序模块之间包含了大量的函数引用(全局变量往往比较少，因为大量的全局变量会导致模块间耦合度变大)，所以在程序开始执行前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找和重定位。不过可以想象，在一个程序运行过程中，可能很多函数在程序执行完时都不会被用到，比如一些错误处理函数或者是一些用户很少用到的功能模块等，如果一开始就把所有函数都链接好实际上是一种浪费。所以ELF采用了一种叫 延迟绑定(Lazy Binding) 的做法,其基本思想是当函数第一次被用到时才进行绑定(符号查找、重定位等)，如果没有用到则不进行绑定。所以程序开始执行时，模块间的函数调用都没有进行绑定，而是需要用到时才由动态链接器来负责绑定。\",\"ELF使用 PLT(Procedure Linkage Table) 的方法来实现，这种方法使用了一些精巧的指令序列来完成。\",\"注\",\"假设liba.so需要调用libc.so中的bar()函数，那么当liba.so中第一次调用bar()时，这时候就需要调用动态链接器中的某个函数来完成地址绑定工作，我们假设这个函数叫做lookup()，那么lookup()需要知道一些必要信息才能完成这个函数地址绑定的工作:\",\"地址绑定发生在哪个模块，哪个函数。 假设lookup的原型为lookup(module, function)，这两个参数的值在我们的列子中分别为liba.so和bar()。在Glibc中，我们这里的lookup()函数正在的名字叫做_dl_runtime_resolve()。\",\"当我们调用某个外部模块的函数时，如果按照通常的做法应该时通过GOT中相应的项进行间接跳转。PLT为了实现延迟绑定，在这个过程中间又增加了一层间接跳转。调用函数并不直接通过GOT跳转，而是通过一个叫做PLT项的结构来进行跳转。每个外部函数在PLT中都有一个相应的项，比如bar()函数在PLT中的项我们称之为bar@plt。\",\"0000000000001070 <bar@plt>: 1070: f3 0f 1e fa endbr64 1074: ff 25 8e 2f 00 00 jmp *0x2f8e(%rip) # 4008 <bar+0x2ecf> 107a: 66 0f 1f 44 00 00 nopw 0x0(%rax,%rax,1)\",\"注\",\"过程链接表(PLT)是一个数组，其中每个条目时16字节代码。PLT[0]时一个特殊条目，它跳转到动态链接库中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PLT[1]调用系统启动函数(__libc_start_main)，它初始化执行环境。从PLT[2]开始的条目调用用户代码调用的函数。\",\"全局偏移表(GOT)是一个数组，其中每个条目时8字节地址。和PLT联合使用时，GOT[0]和GOT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行是被解析。每个条目都有一个相匹配的PLT条目。初始时每个GOT条目都指向对应PLT条目的第二条指令。 (参考csapp 7.12小节)\",\"#include <stdio.h> #include <stdlib.h> #include <dlfcn.h> int x[2] = {1, 2}; int y[2] = {3, 4}; int z[2]; int main() { void *handle; void (*addvec) (int *, int *, int *, int); char *error; handle = dlopen(\\\"./libvector.so\\\", RTLD_LAZY); if (!handle) { fprintf(stderr, \\\"%s \\\\n\\\", dlerror()); exit(1); } addvec = dlsym(handle, \\\"addvec\\\"); if ((error = dlerror()) != NULL) { fprintf(stderr, \\\"%s\\\\n\\\", error); exit(1); } addvec(x, y, z, 2); printf(\\\"z = [%d %d]\\\\n\\\", z[0], z[1]); if (dlclose(handle) < 0) { fprintf(stderr, \\\"%s\\\\n\\\", dlerror()); exit(1); } return 0; }\",\"用PLT和GOT调用外部函数。在第一次调用addvec时，动态链接器解析它的地址\",\"如何使用GOT和PLT协同工作:\",\"addvec第一次被调用时，延迟解析它的运行时地址： \",\"不直接调用addvec，程序调用进入PLT[2]，这是addvec的PLT条目\",\"第一条PLT指令通过GOT[4]进行间接跳转。因为每个GOT条目初始化时都指向它对应的PLT条目的第二条指令，这个间接跳转只是简单的把控制传送回PLT[2]中的下一条指令。\",\"在把addvec的ID（0x1）压入栈中之后，PLT[2]跳转到PLT[0]。\",\"PLT[0]通过GOT[1]间接的把动态链接器的一个参数压入栈中，然后通过GOT[2]间接跳转到动态链接器中。动态链接器使用两个栈条目来确定addvec的运行时位置，用这个地址重新GOT[4]，再把控制权传递给addvec。\",\"后续再调用addvec时的控制流： \",\"控制传递到PLT[2]。\",\"通过GOT[4]的间接跳转会将控制直接转移到addvec。\",\"PLT在ELF文件中以独立的段存放，段名叫\\\".plt\\\"。因为本身是一些地址无关代码，所以可以和代码段等一起合并成同一个可读可指向的“segment”被装载入内存。\"]},\"81\":{\"h\":\"5. 动态链接相关结构\",\"t\":[\"动态链接情况下，可执行文件的装载与静态链接情况基本一样。首先操作系统会读取可执行文件的头部，检查文件的合法性，然后从头部中的 \\\"Program Header\\\" 中读取每个 \\\"Segment\\\" 的虚拟地址、文件地址和属性，并将它们映射到进程虚拟空间的相应位置，这些步骤和静态链接情况下的装载基本无异。在静态链接情况下，操作系统接着就可以把控制权交给可执行文件的入口地址，然后程序开始执行。\",\"可是在动态链接情况下，操作系统还不能在装载完可执行文件之后就把控制权交给可执行文件，因为可执行文件依赖于很多共享对象。这时，可执行文件对于很多 外部符号的引用还处于无效地址的状态，既还没有和相应的共享对象中的实际位置链接起来。所以在映射完可执行文件后，操作系统会先启动一个动态链接器（Dynamic Linker）。\",\"在Linux下，动态链接器ld.so实际上是一个共享对象，操作系统统一通过映射的方式将它加载到进程的地址空间中。操作系统在加载完动态链接器后，将控制权交给动态链接器的入口地址（与可执行文件一样，共享对象也有入口地址）。当动态链接器获得控制权后，便开始一系列自身的初始化操作，然后根据当前的环境参数，开始对可执行文件进行动态链接工作。当所有动态链接工作完成后，动态链接器会将控制权交给可执行文件的入口地址，程序开始正式执行。\"]},\"82\":{\"h\":\"5.1 \\\".interp\\\"段\",\"t\":[\"注\",\"动态链接去的位置既不是由系统配置指定，也不是由环境参数决定，而是由ELF可执行文件决定。在动态链接的ELF可执行文件中，有一个专门的段叫做==\\\".interp\\\"段(\\\"interp\\\"是\\\"interpreter\\\"(解释器)的缩写)。 \\\".interp\\\"里面保持的就是一个字符串，这个字符串就是可执行文件所需要的动态链接器的路径。在Linux中，操作系统在对可执行文件进行加载时==，会去寻址装载该可执行文件所需要相应的动态链接器，既\\\".interp\\\"段所指定的路径的共享对象。\",\"使用objdump工具查看\\\"interp\\\"内容：\",\"// test.c #include <stdio.h> int main() { printf(\\\"hello world!\\\\n\\\"); return 0; } // gcc test.c -o test\",\"$> objdump -s test test: file format elf64-x86-64 Contents of section .interp: 0318 2f6c6962 36342f6c 642d6c69 6e75782d /lib64/ld-linux- 0328 7838362d 36342e73 6f2e3200 x86-64.so.2.\",\"也可以使用readelf查看：\",\"$> readelf -l test|grep .interpreter [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]\"]},\"83\":{\"h\":\"5.2 \\\".dynamic\\\"段\",\"t\":[\"重要\",\"动态链接ELF中最重要的结构\\\".dynamic\\\"段，这个段保存了动态链接所需要的基本信息，比如依赖于那些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。\",\"\\\".dynamic\\\"段的结构：\",\"/* Dynamic section entry. */ // 32位 typedef struct { Elf32_Sword d_tag; /* Dynamic entry type */ union { Elf32_Word d_val; /* Integer value */ Elf32_Addr d_ptr; /* Address value */ } d_un; } Elf32_Dyn; // 64位 typedef struct { Elf64_Sxword d_tag; /* Dynamic entry type */ union { Elf64_Xword d_val; /* Integer value */ Elf64_Addr d_ptr; /* Address value */ } d_un; } Elf64_Dyn;\",\"d_tag类型\",\"d_un的含义\",\"DT_SYMTAB\",\"动态链接符号表的地址，d_ptr表示\\\".dynsym\\\"的地址\",\"DT_STRTAB\",\"动态链接字符串表地址，d_ptr表示\\\".dynstr\\\"的地址\",\"DT_STRSZ\",\"动态链接字符串表大小，d_val表示大小\",\"DT_HASH\",\"动态链接哈希表地址，d_ptr表示\\\".hash\\\"的地址\",\"DT_SONAME\",\"本共享对象的\\\"SO-NAME\\\"\",\"DT_RPATH\",\"动态链接共享对象搜索路径\",\"DT_INIT\",\"初始化代码地址\",\"DT_FINIT\",\"结束代码地址\",\"DT_NEED\",\"依赖的共享对象文件，d_ptr表示所依赖的共享对象文件名\",\"DT_REL/DT_RELA\",\"动态链接重定位表地址\",\"DT_RELENT/DT_RELAENT\",\"动态重定位表入口函数\",\"使用readelf工具查看\\\".dynaminc\\\"段的内容：\",\"$> readelf -d test Dynamic section at offset 0x2dc8 contains 27 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000c (INIT) 0x1000 0x000000000000000d (FINI) 0x1168 0x0000000000000019 (INIT_ARRAY) 0x3db8 0x000000000000001b (INIT_ARRAYSZ) 8 (bytes) 0x000000000000001a (FINI_ARRAY) 0x3dc0 0x000000000000001c (FINI_ARRAYSZ) 8 (bytes) 0x000000006ffffef5 (GNU_HASH) 0x3b0 0x0000000000000005 (STRTAB) 0x480 0x0000000000000006 (SYMTAB) 0x3d8 0x000000000000000a (STRSZ) 141 (bytes) 0x000000000000000b (SYMENT) 24 (bytes) 0x0000000000000015 (DEBUG) 0x0 0x0000000000000003 (PLTGOT) 0x3fb8 0x0000000000000002 (PLTRELSZ) 24 (bytes) 0x0000000000000014 (PLTREL) RELA 0x0000000000000017 (JMPREL) 0x610 0x0000000000000007 (RELA) 0x550 0x0000000000000008 (RELASZ) 192 (bytes) 0x0000000000000009 (RELAENT) 24 (bytes) 0x000000000000001e (FLAGS) BIND_NOW 0x000000006ffffffb (FLAGS_1) Flags: NOW PIE 0x000000006ffffffe (VERNEED) 0x520 0x000000006fffffff (VERNEEDNUM) 1 0x000000006ffffff0 (VERSYM) 0x50e 0x000000006ffffff9 (RELACOUNT) 3 0x0000000000000000 (NULL) 0x0\",\"使用ldd查看一个程序主模块或一个共享库依赖于哪些共享库：\",\"$> ldd test linux-vdso.so.1 (0x00007ffe6d77b000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7967314000) /lib64/ld-linux-x86-64.so.2 (0x00007f796754d000)\"]},\"84\":{\"h\":\"5.3 动态符号表\",\"t\":[\"// lib.c #include <stdio.h> void foobar(int i) { printf(\\\"Printing form lib.so %d\\\\n\\\", i); } // gcc -shared -fPIC lib.c -o Lib.so // Program1.c #include \\\"Lib.h\\\" int main() { foobar(1); return 0; }\",\"注\",\"为了完成动态链接，最关键的还是所依赖的符号和相关文件的信息。我们知道在静态链接中，有一个专门的段叫符号表\\\".symtab\\\"(symbol table)，里面保存了所有关于该目标文件的符号的定义和引用。动态链接的符号表示和静态链接十分相似。比如Program1程序依赖于Lib.so，引用了里面的printf()函数。那么对于Program1来说，我们称Program1 导入(import) 了foobar()函数，foobar()是Program1的 导入函数(import function) ；而Lib.so它实际上是定义了foobar()函数，并且提供给其它模块使用，我们称Lib.so导出(export) 了foobar()函数，foobar()是Lib.so的 导出函数(export function) 。对比于这种导入导出函数，在静态链接中就相当于普通函数的定义和引用。 ELF中表示这种模块间符号导入导出的关系就叫做 动态符号表(Dynamic Symbol Table)，对应的段名就是 \\\".dynsym\\\"(Dynamic Symbol)。与\\\".symbol\\\"不同的是，\\\".dynsym\\\"只保存了与动态链接相关的符号，对于模块内部的符号，比如是私有变量则不保存。很多时候动态链接的模块同时拥有\\\".dynsym\\\"和\\\".symtab\\\"两个表，\\\".symtab\\\"中往往保存了所有符号，包括\\\".dynsym\\\"中的符号。 和\\\".symtab\\\"类似，动态符号表也需要一些辅助表，比如用于保存符号名的字符串表。今天链接时叫做字符串表==\\\".strtab\\\"(string table)，在这里就是动态符号字符串表\\\".dynstr\\\"(Dynamic String Table)；由于动态链接下，我们需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号哈希表(\\\".hash\\\")==。\",\"使用readelf查看ELF文件的动态符号表以及哈希表：\",\"$> readelf -sD Lib.so Symbol table for image contains 7 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterT[...] 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND [...]@GLIBC_2.2.5 (2) 3: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 4: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMC[...] 5: 0000000000000000 0 FUNC WEAK DEFAULT UND [...]@GLIBC_2.2.5 (2) 6: 0000000000001119 43 FUNC GLOBAL DEFAULT 14 foobar # .hash似乎已经不用了\"]},\"85\":{\"h\":\"5.4 动态链接重定位表\",\"t\":[\"动态链接重定位相关结构 共享对象的重定位与静态链接的目标文件的重定位十分类似。唯一有区别的是目标文件的重定位是目标文件的重定位是在今天链接时完成，而共享对象的重定位则是在装载时完成的。在静态链接中，目标文件里面包含有专门由于表示重定位信息的重定位表，比如 \\\".rel.text\\\" 表示代码段的重定位表，\\\".rel.data\\\" 是数据段的重定位表。 动态链接的文件中，重定位表分别叫做\\\".rel.dyn\\\"和\\\".rel.plt\\\"，他们分别相当于\\\".rel.text\\\"和\\\".rel.data\\\"。 \\\".rel.dyn\\\" 实际上是对数据引用的修正，它所修正的位置位于 \\\".got\\\"以及数据段 ；而 \\\".rel.plt\\\" 是对函数引用的修正，它所修正的位置位于 \\\".got.plt\\\" 。\",\"使用readelf查看文件的重定位表：\",\"$> readelf -r Lib.so Relocation section '.rela.dyn' at offset 0x468 contains 7 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000003e10 000000000008 R_X86_64_RELATIVE 1110 000000003e18 000000000008 R_X86_64_RELATIVE 10d0 000000004020 000000000008 R_X86_64_RELATIVE 4020 000000003fe0 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTM[...] + 0 000000003fe8 000300000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000003ff0 000400000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCl[...] + 0 000000003ff8 000500000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 Relocation section '.rela.plt' at offset 0x510 contains 1 entry: Offset Info Type Sym. Value Sym. Name + Addend 000000004018 000200000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 $> readelf -S Lib.so ... [22] .got PROGBITS 0000000000003fe0 00002fe0 0000000000000020 0000000000000008 WA 0 0 8 [23] .got.plt PROGBITS 0000000000004000 00003000 0000000000000020 0000000000000008 WA 0 0 8 [24] .data PROGBITS 0000000000004020 00003020 0000000000000008 0000000000000000 WA 0 0 8 ...\",\"R_X86_64_JUMP_SLO(对.got.plt的重定位) 被修正的位置只需要填入符号的地址即可。例如printf这个重定位入口，它的类型为R_X86_64_JUMP_SLO，它的偏移为0x000000004018，它实际上位于\\\".got.plt\\\"中，前三项被系统占据，从第四项开始存放导入函数的地方。0x0000000000004000 + 8 * 3 = 000000004018。 \",\"第一项保存的是\\\".dynamic\\\"段的地址。\",\"第二项保存的是本模块的ID。\",\"第三项保存的是_dl_runtime_resolve()的地址。 当动态链接器需要进行重定位时，先查找\\\"printf\\\"的地址，\\\"printf\\\"位于libc.so.6中。假设链接器在全局符号表里面找到\\\"printf\\\"的地址为0x000008801234，那么链接器就会将这个地址填入到\\\".got.plt\\\"中的偏移为0x000000004018位置中去，从而实现了地址的重定位，既实现了动态链接最关键的一步。\",\"R_X86_64_GLOB_DAT(对.got的重定位) 和R_X86_64_JUMP_SLO一模一样。\",\"R_X86_64_RELATIVE，这种类型的重定位实际上就是基址重置(Rebasing)。共享对象的数据段没有办法做到地址无关的，它可能会包含绝对地址引用，对于这种绝对地址的引用，我们必须在装载时将其重定位。例如：\",\"static int a; static int *p = &a;\",\"在编译时，共享对象的地址是从0开始的，我们假设该静态变量a相对于起始地址0的偏移为B，即p值为B。一旦共享对象被装载到地址A，那么实际上该变量a的地址为A+B，即p的值需要加上一个装载地址A。R_X86_64_RELATIVE类型的重定位入口就是专门用来重定位指针变量p这种类型的，变量p在装载时需要加上一个装载地址A，才是正确的结果。\"]},\"86\":{\"h\":\"5.5 动态链接时进程堆栈初始化信息\",\"t\":[\"注\",\"站在动态链接器的角度看，当操作系统将控制权交给它时，它将开始做链接工作，那么至少它需要知道关于可执行文件和本进程的些信息，比如可执行文件有几个段(\\\"Segment\\\")、每个段的属性、程序的入口地址等。这些信息往往由操作系统传递给动态链接器，保存在进程的堆栈里面。进程初始化时，堆栈里面保存了关于进程执行环境和命令行参数等信息。事实上，堆栈里面还保存了动态链接器所需要的一些辅助信息数组(Auxiliary Vector)。\",\"辅助信息结构：\",\"// /usr/include/elf.h /* Auxiliary vector. */ /* This vector is normally only used by the program interpreter. The usual definition in an ABI supplement uses the name auxv_t. The vector is not usually defined in a standard <elf.h> file, but it can't hurt. We rename it to avoid conflicts. The sizes of these types are an arrangement between the exec server and the program interpreter, so we don't fully specify them here. */ typedef struct { uint32_t a_type; /* Entry type */ union { uint32_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ } a_un; } Elf32_auxv_t; typedef struct { uint64_t a_type; /* Entry type */ union { uint64_t a_val; /* Integer value */ /* We use to have pointer elements added here. We cannot do that, though, since it does not work when using 32-bit definitions on 64-bit platforms and vice versa. */ } a_un; } Elf64_auxv_t;\"]},\"87\":{\"h\":\"6. 动态链接的步骤和实现\"},\"88\":{\"h\":\"7. HOOK\"},\"89\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"辅助信息结构\",{\"1\":{\"86\":1}}],[\"事实上\",{\"1\":{\"86\":1}}],[\"保存在进程的堆栈里面\",{\"1\":{\"86\":1}}],[\"保留所有的\",{\"1\":{\"7\":1}}],[\"站在动态链接器的角度看\",{\"1\":{\"86\":1}}],[\"才是正确的结果\",{\"1\":{\"85\":1}}],[\"位于libc\",{\"1\":{\"85\":1}}],[\"位于elf文件头后所以elf文件头的大小正好为代码段的偏移0x40\",{\"1\":{\"29\":1}}],[\"先查找\",{\"1\":{\"85\":1}}],[\"前三项被系统占据\",{\"1\":{\"85\":1}}],[\"实际上是对数据引用的修正\",{\"1\":{\"85\":1}}],[\"实际汇编得到的结果是使用了共享对象全局符号介入\",{\"1\":{\"77\":1}}],[\"他们分别相当于\",{\"1\":{\"85\":1}}],[\"他们需要被正确决议\",{\"1\":{\"44\":1}}],[\"唯一有区别的是目标文件的重定位是目标文件的重定位是在今天链接时完成\",{\"1\":{\"85\":1}}],[\"往往还有辅助的符号哈希表\",{\"1\":{\"84\":1}}],[\"今天链接时叫做字符串表==\",{\"1\":{\"84\":1}}],[\"类似\",{\"1\":{\"84\":1}}],[\"类型四\",{\"1\":{\"77\":1}}],[\"类型三\",{\"1\":{\"77\":1}}],[\"类型二\",{\"1\":{\"77\":1}}],[\"类型一\",{\"1\":{\"77\":1}}],[\"类型的重定位入口\",{\"1\":{\"79\":1}}],[\"类型的segment\",{\"1\":{\"67\":1}}],[\"类型的\",{\"1\":{\"39\":1,\"67\":1}}],[\"两个表\",{\"1\":{\"84\":1}}],[\"两步链接\",{\"1\":{\"49\":1}}],[\"很多时候动态链接的模块同时拥有\",{\"1\":{\"84\":1}}],[\"很明显\",{\"1\":{\"77\":1}}],[\"与\",{\"1\":{\"84\":1}}],[\"与可执行文件一样\",{\"1\":{\"81\":1}}],[\"导出函数\",{\"1\":{\"84\":1}}],[\"导入函数\",{\"1\":{\"84\":1}}],[\"导入\",{\"1\":{\"84\":1}}],[\"引用了里面的printf\",{\"1\":{\"84\":1}}],[\"里面保存了所有关于该目标文件的符号的定义和引用\",{\"1\":{\"84\":1}}],[\"里面保持的就是一个字符串\",{\"1\":{\"82\":1}}],[\"结束代码地址\",{\"1\":{\"83\":1}}],[\"结尾\",{\"1\":{\"41\":1}}],[\"本共享对象的\",{\"1\":{\"83\":1}}],[\"本来需要5个物理页的现在只需要3个物理页\",{\"1\":{\"69\":1}}],[\"内容\",{\"1\":{\"82\":1}}],[\"内存空间得到了充分利用\",{\"1\":{\"69\":1}}],[\"内存共享比如libc的动态链接库\",{\"1\":{\"18\":1}}],[\"解释器\",{\"1\":{\"82\":1}}],[\"便开始一系列自身的初始化操作\",{\"1\":{\"81\":1}}],[\"外部符号的引用还处于无效地址的状态\",{\"1\":{\"81\":1}}],[\"检查文件的合法性\",{\"1\":{\"81\":1}}],[\"首先操作系统会读取可执行文件的头部\",{\"1\":{\"81\":1}}],[\"首先将控制权交给动态链接器\",{\"1\":{\"73\":1}}],[\"控制传递到plt\",{\"1\":{\"80\":1}}],[\"后续再调用addvec时的控制流\",{\"1\":{\"80\":1}}],[\"后面跟一个0\",{\"1\":{\"70\":1}}],[\"后面四个字节就是被调用函数的相对于调用指令的下一条指令的偏移量\",{\"1\":{\"52\":1}}],[\"后面四字节就是该指令的下一条指令的偏移量\",{\"1\":{\"52\":1}}],[\"后面\",{\"1\":{\"41\":1}}],[\"后面紧跟一个0表示结束\",{\"1\":{\"70\":1}}],[\"后面紧跟\",{\"1\":{\"41\":1}}],[\"间接跳转到动态链接器中\",{\"1\":{\"80\":1}}],[\"间接的把动态链接器的一个参数压入栈中\",{\"1\":{\"80\":1}}],[\"压入栈中之后\",{\"1\":{\"80\":1}}],[\"进行间接跳转\",{\"1\":{\"80\":1}}],[\"进程初始化时\",{\"1\":{\"86\":1}}],[\"进程栈初始化\",{\"0\":{\"70\":1}}],[\"进程虚拟空间分布\",{\"0\":{\"66\":1}}],[\"进程从刚才页错误的位置重新开始执行\",{\"1\":{\"65\":1}}],[\"进程建立完成后\",{\"1\":{\"65\":1}}],[\"进程的建立\",{\"0\":{\"64\":1}}],[\"延迟解析它的运行时地址\",{\"1\":{\"80\":1}}],[\"延迟绑定实现\",{\"1\":{\"80\":1}}],[\"延迟绑定\",{\"0\":{\"80\":1},\"1\":{\"77\":1,\"80\":1}}],[\"用这个地址重新got\",{\"1\":{\"80\":1}}],[\"用plt和got调用外部函数\",{\"1\":{\"80\":1}}],[\"用于解决上述问题\",{\"1\":{\"79\":1}}],[\"y\",{\"1\":{\"80\":2}}],[\"ymbol\",{\"1\":{\"77\":1}}],[\"初始化代码地址\",{\"1\":{\"83\":1}}],[\"初始化为0的全局变量和局部静态变量\",{\"1\":{\"18\":1,\"22\":1}}],[\"初始时每个got条目都指向对应plt条目的第二条指令\",{\"1\":{\"80\":1}}],[\"全局偏移表\",{\"1\":{\"80\":1}}],[\"全局变量往往比较少\",{\"1\":{\"80\":1}}],[\"全局变量和局部静态变量经常存放于数据段\",{\"1\":{\"18\":1}}],[\"开始对可执行文件进行动态链接工作\",{\"1\":{\"81\":1}}],[\"开始的条目调用用户代码调用的函数\",{\"1\":{\"80\":1}}],[\"开头\",{\"1\":{\"41\":1}}],[\"哪个函数\",{\"1\":{\"80\":1}}],[\"时一个特殊条目\",{\"1\":{\"80\":1}}],[\"时\",{\"1\":{\"80\":1}}],[\"无法根据这个上下文判断global是定义在同一个模块的其它目标文件还是定义在另一个模块当中\",{\"1\":{\"78\":1}}],[\"无映像文件\",{\"1\":{\"68\":2}}],[\"绝大多数情况下都使用\",{\"1\":{\"77\":1}}],[\"跳转到plt\",{\"1\":{\"80\":1}}],[\"跳转的一种优化\",{\"1\":{\"77\":1}}],[\"跳转\",{\"1\":{\"77\":2}}],[\"跳转等\",{\"1\":{\"77\":2}}],[\"查看动态链接时重定位项\",{\"1\":{\"77\":1}}],[\"查看got位置\",{\"1\":{\"77\":1}}],[\"查看可执行文件的堆栈\",{\"1\":{\"68\":1}}],[\"观察函数bar\",{\"1\":{\"77\":1}}],[\"观察到调用ext\",{\"1\":{\"77\":1}}],[\"观察到变量b的地址需要重定位\",{\"1\":{\"77\":1}}],[\"观察到整个虚拟地址空间中\",{\"1\":{\"73\":1}}],[\"观察到进程中10个vma中只有前五个是映射到可执行文件中的两个segment\",{\"1\":{\"68\":1}}],[\"确定got的位置和上面的访问变量a的方法基本一样\",{\"1\":{\"77\":1}}],[\"基本的思想是把和地址相关的部分放到数据段里面\",{\"1\":{\"77\":1}}],[\"基本原则是将相同权限属性的\",{\"1\":{\"68\":1}}],[\"要使得代码地址无关\",{\"1\":{\"77\":1}}],[\"加上固定的偏移量就可以访问模块内部数据了\",{\"1\":{\"77\":1}}],[\"加载地址\",{\"1\":{\"49\":1}}],[\"作为补充我在这里给出了书中想要的效果\",{\"1\":{\"77\":1}}],[\"或\",{\"1\":{\"77\":1}}],[\"或许是书中的纰漏吧\",{\"1\":{\"77\":1}}],[\"或者是基于寄存器的相对调用\",{\"1\":{\"77\":1}}],[\"或者是一个特殊的值\",{\"1\":{\"44\":1}}],[\"或者多个模块被多个程序使用呢\",{\"1\":{\"75\":1}}],[\"或者写成\",{\"1\":{\"42\":1}}],[\"或者对于有些特殊符号\",{\"1\":{\"38\":1}}],[\"或者段\",{\"1\":{\"18\":1}}],[\"或者中间目标文件\",{\"1\":{\"9\":1}}],[\"或者\",{\"1\":{\"7\":1,\"8\":1,\"9\":1,\"40\":1}}],[\"根据objdump反汇编后得到的结果和书中列出的不太一样\",{\"1\":{\"77\":1}}],[\"jump\",{\"1\":{\"85\":4}}],[\"jmprel\",{\"1\":{\"83\":1}}],[\"jmp\",{\"1\":{\"77\":3,\"80\":1}}],[\"jne\",{\"1\":{\"52\":1,\"53\":1}}],[\"模块间的函数调用都没有进行绑定\",{\"1\":{\"80\":1}}],[\"模块间变量访问\",{\"1\":{\"78\":1}}],[\"模块间调用\",{\"1\":{\"77\":2}}],[\"模块间数据访问\",{\"1\":{\"77\":2}}],[\"模块在编译时可以确定模块内部变量相对于当前指令的偏移\",{\"1\":{\"77\":1}}],[\"模块外部函数调用\",{\"1\":{\"77\":2}}],[\"模块外部数据访问\",{\"1\":{\"77\":2}}],[\"模块外部的数据访问\",{\"1\":{\"77\":1}}],[\"模块外部的函数调用\",{\"1\":{\"77\":1}}],[\"模块内部调用或跳转\",{\"1\":{\"77\":1}}],[\"模块内部函数调用\",{\"1\":{\"77\":2}}],[\"模块内部数据访问\",{\"1\":{\"77\":3}}],[\"模块内部的跳转\",{\"1\":{\"77\":1}}],[\"模块内部的数据访问\",{\"1\":{\"77\":1}}],[\"模块内部的函数调用\",{\"1\":{\"77\":1}}],[\"模块内部引用和模块外部引用\",{\"1\":{\"77\":1}}],[\"按照不同的引用方式又分为\",{\"1\":{\"77\":1}}],[\"按序叠加内存分配\",{\"1\":{\"48\":1}}],[\"按序叠加\",{\"0\":{\"48\":1}}],[\"任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的\",{\"1\":{\"77\":1}}],[\"任何人以后将不能在同一个程序里面使用模块a和c\",{\"1\":{\"75\":1}}],[\"任何不包含在e中的成员目标文件都简单地被丢弃\",{\"1\":{\"55\":1}}],[\"余数分配给了另一个模块c\",{\"1\":{\"75\":1}}],[\"例如\",{\"1\":{\"85\":1}}],[\"例如printf这个重定位入口\",{\"1\":{\"85\":1}}],[\"例如函数bar中的一段反汇编代码\",{\"1\":{\"77\":1}}],[\"例如程序program1使用了模块b\",{\"1\":{\"75\":1}}],[\"例如a和b链接后\",{\"1\":{\"14\":1}}],[\"固定装载地址的困扰\",{\"0\":{\"75\":1}}],[\"动态符号表也需要一些辅助表\",{\"1\":{\"84\":1}}],[\"动态符号表\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"动态重定位表入口函数\",{\"1\":{\"83\":1}}],[\"动态的分配一块足够大小的地址空间给相应的共享对象\",{\"1\":{\"73\":1}}],[\"动态链接时进程堆栈初始化信息\",{\"0\":{\"86\":1}}],[\"动态链接重定位相关结构\",{\"1\":{\"85\":1}}],[\"动态链接重定位表\",{\"0\":{\"85\":1}}],[\"动态链接重定位表地址\",{\"1\":{\"83\":1}}],[\"动态链接重定位表的位置\",{\"1\":{\"83\":1}}],[\"动态链接的步骤和实现\",{\"0\":{\"87\":1}}],[\"动态链接的文件中\",{\"1\":{\"85\":1}}],[\"动态链接的符号表示和静态链接十分相似\",{\"1\":{\"84\":1}}],[\"动态链接的链接工作在运行时完成\",{\"1\":{\"80\":1}}],[\"动态链接共享对象搜索路径\",{\"1\":{\"83\":1}}],[\"动态链接哈希表地址\",{\"1\":{\"83\":1}}],[\"动态链接字符串表大小\",{\"1\":{\"83\":1}}],[\"动态链接字符串表地址\",{\"1\":{\"83\":1}}],[\"动态链接符号表的地址\",{\"1\":{\"83\":1}}],[\"动态链接符号表的位置\",{\"1\":{\"83\":1}}],[\"动态链接elf中最重要的结构\",{\"1\":{\"83\":1}}],[\"动态链接去的位置既不是由系统配置指定\",{\"1\":{\"82\":1}}],[\"动态链接情况下\",{\"1\":{\"81\":1}}],[\"动态链接相关结构\",{\"0\":{\"81\":1}}],[\"动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找和重定位\",{\"1\":{\"80\":1}}],[\"动态链接器会将控制权交给可执行文件的入口地址\",{\"1\":{\"81\":1}}],[\"动态链接器会寻找斌装载所需要的共享对象\",{\"1\":{\"80\":1}}],[\"动态链接器ld\",{\"1\":{\"81\":1}}],[\"动态链接器使用两个栈条目来确定addvec的运行时位置\",{\"1\":{\"80\":1}}],[\"动态链接器解析它的地址\",{\"1\":{\"80\":1}}],[\"动态链接器都要进行一次链接工作\",{\"1\":{\"80\":1}}],[\"动态链接器和普通共享对象一样被映射到进程的地址空间\",{\"1\":{\"73\":1}}],[\"动态链接下对于全局和静态的数据访问都要进行复杂的got定位\",{\"1\":{\"80\":1}}],[\"动态链接库比静态链接慢的主要原因\",{\"1\":{\"80\":1}}],[\"动态链接模块被装载至虚拟空间后\",{\"1\":{\"76\":1}}],[\"动态链接模块的装载地址是从地址0x0000000000000000开始的\",{\"1\":{\"73\":1}}],[\"动态链接程序运行时地址空间分布\",{\"1\":{\"73\":1}}],[\"动态链接过程\",{\"1\":{\"73\":1}}],[\"动态链接\",{\"0\":{\"71\":1},\"1\":{\"32\":1}}],[\"共享对象的地址是从0开始的\",{\"1\":{\"85\":1}}],[\"共享对象的数据段没有办法做到地址无关的\",{\"1\":{\"85\":1}}],[\"共享对象的重定位与静态链接的目标文件的重定位十分类似\",{\"1\":{\"85\":1}}],[\"共享对象的最终装载地址在编译时是不确定的\",{\"1\":{\"73\":1}}],[\"共享对象初始化代码的地址等\",{\"1\":{\"83\":1}}],[\"共享对象也有入口地址\",{\"1\":{\"81\":1}}],[\"共享模块的全局变量问题\",{\"0\":{\"78\":1}}],[\"共享目标文件\",{\"1\":{\"17\":1}}],[\"我们假设该静态变量a相对于起始地址0的偏移为b\",{\"1\":{\"85\":1}}],[\"我们假设这个函数叫做lookup\",{\"1\":{\"80\":1}}],[\"我们必须在装载时将其重定位\",{\"1\":{\"85\":1}}],[\"我们需要在程序运行时查找符号\",{\"1\":{\"84\":1}}],[\"我们称lib\",{\"1\":{\"84\":1}}],[\"我们称program1\",{\"1\":{\"84\":1}}],[\"我们知道在静态链接中\",{\"1\":{\"84\":1}}],[\"我们知道这个地址是无效地址\",{\"1\":{\"73\":1}}],[\"我们这里的lookup\",{\"1\":{\"80\":1}}],[\"我们可以选择装载时重定位的方法来解决数据段中绝对地址引用问题\",{\"1\":{\"79\":1}}],[\"我们可以手工指定各个模块的地址\",{\"1\":{\"75\":1}}],[\"我们设想是否可以让共享对象在任意地址加载\",{\"1\":{\"75\":1}}],[\"我们首先会遇到的问题是共享对象地址冲突问题\",{\"1\":{\"75\":1}}],[\"我们只关心\",{\"1\":{\"67\":1}}],[\"我们只关心其中两种最基本的重定位类型\",{\"1\":{\"56\":1}}],[\"多出了几个文件的映射\",{\"1\":{\"73\":1}}],[\"多余\",{\"1\":{\"67\":1}}],[\"kill\",{\"1\":{\"73\":1}}],[\"key\",{\"1\":{\"28\":1,\"67\":1}}],[\"还是会产生跨模块代码\",{\"1\":{\"78\":1}}],[\"还是用到了动态链接形式的c语言运行时库\",{\"1\":{\"73\":1}}],[\"还有一点不同的是\",{\"1\":{\"73\":1}}],[\"还有linux下的动态链接器\",{\"1\":{\"73\":1}}],[\"还有它所依赖的共享目标文件\",{\"1\":{\"73\":1}}],[\"还存在其它几种不常用的符号\",{\"1\":{\"35\":1}}],[\"整个进程只有可执行文件需要被映射\",{\"1\":{\"73\":1}}],[\"整个链接的过程基于符号才能正确完成\",{\"1\":{\"35\":1}}],[\"简单的动态链接例子\",{\"0\":{\"73\":1}}],[\"把地址0x2000到0x3000分配给模块b\",{\"1\":{\"75\":1}}],[\"把lib\",{\"1\":{\"73\":1}}],[\"把这个过程保留到装载时进行\",{\"1\":{\"73\":1}}],[\"把链接的过程推迟到运行时进行\",{\"1\":{\"72\":1}}],[\"把它们合并到一起当作一个段进行映射\",{\"1\":{\"67\":1}}],[\"紧接的就是指向这两个参数字符串的指针\",{\"1\":{\"70\":1}}],[\"指令引用和数据访问\",{\"1\":{\"77\":1}}],[\"指令部分是在多个进程之间共享的\",{\"1\":{\"76\":1}}],[\"指令修正方式\",{\"0\":{\"56\":1}}],[\"指向的位置是初始化以后堆栈的顶部\",{\"1\":{\"70\":1}}],[\"栈指针寄存器esp\",{\"1\":{\"70\":1}}],[\"栈vma\",{\"1\":{\"68\":1}}],[\"执行指令\",{\"1\":{\"70\":1}}],[\"物理页多次映射\",{\"1\":{\"69\":1}}],[\"物理页普通映射\",{\"1\":{\"69\":1}}],[\"另一份seg1\",{\"1\":{\"69\":1}}],[\"另外三个所在的设备号和次设备号以及文件节点都是0\",{\"1\":{\"68\":1}}],[\"另外值得注意的是可能有些编译器并不是将弱符号使用common块\",{\"1\":{\"57\":1}}],[\"系统将它们映射两份到虚拟地址空间\",{\"1\":{\"69\":1}}],[\"空间使用率只有58\",{\"1\":{\"69\":1}}],[\"空间与地址分配\",{\"0\":{\"47\":1},\"1\":{\"49\":1}}],[\"权限\",{\"1\":{\"69\":1}}],[\"偏移\",{\"1\":{\"69\":1}}],[\"长度\",{\"1\":{\"69\":1}}],[\"匿名\",{\"1\":{\"68\":2}}],[\"代码vma\",{\"1\":{\"68\":1}}],[\"代码段结束地址\",{\"1\":{\"40\":1}}],[\"代码段\",{\"0\":{\"20\":1},\"1\":{\"29\":1}}],[\"堆栈里面还保存了动态链接器所需要的一些辅助信息数组\",{\"1\":{\"86\":1}}],[\"堆栈里面保存了关于进程执行环境和命令行参数等信息\",{\"1\":{\"86\":1}}],[\"堆栈提示段\",{\"1\":{\"19\":1}}],[\"堆vma\",{\"1\":{\"68\":1}}],[\"堆和栈\",{\"0\":{\"68\":1}}],[\"来说\",{\"1\":{\"67\":1}}],[\"来定义任何一个强符号为弱符号\",{\"1\":{\"43\":1}}],[\"描述\",{\"1\":{\"67\":1}}],[\"描述了整个文件的文件属性\",{\"1\":{\"18\":1}}],[\"属性的结构叫做段表\",{\"1\":{\"67\":1}}],[\"属性和位置\",{\"1\":{\"49\":1}}],[\"正好对应通过指令计算出的偏移量0x114e\",{\"1\":{\"77\":1}}],[\"正如描述\",{\"1\":{\"67\":1}}],[\"正确的\",{\"1\":{\"55\":2}}],[\"假设链接器在全局符号表里面找到\",{\"1\":{\"85\":1}}],[\"假设lookup的原型为lookup\",{\"1\":{\"80\":1}}],[\"假设liba\",{\"1\":{\"80\":1}}],[\"假设module\",{\"1\":{\"78\":1}}],[\"假设共享库被加载到0x100000000的位置\",{\"1\":{\"77\":1}}],[\"假设该模块经过加载后位于虚拟内存的0x10000000处\",{\"1\":{\"77\":1}}],[\"假设系统中有两环境变量\",{\"1\":{\"70\":1}}],[\"假设\",{\"1\":{\"67\":1}}],[\"假设我们的elf可执行文件只有一个代码段\",{\"1\":{\"64\":1}}],[\"计算出相应的页面在可执行文件中的偏移\",{\"1\":{\"65\":1}}],[\"计算输出文件中各个段合并后的长度和位置\",{\"1\":{\"49\":1}}],[\"会去寻址装载该可执行文件所需要相应的动态链接器\",{\"1\":{\"82\":1}}],[\"会发现对应页面是一个空页面\",{\"1\":{\"65\":1}}],[\"会在进程相应的数据结构中设置一个\",{\"1\":{\"64\":1}}],[\"页错误\",{\"0\":{\"65\":1},\"1\":{\"65\":1}}],[\"页映射\",{\"0\":{\"62\":1}}],[\"直接跳转到可执行文件的入口地址\",{\"1\":{\"64\":1}}],[\"直到u和d都不再发生变化\",{\"1\":{\"55\":1}}],[\"启动运行\",{\"1\":{\"64\":1}}],[\"操作系统在对可执行文件进行加载时==\",{\"1\":{\"82\":1}}],[\"操作系统在加载完动态链接器后\",{\"1\":{\"81\":1}}],[\"操作系统在某个特定的地址划分出一些地址块\",{\"1\":{\"75\":1}}],[\"操作系统统一通过映射的方式将它加载到进程的地址空间中\",{\"1\":{\"81\":1}}],[\"操作系统会先启动一个动态链接器\",{\"1\":{\"81\":1}}],[\"操作系统还不能在装载完可执行文件之后就把控制权交给可执行文件\",{\"1\":{\"81\":1}}],[\"操作系统接着就可以把控制权交给可执行文件的入口地址\",{\"1\":{\"81\":1}}],[\"操作系统通过给进程空间划出一个个vma来管理进程的虚拟空间\",{\"1\":{\"68\":1}}],[\"操作系统处理页错误时\",{\"1\":{\"65\":1}}],[\"操作系统只是通过可执行文件头部的信息建立起可执行文件和进程虚拟内存之间的映射关系\",{\"1\":{\"65\":1}}],[\"操作系统创建进程后\",{\"1\":{\"64\":1}}],[\"操作系统将从物理内存中分配一个物理页\",{\"1\":{\"64\":1}}],[\"过程链接表\",{\"1\":{\"80\":1}}],[\"过程\",{\"1\":{\"64\":1}}],[\"应当知道所需的页在可执行文件中的那一个位置\",{\"1\":{\"64\":1}}],[\"再把控制权传递给addvec\",{\"1\":{\"80\":1}}],[\"再设置缺页的虚拟页和物理页的映射关系\",{\"1\":{\"64\":1}}],[\"再以\",{\"1\":{\"41\":1}}],[\"缺页\",{\"1\":{\"64\":1}}],[\"甚至不需要设置页映射关系\",{\"1\":{\"64\":1}}],[\"创建虚拟地址空间实际上只是分配一个页目录\",{\"1\":{\"64\":1}}],[\"创建一个独立的虚拟地址空间\",{\"1\":{\"64\":1}}],[\"从第四项开始存放导入函数的地方\",{\"1\":{\"85\":1}}],[\"从plt\",{\"1\":{\"80\":1}}],[\"从这点来看\",{\"1\":{\"79\":1}}],[\"从这一点可以推断\",{\"1\":{\"73\":1}}],[\"从功能上来说完全一样\",{\"1\":{\"77\":1}}],[\"从\",{\"1\":{\"67\":2}}],[\"从装载的角度看\",{\"1\":{\"67\":1}}],[\"从而实现了地址的重定位\",{\"1\":{\"85\":1}}],[\"从而使得共享模块中对global的引用要执行可执行文件中的globa副本\",{\"1\":{\"78\":1}}],[\"从而导致这些地址对每个进程来说是不同的\",{\"1\":{\"76\":1}}],[\"从而节省内存空间\",{\"1\":{\"67\":1}}],[\"从而触发页错误\",{\"1\":{\"65\":1}}],[\"从操作系统装载可执行文件的角度看\",{\"1\":{\"67\":1}}],[\"从操作系统角度看可执行文件的装载\",{\"0\":{\"63\":1}}],[\"从进程的角度看这一步可以简单的认为操作系统执行了一条跳转指令\",{\"1\":{\"64\":1}}],[\"从磁盘中读取到内存中\",{\"1\":{\"64\":1}}],[\"从段表中可以得到每个的段的所有信息\",{\"1\":{\"18\":1}}],[\"虚拟内存\",{\"1\":{\"62\":1}}],[\"虚拟地址内存分配\",{\"1\":{\"52\":1}}],[\"虚拟地址\",{\"1\":{\"49\":1}}],[\"建议阅读csapp\",{\"1\":{\"62\":1}}],[\"覆盖装入的方法把挖掘内存潜力的任务交给了程序员\",{\"1\":{\"61\":1}}],[\"覆盖装入\",{\"0\":{\"61\":1}}],[\"工具查看这个文件包含了那些目标文件\",{\"1\":{\"58\":1}}],[\"值得注意的是\",{\"1\":{\"57\":1}}],[\"采用的就是与common块一样的机制\",{\"1\":{\"57\":1}}],[\"现在我们希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变\",{\"1\":{\"77\":1}}],[\"现在的linux下的gcc编译器中\",{\"1\":{\"40\":1}}],[\"现代的链接机制在处理弱符号时\",{\"1\":{\"57\":1}}],[\"早期的fortran没有动态分配空间的机制\",{\"1\":{\"57\":1}}],[\"被修正的位置只需要填入符号的地址即可\",{\"1\":{\"85\":1}}],[\"被装载入内存\",{\"1\":{\"80\":1}}],[\"被引用的符号地址\",{\"1\":{\"56\":1}}],[\"被隐藏的过程\",{\"0\":{\"6\":1}}],[\"标志来编译\",{\"1\":{\"56\":1}}],[\"大型代码模型\",{\"1\":{\"56\":1}}],[\"大于2gb的程序可以使用\",{\"1\":{\"56\":1}}],[\"中\",{\"1\":{\"85\":1}}],[\"中往往保存了所有符号\",{\"1\":{\"84\":1}}],[\"中读取每个\",{\"1\":{\"81\":1}}],[\"中型代码模型\",{\"1\":{\"56\":1}}],[\"中的偏移为0x000000004018位置中去\",{\"1\":{\"85\":1}}],[\"中的符号\",{\"1\":{\"84\":1}}],[\"中的下一条指令\",{\"1\":{\"80\":1}}],[\"中的\",{\"1\":{\"50\":1}}],[\"得到有效地址\",{\"1\":{\"56\":1}}],[\"原书第七章\",{\"0\":{\"56\":1}}],[\"参考csapp\",{\"0\":{\"56\":1},\"1\":{\"80\":1}}],[\"参数类型\",{\"1\":{\"41\":1}}],[\"参数可以打印更多信息\",{\"1\":{\"19\":1}}],[\"都是生成地址无关代码\",{\"1\":{\"77\":1}}],[\"都是可读可执行\",{\"1\":{\"67\":1}}],[\"都是und\",{\"1\":{\"55\":1}}],[\"都会有一个相应的重定位表\",{\"1\":{\"33\":1}}],[\"依赖的共享对象文件\",{\"1\":{\"83\":1}}],[\"依赖\",{\"1\":{\"55\":3}}],[\"特别是出现相互依赖的库文件时更容易出现这种错误\",{\"1\":{\"55\":1}}],[\"特殊符号\",{\"0\":{\"40\":1}}],[\"最关键的还是所依赖的符号和相关文件的信息\",{\"1\":{\"84\":1}}],[\"最后开始执行\",{\"1\":{\"73\":1}}],[\"最后一列是可执行文件的路径\",{\"1\":{\"68\":1}}],[\"最前面四个字节表示命令行参数的数量\",{\"1\":{\"70\":1}}],[\"最主要的时段的权限\",{\"1\":{\"67\":1}}],[\"最终导致符号未定义行为\",{\"1\":{\"55\":1}}],[\"最好不要这样负责会出现一些意想不到的bug\",{\"1\":{\"43\":1}}],[\"存档文件\",{\"1\":{\"55\":1}}],[\"存放只读数据\",{\"1\":{\"21\":1}}],[\"错误的\",{\"1\":{\"55\":2}}],[\"构建输出的可执行文件\",{\"1\":{\"55\":1}}],[\"否则就会超出被分配的空间\",{\"1\":{\"75\":1}}],[\"否则就会引起应用程序崩溃\",{\"1\":{\"75\":1}}],[\"否则就是不合理的\",{\"1\":{\"67\":1}}],[\"否则链接就会报符号未定义错误\",{\"1\":{\"55\":1}}],[\"否则\",{\"1\":{\"55\":1}}],[\"此时可以给编译选项加上\",{\"1\":{\"57\":1}}],[\"此时\",{\"1\":{\"55\":1}}],[\"此时的指令地址时暂时的\",{\"1\":{\"52\":1}}],[\"定义了一个符号来解析u中的一个引用\",{\"1\":{\"55\":1}}],[\"定义在目标文件的全局符号\",{\"1\":{\"35\":1}}],[\"修正值\",{\"1\":{\"56\":1}}],[\"修正后的地址\",{\"0\":{\"53\":1}}],[\"修改u和d来反映f中的符号定义和引用\",{\"1\":{\"55\":1}}],[\"以及数据段\",{\"1\":{\"85\":1}}],[\"以及一个在前面输入文件中已定义的符号集合d\",{\"1\":{\"55\":1}}],[\"以确保每个指针所指向的地址正确\",{\"1\":{\"77\":1}}],[\"以只读数据为代表的权限为只读段\",{\"1\":{\"67\":1}}],[\"以数据段和bss段位代表的权限为可读可写段\",{\"1\":{\"67\":1}}],[\"以代码段为代表的权限为可读可执行段\",{\"1\":{\"67\":1}}],[\"以最大的那块为准\",{\"1\":{\"57\":1}}],[\"以便于程序代码能够识别\",{\"1\":{\"44\":1}}],[\"以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号\",{\"1\":{\"7\":1}}],[\"静态变量\",{\"1\":{\"77\":1}}],[\"静态共享库的升级也是问题\",{\"1\":{\"75\":1}}],[\"静态共享库的目标地址导致了很多问题\",{\"1\":{\"75\":1}}],[\"静态共享库的做法就是将程序的各个模块统一交给操作系统管理\",{\"1\":{\"75\":1}}],[\"静态库可以简单的看成一组目标文件的集合\",{\"1\":{\"58\":1}}],[\"静态库链接\",{\"0\":{\"58\":1}}],[\"静态库\",{\"1\":{\"55\":1}}],[\"静态链接时的重定位被称为链接时重定位\",{\"1\":{\"76\":1}}],[\"静态链接库\",{\"1\":{\"17\":1}}],[\"静态链接\",{\"0\":{\"11\":1,\"46\":1},\"1\":{\"32\":1}}],[\"需要知道一些必要信息才能完成这个函数地址绑定的工作\",{\"1\":{\"80\":1}}],[\"需要修改的重定位地址\",{\"1\":{\"56\":1}}],[\"需要补充的一点是linux链接器在符号解析阶段\",{\"1\":{\"55\":1}}],[\"需要注意的是\",{\"1\":{\"43\":1,\"72\":1}}],[\"找到相应的符号后进行重定位\",{\"1\":{\"55\":1}}],[\"`global\",{\"1\":{\"57\":1}}],[\"`swap\",{\"1\":{\"55\":1}}],[\"`shared\",{\"1\":{\"55\":2}}],[\"`main\",{\"1\":{\"55\":1}}],[\"`\",{\"1\":{\"55\":1}}],[\"^~~~\",{\"1\":{\"55\":1}}],[\"^=\",{\"1\":{\"46\":3}}],[\"|\",{\"1\":{\"55\":2,\"58\":1}}],[\"未定义的类型\",{\"1\":{\"55\":1}}],[\"未正确链接目标文件或者库文件导致\",{\"1\":{\"55\":1}}],[\"未初始化\",{\"1\":{\"43\":2}}],[\"未初始化的全局变量为弱符号\",{\"1\":{\"43\":1}}],[\"未初始化的全局变量和局部静态变量\",{\"1\":{\"18\":1,\"22\":1}}],[\"下一条指令\",{\"1\":{\"54\":1}}],[\"既实现了动态链接最关键的一步\",{\"1\":{\"85\":1}}],[\"既还没有和相应的共享对象中的实际位置链接起来\",{\"1\":{\"81\":1}}],[\"既无法判断是否为跨模块间的调用\",{\"1\":{\"78\":1}}],[\"既目标地址确定\",{\"1\":{\"76\":1}}],[\"既共享对象在编译时不能假设自己在进程虚拟地址空间中的位置\",{\"1\":{\"75\":1}}],[\"既很多目标文件经过压缩打包后形成的一个文件\",{\"1\":{\"58\":1}}],[\"既\",{\"1\":{\"54\":1,\"82\":1}}],[\"既不同的目标文件中不能有同名的强符号\",{\"1\":{\"43\":1}}],[\"同样可以采用类型三的方法来解决\",{\"1\":{\"77\":1}}],[\"同理\",{\"1\":{\"54\":1}}],[\"同时分配虚拟空间\",{\"1\":{\"49\":1}}],[\"因此有如下方式\",{\"1\":{\"77\":1}}],[\"因此我们在构造elf可执行文件时不需要再额外设立bss的\",{\"1\":{\"67\":1}}],[\"因此会报重定义错误\",{\"1\":{\"57\":1}}],[\"因此在运行时可以用32位pc相对地址来访问\",{\"1\":{\"56\":1}}],[\"因此又被称为重定位段\",{\"1\":{\"54\":1}}],[\"因为可执行文件依赖于很多共享对象\",{\"1\":{\"81\":1}}],[\"因为可执行文件往往是第一个被加载的文件\",{\"1\":{\"75\":1}}],[\"因为本身是一些地址无关代码\",{\"1\":{\"80\":1}}],[\"因为每个got条目初始化时都指向它对应的plt条目的第二条指令\",{\"1\":{\"80\":1}}],[\"因为大量的全局变量会导致模块间耦合度变大\",{\"1\":{\"80\":1}}],[\"因为global可能被可执行文件引用\",{\"1\":{\"78\":1}}],[\"因为编译器无法确定对global的引用是跨模块的还是模块内部的\",{\"1\":{\"78\":1}}],[\"因为编译器需要使用它们\",{\"1\":{\"7\":1}}],[\"因为被调用的函数与调用者都在同一个模块\",{\"1\":{\"77\":1}}],[\"因为指令部分对于每个进程来说可能会被映射到每个进程的不同虚拟空间\",{\"1\":{\"76\":1}}],[\"因为静态共享库被分配到的虚拟地址空间是有限的\",{\"1\":{\"75\":1}}],[\"因为升级后的共享库必须保持共享库中全局函数和变量地址的不变\",{\"1\":{\"75\":1}}],[\"因为运行时进行动态链接还需要使用符号信息\",{\"1\":{\"73\":1}}],[\"因为elf目标文件不需要被装载\",{\"1\":{\"67\":1}}],[\"因为只有它是需要被映射的\",{\"1\":{\"67\":1}}],[\"因为链接器时从左到右开始扫描的\",{\"1\":{\"55\":1}}],[\"因为重定位表其实就是elf文件中的一个段\",{\"1\":{\"54\":1}}],[\"因为各个符号在段内的相对位置时固定的\",{\"1\":{\"50\":1}}],[\"因为它在文件中并没有内容\",{\"1\":{\"49\":1}}],[\"因为字符串的长度往往是不定的\",{\"1\":{\"34\":1}}],[\"经过修正后\",{\"1\":{\"53\":1}}],[\"经过修饰后的名字为\",{\"1\":{\"41\":1}}],[\"截取了部分\",{\"1\":{\"53\":1}}],[\"真正的地址计算工作留给了连接器\",{\"1\":{\"52\":1}}],[\"即p的值需要加上一个装载地址a\",{\"1\":{\"85\":1}}],[\"即p值为b\",{\"1\":{\"85\":1}}],[\"即程序开始执行时\",{\"1\":{\"80\":1}}],[\"即使是模块内部的\",{\"1\":{\"78\":1}}],[\"即使升级静态共享库后保持原有的函数和变量地址不变\",{\"1\":{\"75\":1}}],[\"即0x10000000\",{\"1\":{\"77\":1}}],[\"即\",{\"1\":{\"70\":1}}],[\"即20480字节\",{\"1\":{\"69\":1}}],[\"即引用了但尚未定义的符号\",{\"1\":{\"55\":1}}],[\"即没有执行链接的第一步\",{\"1\":{\"52\":1}}],[\"即目标文件指令与源代码中代码行的对应关系\",{\"1\":{\"35\":1}}],[\"各个段在链接后的虚拟地址空间已经确定\",{\"1\":{\"50\":1}}],[\"调用系统启动函数\",{\"1\":{\"80\":1}}],[\"调用函数并不直接通过got跳转\",{\"1\":{\"80\":1}}],[\"调用\",{\"1\":{\"77\":1}}],[\"调整代码中的地址等\",{\"1\":{\"49\":1}}],[\"调试信息\",{\"0\":{\"45\":1}}],[\"读取可执行文件头\",{\"1\":{\"64\":1}}],[\"读取输入文件中段的数据\",{\"1\":{\"49\":1}}],[\"读写权限及段的其它属性\",{\"1\":{\"24\":1}}],[\"并将它们映射到进程虚拟空间的相应位置\",{\"1\":{\"81\":1}}],[\"并继续下一个输入文件\",{\"1\":{\"55\":1}}],[\"并建立映射关系\",{\"1\":{\"49\":1}}],[\"并且提供给其它模块使用\",{\"1\":{\"84\":1}}],[\"并且每个进程都可以有独立的副本\",{\"1\":{\"77\":1}}],[\"并且从上面的进程虚拟空间分布看到\",{\"1\":{\"73\":1}}],[\"并且输出可执行文件program1\",{\"1\":{\"73\":1}}],[\"并且它们的权限相同\",{\"1\":{\"67\":1}}],[\"并且建立虚拟空间与可执行文件的映射关系\",{\"1\":{\"64\":1}}],[\"并且链接器修改u和d来反映m中的符号定义和引用\",{\"1\":{\"55\":1}}],[\"并且进行符号解析与重定位\",{\"1\":{\"49\":1}}],[\"并且将它们合并\",{\"1\":{\"49\":1}}],[\"并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来\",{\"1\":{\"49\":1}}],[\"并且获得它们的各个段的长度\",{\"1\":{\"49\":1}}],[\"统一放到一个全局符号表\",{\"1\":{\"49\":1}}],[\"扫描所有的输入目标文件\",{\"1\":{\"49\":1}}],[\"分别编译链接program1和program2\",{\"1\":{\"73\":1}}],[\"分配空间只局限与虚拟地址空间\",{\"1\":{\"49\":1}}],[\"分段的好处\",{\"1\":{\"18\":1}}],[\"装载时重定位是解决动态模块中没有绝对地址应用的办法之一\",{\"1\":{\"77\":1}}],[\"装载时重定位的问题\",{\"1\":{\"76\":1}}],[\"装载时重定位\",{\"0\":{\"76\":1}}],[\"装载器根据当前地址空间的空闲情况\",{\"1\":{\"73\":1}}],[\"装载\",{\"1\":{\"64\":1}}],[\"装载的方式\",{\"0\":{\"60\":1}}],[\"装载后的虚拟地址中的虚拟地址空间\",{\"1\":{\"49\":1}}],[\"装载和库\",{\"0\":{\"4\":1}}],[\"输出的可执行文件中的空间\",{\"1\":{\"49\":1}}],[\"关于地址和空间的两个含义\",{\"1\":{\"49\":1}}],[\"重要\",{\"1\":{\"49\":2,\"53\":1,\"55\":1,\"56\":1,\"67\":1,\"68\":1,\"72\":1,\"73\":1,\"76\":1,\"77\":1,\"83\":1}}],[\"重定位等\",{\"1\":{\"80\":1}}],[\"重定位一个使用32位绝对地址的引用\",{\"1\":{\"56\":1}}],[\"重定位一个使用32位pc相对地址的引用\",{\"1\":{\"56\":1}}],[\"重定位过程中\",{\"1\":{\"55\":1}}],[\"重定位的过程也伴随着符号解析的过程\",{\"1\":{\"55\":1}}],[\"重定位信息\",{\"1\":{\"49\":1}}],[\"重定位表分别叫做\",{\"1\":{\"85\":1}}],[\"重定位表结构\",{\"1\":{\"54\":1}}],[\"重定位表的结构\",{\"1\":{\"54\":1}}],[\"重定位表\",{\"0\":{\"33\":1,\"54\":1},\"1\":{\"32\":1,\"33\":1}}],[\"重定位所做的就是给程序中每个这样的绝对地址引用的地址进行修正\",{\"1\":{\"14\":1}}],[\"重定位入口的偏移\",{\"1\":{\"54\":1}}],[\"重定位入口\",{\"1\":{\"14\":1}}],[\"重定位\",{\"0\":{\"14\":1,\"52\":1},\"1\":{\"14\":1}}],[\"接着是两个指向环境变量的字符串的指针\",{\"1\":{\"70\":1}}],[\"接着是\",{\"1\":{\"49\":1}}],[\"合并到输出文件的\",{\"1\":{\"49\":1}}],[\"什么是动态链接\",{\"0\":{\"72\":1}}],[\"什么是相似段合并\",{\"1\":{\"49\":1}}],[\"什么是按序叠加\",{\"1\":{\"48\":1}}],[\"就会把对global的调用按照跨模块模式产生代码\",{\"1\":{\"78\":1}}],[\"就会使用装载过程的中建立的可执行文件与虚拟内存的映射关系从而找到空页所在的vma\",{\"1\":{\"65\":1}}],[\"就可以得到got的位置\",{\"1\":{\"77\":1}}],[\"就可以了\",{\"1\":{\"64\":1}}],[\"就必须重新链接应用程序\",{\"1\":{\"75\":1}}],[\"就表示该\",{\"1\":{\"67\":1}}],[\"就要确定这个符号的目的地址\",{\"1\":{\"55\":1}}],[\"就算一个段只有1字节的大小\",{\"1\":{\"48\":1}}],[\"就是将相同性质的段进行合并\",{\"1\":{\"49\":1}}],[\"就是将各个目标文件依次合并\",{\"1\":{\"48\":1}}],[\"就是\",{\"1\":{\"33\":1}}],[\"主要原因是内存对齐\",{\"1\":{\"48\":1}}],[\"主要决定段的属性的是段的类型\",{\"1\":{\"30\":1}}],[\"那就是所有的使用这个变量的指令都指向位于可执行文件中的那个副本\",{\"1\":{\"78\":1}}],[\"那变量a所在的虚拟内存地址为\",{\"1\":{\"77\":1}}],[\"那些额外的部分就是bss\",{\"1\":{\"67\":1}}],[\"那将m加到么就e中\",{\"1\":{\"55\":1}}],[\"那这个段也要占据4096字节的内存大小\",{\"1\":{\"48\":1}}],[\"那最后输出文件将会有成百上千零散的段\",{\"1\":{\"48\":1}}],[\"那么至少它需要知道关于可执行文件和本进程的些信息\",{\"1\":{\"86\":1}}],[\"那么实际上该变量a的地址为a+b\",{\"1\":{\"85\":1}}],[\"那么对于program1来说\",{\"1\":{\"84\":1}}],[\"那么lookup\",{\"1\":{\"80\":1}}],[\"那么当liba\",{\"1\":{\"80\":1}}],[\"那么当连接器需要对某个符号的引用进行重定位时\",{\"1\":{\"55\":1}}],[\"那么编译器和链接器就会产生一个重定位表\",{\"1\":{\"79\":1}}],[\"那么p的地址就是一个绝对地址\",{\"1\":{\"79\":1}}],[\"那么gcc编译器在\",{\"1\":{\"78\":1}}],[\"那么got中相应地址就指向模块内部的该变量副本\",{\"1\":{\"78\":1}}],[\"那么动态链接器就会对该共享对象进行重定位\",{\"1\":{\"79\":1}}],[\"那么动态链接器就会把got中的相应地址指向该副本\",{\"1\":{\"78\":1}}],[\"那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本\",{\"1\":{\"78\":1}}],[\"那么现在global变量定义在原先的共享对象中\",{\"1\":{\"78\":1}}],[\"那么这种情况下\",{\"1\":{\"78\":1}}],[\"那么这个成员表示符号所在的段在段表中的下标\",{\"1\":{\"38\":1}}],[\"那么这个段的类型\",{\"1\":{\"33\":1}}],[\"那么只需要相对于当前指令\",{\"1\":{\"77\":1}}],[\"那么系统就对程序中所有的绝对地址引用进行重定位\",{\"1\":{\"76\":1}}],[\"那么装载的时候就可以将它们看作一个整体一起映射\",{\"1\":{\"67\":1}}],[\"那么我们也可以在编译时确定got相对于当前指令的偏移\",{\"1\":{\"77\":1}}],[\"那么我们可以对于相同的段\",{\"1\":{\"67\":1}}],[\"那么我们就称文件a定义\",{\"1\":{\"35\":1}}],[\"那么最终输出结果中的符号所占空间与强符号相同\",{\"1\":{\"57\":1}}],[\"那么链接器将会按照静态链接的规则\",{\"1\":{\"73\":1}}],[\"那么链接器将会把这个指令的目标地址部分修改为0x1000\",{\"1\":{\"14\":1}}],[\"那么链接器通常会给出警告\",{\"1\":{\"57\":1}}],[\"那么链接器就会将这个地址填入到\",{\"1\":{\"85\":1}}],[\"那么链接器就会将这个符号的引用标记为一个动态链接的符号\",{\"1\":{\"73\":1}}],[\"那么链接器就会输出一个错误并终止\",{\"1\":{\"55\":1}}],[\"那么链接器就尝试匹配u中未解析的符号和由存档文件成员定义的符号\",{\"1\":{\"55\":1}}],[\"那么链接器把f添加到e\",{\"1\":{\"55\":1}}],[\"那么会有一个相应的叫\",{\"1\":{\"54\":1}}],[\"那么\",{\"1\":{\"50\":1}}],[\"那么选其中占用空间最大的一个\",{\"1\":{\"43\":1}}],[\"那么选强符号\",{\"1\":{\"43\":1}}],[\"那么符号的值就是这个函数或变量的地址\",{\"1\":{\"39\":1}}],[\"判断是否链接到pthread库\",{\"1\":{\"44\":1}}],[\"声明对一个外部函数的引用为弱引用\",{\"1\":{\"44\":1}}],[\"连接器在完成第一步的虚拟内存分配后就可以确定所有符号的虚拟地址了\",{\"1\":{\"52\":1}}],[\"连接器通过给每个符号加上一个偏移量\",{\"1\":{\"50\":1}}],[\"连接器默认其为0\",{\"1\":{\"44\":1}}],[\"连接器按如下规则处理与选择被多次定义的全局符号\",{\"1\":{\"43\":1}}],[\"强引用\",{\"1\":{\"44\":1}}],[\"强符号\",{\"1\":{\"43\":2}}],[\"强符号和弱符号都是针对定义的\",{\"1\":{\"43\":1}}],[\"强符合与弱符号\",{\"0\":{\"43\":1}}],[\"弱引用\",{\"1\":{\"44\":1}}],[\"弱引用和强引用\",{\"0\":{\"44\":1}}],[\"弱符号\",{\"1\":{\"43\":2}}],[\"而共享对象的重定位则是在装载时完成的\",{\"1\":{\"85\":1}}],[\"而lib\",{\"1\":{\"84\":1}}],[\"而变量a的地址会随着共享对象的装载地址改变而改变\",{\"1\":{\"79\":1}}],[\"而在可执行文件的\",{\"1\":{\"78\":1}}],[\"而模块module\",{\"1\":{\"78\":1}}],[\"而且较快\",{\"1\":{\"77\":1}}],[\"而且很难发现\",{\"1\":{\"43\":1}}],[\"而\",{\"1\":{\"77\":2,\"85\":1}}],[\"而该函数内部实现依旧是跳转到got表中通过间接跳转实现对函数的调用\",{\"1\":{\"77\":1}}],[\"而通过查看符号表信息可以得到变量a所在elf文件中的位置\",{\"1\":{\"77\":1}}],[\"而数据部分可以在每个进程中拥有一个副本\",{\"1\":{\"77\":1}}],[\"而对于可修改数据部分来说每个进程都有不同的副本\",{\"1\":{\"76\":1}}],[\"而对于单个程序来说\",{\"1\":{\"75\":1}}],[\"而现在这种情况通常被称为装载时重定位\",{\"1\":{\"76\":1}}],[\"而把这一步推迟到装载时完成\",{\"1\":{\"76\":1}}],[\"而是由elf可执行文件决定\",{\"1\":{\"82\":1}}],[\"而是通过一个叫做plt项的结构来进行跳转\",{\"1\":{\"80\":1}}],[\"而是需要用到时才由动态链接器来负责绑定\",{\"1\":{\"80\":1}}],[\"而是在装载时\",{\"1\":{\"73\":1}}],[\"而是0x7f066ed25000\",{\"1\":{\"73\":1}}],[\"而是使用的bss段\",{\"1\":{\"57\":1}}],[\"而不静态链接器ld完成\",{\"1\":{\"72\":1}}],[\"而不是两个\",{\"1\":{\"67\":1}}],[\"而可执行文件和共享库文件都有\",{\"1\":{\"67\":1}}],[\"而静态库文件\",{\"1\":{\"55\":1}}],[\"而链接器将继续处理下一个输入文件\",{\"1\":{\"55\":1}}],[\"而0x408\",{\"1\":{\"29\":1}}],[\"当操作系统将控制权交给它时\",{\"1\":{\"86\":1}}],[\"当所有动态链接工作完成后\",{\"1\":{\"81\":1}}],[\"当动态链接器需要进行重定位时\",{\"1\":{\"85\":1}}],[\"当动态链接器获得控制权后\",{\"1\":{\"81\":1}}],[\"当动态链接器装载共享对象时\",{\"1\":{\"79\":1}}],[\"当我们调用某个外部模块的函数时\",{\"1\":{\"80\":1}}],[\"当共享模块被装载时\",{\"1\":{\"78\":1}}],[\"当编译器编译moudule\",{\"1\":{\"78\":1}}],[\"当一个模块引用了一个定义在共享对象的全局变量的时比如一个共享对象定义了一个全局变量global\",{\"1\":{\"78\":1}}],[\"当模块需要调用目标函数时\",{\"1\":{\"77\":1}}],[\"当然got中每个地址对应于哪个变量是由编译器决定的\",{\"1\":{\"77\":1}}],[\"当然common块的链接规则仅仅是针对弱符号的\",{\"1\":{\"57\":1}}],[\"当指令需要访问变量b时\",{\"1\":{\"77\":1}}],[\"当代码需要引用该变量时\",{\"1\":{\"77\":1}}],[\"当前执行的下一条指令\",{\"1\":{\"77\":1}}],[\"当链接器将program1\",{\"1\":{\"73\":1}}],[\"当程序模块program1\",{\"1\":{\"73\":1}}],[\"当程序执行发生页错误时\",{\"1\":{\"64\":1}}],[\"当cpu开始执行指令时\",{\"1\":{\"65\":1}}],[\"当不同的目标文件需要的common块空间大小不一致时\",{\"1\":{\"57\":1}}],[\"当输入指令如下时就会出现符号未定义错误\",{\"1\":{\"55\":1}}],[\"当输入文件很多时\",{\"1\":{\"48\":1}}],[\"当a和b链接时\",{\"1\":{\"43\":1}}],[\"当它经过编译后的符号名就为\",{\"1\":{\"40\":1}}],[\"则没有这样的限制\",{\"1\":{\"77\":1}}],[\"则表示它们没有映射到文件中\",{\"1\":{\"68\":1}}],[\"则连接器对于该引用不报错\",{\"1\":{\"44\":1}}],[\"则连接器将该符号的引用决议\",{\"1\":{\"44\":1}}],[\"则链接器报符号重定义错误\",{\"1\":{\"43\":1}}],[\"则st\",{\"1\":{\"39\":1}}],[\"不同的是\",{\"1\":{\"84\":1}}],[\"不同的平台有着不同的实现\",{\"1\":{\"77\":1}}],[\"不直接调用addvec\",{\"1\":{\"80\":1}}],[\"不过可以想象\",{\"1\":{\"80\":1}}],[\"不能增长太多\",{\"1\":{\"75\":1}}],[\"不对其进行地址重定位\",{\"1\":{\"73\":1}}],[\"不可执行\",{\"1\":{\"68\":1}}],[\"不需要进一步修改\",{\"1\":{\"56\":1}}],[\"不允许被多次定义\",{\"1\":{\"43\":1}}],[\"不是针对符号的引用\",{\"1\":{\"43\":1}}],[\"有一个专门的段叫符号表\",{\"1\":{\"84\":1}}],[\"有一个专门的段叫做==\",{\"1\":{\"82\":1}}],[\"有映像文件\",{\"1\":{\"68\":2}}],[\"有相同映像文件的映射成一个vma\",{\"1\":{\"68\":1}}],[\"有符号常数\",{\"1\":{\"56\":1}}],[\"有些符号的定义也被称为弱符号\",{\"1\":{\"43\":1}}],[\"有目标文件a有全局变量var\",{\"1\":{\"14\":1}}],[\"深入理解计算机系统\",{\"1\":{\"43\":1}}],[\"和r\",{\"1\":{\"85\":1}}],[\"和got\",{\"1\":{\"80\":1}}],[\"和plt联合使用时\",{\"1\":{\"80\":1}}],[\"和数据部分放在一起\",{\"1\":{\"77\":1}}],[\"和段表结构一样\",{\"1\":{\"67\":1}}],[\"和段的标志位\",{\"1\":{\"30\":1}}],[\"和\",{\"1\":{\"49\":1,\"50\":1,\"53\":1,\"56\":1,\"67\":2,\"70\":1,\"84\":2,\"85\":2}}],[\"和func\",{\"1\":{\"41\":1}}],[\"zz4funce3foo\",{\"1\":{\"41\":1}}],[\"zz4maine3foo和\",{\"1\":{\"41\":1}}],[\"zn6myname3vare\",{\"1\":{\"42\":1}}],[\"zn3far3bare\",{\"1\":{\"41\":1}}],[\"zn1n1c4funcei\",{\"1\":{\"41\":2}}],[\"zn1n1c4funce\",{\"1\":{\"41\":1}}],[\"z\",{\"1\":{\"41\":1,\"80\":5}}],[\"zr\",{\"1\":{\"20\":1}}],[\"所有这些未定义的符号都应该能在全局符号表中找到\",{\"1\":{\"55\":1}}],[\"所有引用到的外部符号\",{\"1\":{\"54\":1}}],[\"所有符号都以\",{\"1\":{\"41\":1}}],[\"所以可以和代码段等一起合并成同一个可读可指向的\",{\"1\":{\"80\":1}}],[\"所以可以使用装载时重定位的方法来处理\",{\"1\":{\"76\":1}}],[\"所以程序开始执行时\",{\"1\":{\"80\":1}}],[\"所以elf采用了一种叫\",{\"1\":{\"80\":1}}],[\"所以并不担心被进程改变\",{\"1\":{\"79\":1}}],[\"所以变量的地址必须在链接过程中确定下来\",{\"1\":{\"78\":1}}],[\"所以为了方便\",{\"1\":{\"77\":1}}],[\"所以需要补0所以\",{\"1\":{\"77\":1}}],[\"所以对于这种指令是不需要重定位的\",{\"1\":{\"77\":1}}],[\"所以这种情况会比较简单\",{\"1\":{\"77\":1}}],[\"所以这时\",{\"1\":{\"50\":1}}],[\"所以我们只需要将指令中那些需要被修改的部分进行剥离\",{\"1\":{\"77\":1}}],[\"所以没有办法做到同一份指令被多个进程共享\",{\"1\":{\"76\":1}}],[\"所以他认为地址0x1000到0x2000的地址是空闲的\",{\"1\":{\"75\":1}}],[\"所以整个可执行文件只有12014字节却占用了5个页\",{\"1\":{\"69\":1}}],[\"所以整个n\",{\"1\":{\"41\":1}}],[\"所以它可以在模块装载时被修改\",{\"1\":{\"77\":1}}],[\"所以它们之间的相对位置是固定的\",{\"1\":{\"77\":1}}],[\"所以它没有程序头表\",{\"1\":{\"67\":1}}],[\"所以它被放到了\",{\"1\":{\"21\":1}}],[\"所以32位elf的对齐粒度为0x1000\",{\"1\":{\"64\":1}}],[\"所以当操作系统捕获到也错误发生时\",{\"1\":{\"64\":1}}],[\"所以必须事先声明它所需的临时使用空间的大小\",{\"1\":{\"57\":1}}],[\"所以在映射完可执行文件后\",{\"1\":{\"81\":1}}],[\"所以在程序开始执行前\",{\"1\":{\"80\":1}}],[\"所以在链接器扫描完所有的输入目标文件后\",{\"1\":{\"55\":1}}],[\"所以在文件中也不占据空间\",{\"1\":{\"18\":1}}],[\"所以main的起始地址为0\",{\"1\":{\"52\":1}}],[\"所以链接器在合并各个段的同时\",{\"1\":{\"49\":1}}],[\"所以即不是强符号也不是弱符号\",{\"1\":{\"43\":1}}],[\"所以c++名称修饰会对其不起作用\",{\"1\":{\"42\":1}}],[\"所以不论这个变量是整形还是浮点型甚至是全局对象\",{\"1\":{\"41\":1}}],[\"所以用固定的结构来表示它比较困难\",{\"1\":{\"34\":1}}],[\"所以simplesection\",{\"1\":{\"28\":1}}],[\"所以每个elf64\",{\"1\":{\"28\":1}}],[\"所以\",{\"1\":{\"21\":2,\"22\":1,\"64\":1}}],[\"所以编译器在无法确认var地址的情况下\",{\"1\":{\"14\":1}}],[\"使它成为一个对动态符号的引用\",{\"1\":{\"73\":1}}],[\"使它们能够调整到正确的虚拟地址\",{\"1\":{\"50\":1}}],[\"使得每个函数签名对应一个修饰后名称\",{\"1\":{\"41\":1}}],[\"使用ldd查看一个程序主模块或一个共享库依赖于哪些共享库\",{\"1\":{\"83\":1}}],[\"使用gcc将lib\",{\"1\":{\"73\":1}}],[\"使用gcc生成可执行文件\",{\"1\":{\"6\":1}}],[\"使用最简单的映射将每个段分开映射\",{\"1\":{\"69\":1}}],[\"使用\",{\"1\":{\"58\":1}}],[\"使用上一步中收集到的所有信息\",{\"1\":{\"49\":1}}],[\"使用某种名称修饰的方法\",{\"1\":{\"41\":1}}],[\"使用readelf查看文件的重定位表\",{\"1\":{\"85\":1}}],[\"使用readelf查看elf文件的动态符号表以及哈希表\",{\"1\":{\"84\":1}}],[\"使用readelf工具查看\",{\"1\":{\"83\":1}}],[\"使用readelf\",{\"1\":{\"39\":1,\"55\":1,\"67\":1}}],[\"使用nm指令查看符号结果\",{\"1\":{\"35\":1}}],[\"使用size指令查看elf文件的代码段\",{\"1\":{\"19\":1}}],[\"使用objdump工具查看\",{\"1\":{\"82\":1}}],[\"使用objdump指令查看某个符号在那个文件中\",{\"1\":{\"58\":1}}],[\"使用objdump指令查看链接前后的地址分配情况\",{\"1\":{\"49\":1}}],[\"使用objdump\",{\"1\":{\"19\":1,\"28\":1,\"52\":1,\"54\":1}}],[\"名称修饰机制也被用来防止静态变量的名字冲突\",{\"1\":{\"41\":1}}],[\"名称修饰\",{\"1\":{\"41\":1}}],[\"包括\",{\"1\":{\"84\":1}}],[\"包括函数名\",{\"1\":{\"41\":1}}],[\"包含动态链接器在解析函数地址时会使用的信息\",{\"1\":{\"80\":1}}],[\"包含一个或多个属性类似的\",{\"1\":{\"67\":1}}],[\"包含了一个函数的信息\",{\"1\":{\"41\":1}}],[\"函数在plt中的项我们称之为bar\",{\"1\":{\"80\":1}}],[\"函数正在的名字叫做\",{\"1\":{\"80\":1}}],[\"函数\",{\"1\":{\"80\":1,\"84\":4}}],[\"函数时跳转到了\",{\"1\":{\"77\":1}}],[\"函数调用都可以是相对地址调用\",{\"1\":{\"77\":1}}],[\"函数进行修改\",{\"1\":{\"73\":1}}],[\"函数是一个定义在lib\",{\"1\":{\"73\":1}}],[\"函数是一个定义于静态目标模块中的函数\",{\"1\":{\"73\":1}}],[\"函数是定义在代码段之外\",{\"1\":{\"55\":1}}],[\"函数的引用进行特殊处理\",{\"1\":{\"73\":1}}],[\"函数的引用是一个静态符号还是动态符号\",{\"1\":{\"73\":1}}],[\"函数的性质\",{\"1\":{\"73\":1}}],[\"函数的地址\",{\"1\":{\"73\":1}}],[\"函数的虚拟地址应该是0x0000000000001060+x\",{\"1\":{\"50\":1}}],[\"函数的静态变量foo会被gcc编译器会将他们修饰为\",{\"1\":{\"41\":1}}],[\"函数相对于\",{\"1\":{\"50\":1}}],[\"函数里面的静态变量foo\",{\"1\":{\"41\":1}}],[\"函数签名经过修饰为\",{\"1\":{\"41\":1}}],[\"函数签名\",{\"1\":{\"41\":1}}],[\"函数名和变量名称为符号名\",{\"1\":{\"35\":1}}],[\"默认都把定义在模块内部的全局变量当作定义在其它模块的全局变量\",{\"1\":{\"78\":1}}],[\"默认情况下已经去掉了在c语言符号前加\",{\"1\":{\"40\":1}}],[\"默认值为0\",{\"1\":{\"18\":1,\"22\":1}}],[\"于是像c++增加了==命名空间\",{\"1\":{\"40\":1}}],[\"但是由于地址无关代码都是和硬件平台相关的\",{\"1\":{\"77\":1}}],[\"但是不影响我们进行分析\",{\"1\":{\"77\":1}}],[\"但是不同的是\",{\"1\":{\"77\":1}}],[\"但是当你讲bar函数修改为静态成员函数时就是书中想要的结果\",{\"1\":{\"77\":1}}],[\"但是当程序规模很大时仍然会出现明明冲突的问题\",{\"1\":{\"40\":1}}],[\"但是有一个很大的缺点是指令部分无法在多个进程之间共享\",{\"1\":{\"77\":1}}],[\"但是没有使用模块a\",{\"1\":{\"75\":1}}],[\"但是命令行中又发现lib\",{\"1\":{\"73\":1}}],[\"但是对于动态链接来说\",{\"1\":{\"73\":1}}],[\"但是对于动态链接\",{\"1\":{\"73\":1}}],[\"但是和静态链接不同的是\",{\"1\":{\"73\":1}}],[\"但是\",{\"1\":{\"67\":1,\"75\":1}}],[\"但是经过链接合并后\",{\"1\":{\"50\":1}}],[\"但是它在装载时占用地址空间\",{\"1\":{\"49\":1}}],[\"但是这样会有些问题\",{\"1\":{\"48\":1}}],[\"但是只是把elf文件中关键的段显示了出来\",{\"1\":{\"28\":1}}],[\"相当于是got中的第一项\",{\"1\":{\"77\":1}}],[\"相互不受影响\",{\"1\":{\"77\":1}}],[\"相比于静态链接\",{\"1\":{\"75\":1}}],[\"相似段合并\",{\"0\":{\"49\":1},\"1\":{\"49\":1}}],[\"相应的符号名前加上下划线\",{\"1\":{\"40\":1}}],[\"相关时这两个成员才会有意义\",{\"1\":{\"32\":1}}],[\"地址绑定发生在哪个模块\",{\"1\":{\"80\":1}}],[\"地址无关代码\",{\"0\":{\"74\":1,\"77\":1}}],[\"地址引用重定位\",{\"1\":{\"73\":1}}],[\"地址分别为0x4010和0x11a0\",{\"1\":{\"53\":1}}],[\"地址都为虚拟地址\",{\"1\":{\"40\":1}}],[\"地址和空间分配\",{\"1\":{\"13\":1}}],[\"如何使用got和plt协同工作\",{\"1\":{\"80\":1}}],[\"如何解决\",{\"1\":{\"78\":1}}],[\"如图\",{\"1\":{\"77\":1}}],[\"如果按照通常的做法应该时通过got中相应的项进行间接跳转\",{\"1\":{\"80\":1}}],[\"如果没有用到则不进行绑定\",{\"1\":{\"80\":1}}],[\"如果没有找到该符号的定义\",{\"1\":{\"44\":1}}],[\"如果一开始就把所有函数都链接好实际上是一种浪费\",{\"1\":{\"80\":1}}],[\"如果一个符号在所有目标文件中都是弱符号\",{\"1\":{\"43\":1}}],[\"如果一个符号在某个文件中是强符号\",{\"1\":{\"43\":1}}],[\"如果发现该共享对象有这样的重定位入口\",{\"1\":{\"79\":1}}],[\"如果数据段中有绝对地址引用\",{\"1\":{\"79\":1}}],[\"如果module\",{\"1\":{\"78\":1}}],[\"如果该全局变量在程序主模块中没有副本\",{\"1\":{\"78\":1}}],[\"如果该符号未被定义\",{\"1\":{\"44\":1}}],[\"如果该符号有定义\",{\"1\":{\"44\":1}}],[\"如果变量在共享模块中被初始化\",{\"1\":{\"78\":1}}],[\"如果同一个变量同时存在于多个位置中\",{\"1\":{\"78\":1}}],[\"如果应用程序在链接时已经绑定了这些地址\",{\"1\":{\"75\":1}}],[\"如果某个共享对象里有这样一段代码\",{\"1\":{\"79\":1}}],[\"如果某个全局变量在可执行文件中拥有副本\",{\"1\":{\"78\":1}}],[\"如果某个模块被多个程序使用\",{\"1\":{\"75\":1}}],[\"如果某个存档文件成员m\",{\"1\":{\"55\":1}}],[\"如果不同的模块目标装载地址都一样是不行的\",{\"1\":{\"75\":1}}],[\"如果foobar\",{\"1\":{\"73\":2}}],[\"如果f是一个存档文件\",{\"1\":{\"55\":1}}],[\"如果f是一个目标文件\",{\"1\":{\"55\":1}}],[\"如果p\",{\"1\":{\"67\":1}}],[\"如果将它们合并成一起映射的话只需要两个页面\",{\"1\":{\"67\":1}}],[\"如果链接过程中有弱符号大于强符号所使用的内存大小\",{\"1\":{\"57\":1}}],[\"如果其中有一个符号为强符号时\",{\"1\":{\"57\":1}}],[\"如果当链接器完成对命令行上输入文件的扫描后\",{\"1\":{\"55\":1}}],[\"如果有要重定位的地方\",{\"1\":{\"54\":1}}],[\"如果每个段都分别有\",{\"1\":{\"48\":1}}],[\"如果出现多个强符号定义\",{\"1\":{\"43\":1}}],[\"如果是符号的定义并且该符号不是\",{\"1\":{\"39\":1}}],[\"如果这个符号是一个函数或变量的定义\",{\"1\":{\"39\":1}}],[\"如果符号是\",{\"1\":{\"39\":1}}],[\"如果符号不是定义在本目标文件中\",{\"1\":{\"38\":1}}],[\"如果符号定义在本目标文件中\",{\"1\":{\"38\":1}}],[\"如hello文件\",{\"1\":{\"10\":1}}],[\"高28位表示符号绑定信息\",{\"1\":{\"37\":1}}],[\"低4位表示符号类型\",{\"1\":{\"37\":1}}],[\"行号信息\",{\"1\":{\"35\":1}}],[\"局部符号\",{\"1\":{\"35\":1}}],[\"由它完成所有的动态链接工作后再把控制权交给program1\",{\"1\":{\"73\":1}}],[\"由于动态链接下\",{\"1\":{\"84\":1}}],[\"由于可执行文件在运行时并不进行代码重定位\",{\"1\":{\"78\":1}}],[\"由于程序主模块的代码并不是地址无关代码\",{\"1\":{\"78\":1}}],[\"由于got本身是放在数据段的\",{\"1\":{\"77\":1}}],[\"由于global重复定义链接时将会出现重定义错误\",{\"1\":{\"43\":1}}],[\"由于装载时重定位的方法需要修改指令\",{\"1\":{\"76\":1}}],[\"由于虚拟存储的也映射都是以页为单位\",{\"1\":{\"64\":1}}],[\"由于此时还并没有进行链接\",{\"1\":{\"52\":1}}],[\"由于编译目标文件b时无法确认var的目标地址\",{\"1\":{\"14\":1}}],[\"由编译器生成\",{\"1\":{\"35\":1}}],[\"也可以使用readelf查看\",{\"1\":{\"82\":1}}],[\"也可能引用其它目标文件的符号\",{\"1\":{\"55\":1}}],[\"也不是由环境参数决定\",{\"1\":{\"82\":1}}],[\"也被称为全局偏移表\",{\"1\":{\"77\":1}}],[\"也被称为符号引用\",{\"1\":{\"35\":1}}],[\"也会受到限制\",{\"1\":{\"75\":1}}],[\"也会有一个叫\",{\"1\":{\"54\":1}}],[\"也将\",{\"1\":{\"49\":1}}],[\"也就是类型四\",{\"1\":{\"78\":1}}],[\"也就是说代码不会使用这种pic机制\",{\"1\":{\"78\":1}}],[\"也就是说它是一个重定位表\",{\"1\":{\"33\":1}}],[\"也就是got中偏移0\",{\"1\":{\"77\":1}}],[\"也就是所映射之后在进程虚拟内存中只有一个相对应的vma\",{\"1\":{\"67\":1}}],[\"也就是4096字节\",{\"1\":{\"48\":1}}],[\"却没有在本文件中定义\",{\"1\":{\"35\":1}}],[\"除了地址冲突外\",{\"1\":{\"75\":1}}],[\"除了文件类型与普通程序不同之外\",{\"1\":{\"73\":1}}],[\"除了可执行文件之外\",{\"1\":{\"73\":1}}],[\"除了\",{\"1\":{\"55\":1}}],[\"除了函数和变量外\",{\"1\":{\"35\":1}}],[\"除此之外每个描述符对应一个段\",{\"1\":{\"28\":1}}],[\"叫做符号值\",{\"1\":{\"35\":1}}],[\"每8字节一项\",{\"1\":{\"77\":1}}],[\"每一个被重定位的地方叫一个重定位入口\",{\"1\":{\"54\":1}}],[\"每一个目标文件都有一个相应的符号表\",{\"1\":{\"35\":1}}],[\"每个段的属性\",{\"1\":{\"86\":1}}],[\"每个条目都有一个相匹配的plt条目\",{\"1\":{\"80\":1}}],[\"每个条目都负责调用一个具体的函数\",{\"1\":{\"80\":1}}],[\"每个被可执行程序调用的库函数都有它自己的plt条目\",{\"1\":{\"80\":1}}],[\"每个外部函数在plt中都有一个相应的项\",{\"1\":{\"80\":1}}],[\"每个重定位入口都是对一个符号的引用\",{\"1\":{\"55\":1}}],[\"每个目标文件都可能定义一些符号\",{\"1\":{\"55\":1}}],[\"每个名字前是名字字符串长度\",{\"1\":{\"41\":1}}],[\"每个符号都有一个对应的值\",{\"1\":{\"39\":1}}],[\"每个定义的符号都有一个对应的值\",{\"1\":{\"35\":1}}],[\"每个elf64\",{\"1\":{\"28\":1}}],[\"每个要修正的地方叫一个\",{\"1\":{\"14\":1}}],[\"这时\",{\"1\":{\"81\":1}}],[\"这时候就需要调用动态链接器中的某个函数来完成地址绑定工作\",{\"1\":{\"80\":1}}],[\"这时候链接器必须确定foobar\",{\"1\":{\"73\":1}}],[\"这时候连接器就会查找所有输入目标文件的符号表组成的全局符号表\",{\"1\":{\"55\":1}}],[\"这在程序实际运行过程中肯定是不可行的\",{\"1\":{\"78\":1}}],[\"这是addvec的plt条目\",{\"1\":{\"80\":1}}],[\"这是对模块间调用\",{\"1\":{\"77\":1}}],[\"这是原书可出的可能会和实际不同\",{\"1\":{\"77\":1}}],[\"这是一个引用\",{\"1\":{\"43\":1}}],[\"这些信息往往由操作系统传递给动态链接器\",{\"1\":{\"86\":1}}],[\"这些步骤和静态链接情况下的装载基本无异\",{\"1\":{\"81\":1}}],[\"这些其它模块的全局变量的地址是和模块装载地址相关的\",{\"1\":{\"77\":1}}],[\"这些映射关系可以等到页错误时再进行映射\",{\"1\":{\"64\":1}}],[\"这将会使得管理这些模块的地址将是一件无比繁琐的事情\",{\"1\":{\"75\":1}}],[\"这其实就是我们要用到lib\",{\"1\":{\"73\":1}}],[\"这就是动态链接\",{\"1\":{\"72\":1}}],[\"这就是传统意义的\",{\"1\":{\"64\":1}}],[\"这部分\",{\"1\":{\"67\":1}}],[\"这样该变量在运行时实际上最终只有一个实例\",{\"1\":{\"78\":1}}],[\"这样指令部分就可以保持不变\",{\"1\":{\"77\":1}}],[\"这样就失去了动态链接节省内存的一大优势\",{\"1\":{\"77\":1}}],[\"这样c和原先的模块a的目标地址就冲突了\",{\"1\":{\"75\":1}}],[\"这样链接器就可以堆foobar\",{\"1\":{\"73\":1}}],[\"这样做的好处是进程中的某一段区域就是整个elf文件的映射\",{\"1\":{\"69\":1}}],[\"这样做的好处是可以明显减少页面内部内存碎片\",{\"1\":{\"67\":1}}],[\"这样程序才得以正确运行\",{\"1\":{\"64\":1}}],[\"这样的解析通常会伴随一个顺序问题\",{\"1\":{\"55\":1}}],[\"这样的段\",{\"1\":{\"49\":1}}],[\"这一步所做的是虚拟空间与可执行文件的映射关系\",{\"1\":{\"64\":1}}],[\"这一步中映射的是虚拟空间到实际物理内存的映射关系\",{\"1\":{\"64\":1}}],[\"这一步连接器将能够获得所有输入目标文件的段长度\",{\"1\":{\"49\":1}}],[\"这两个参数的值在我们的列子中分别为liba\",{\"1\":{\"80\":1}}],[\"这两个段分别映射的话要占用三个页面\",{\"1\":{\"67\":1}}],[\"这两个概念同样适用于变量\",{\"1\":{\"35\":1}}],[\"这两种重定位类型支持x86\",{\"1\":{\"56\":1}}],[\"这里是链接成可执行文件ab后在可执行文件ab中的偏移量\",{\"1\":{\"50\":1}}],[\"这会导致大量的内存碎片\",{\"1\":{\"48\":1}}],[\"这种类型的重定位实际上就是基址重置\",{\"1\":{\"85\":1}}],[\"这种方法使用了一些精巧的指令序列来完成\",{\"1\":{\"80\":1}}],[\"这种方案就是地址无关代码\",{\"1\":{\"77\":1}}],[\"这种情况是最简单的\",{\"1\":{\"77\":1}}],[\"这种做法就叫做静态共享库\",{\"1\":{\"75\":1}}],[\"这种做法是很浪费内存空间的\",{\"1\":{\"48\":1}}],[\"这种映射情况下对于一个物理页来说可能同时包含多个段\",{\"1\":{\"69\":1}}],[\"这种映射关系只是保存在操作系统内部的一个数据结构\",{\"1\":{\"64\":1}}],[\"这种vma叫做匿名虚拟内存区域\",{\"1\":{\"68\":1}}],[\"这种未定义的符号都是该目标文件的重定位项\",{\"1\":{\"55\":1}}],[\"这种被称为强引用\",{\"1\":{\"44\":1}}],[\"这个段保存了动态链接所需要的基本信息\",{\"1\":{\"83\":1}}],[\"这个字符串就是可执行文件所需要的动态链接器的路径\",{\"1\":{\"82\":1}}],[\"这个间接跳转只是简单的把控制传送回plt\",{\"1\":{\"80\":1}}],[\"这个重定位表里面里面包含了\",{\"1\":{\"79\":1}}],[\"这个在elf中被称为不同的视图\",{\"1\":{\"67\":1}}],[\"这个可执行文件共有10个segment\",{\"1\":{\"67\":1}}],[\"这个小的辅助代码就是所谓的覆盖管理器\",{\"1\":{\"61\":1}}],[\"这个集合中的文件会被合并起来形成可执行文件\",{\"1\":{\"55\":1}}],[\"这个相互衔接的过程实际上是目标文件之间对地址的引用\",{\"1\":{\"35\":1}}],[\"这个地址修正的过程也被叫做\",{\"1\":{\"14\":1}}],[\"了foobar\",{\"1\":{\"84\":2}}],[\"了\",{\"1\":{\"67\":1}}],[\"了解本小节将有助于帮助理解链接过程中为什么会出现重复定义的问题\",{\"1\":{\"43\":1}}],[\"了目标文件a中的函数\",{\"1\":{\"35\":1}}],[\"了函数\",{\"1\":{\"35\":1}}],[\"称目标文件b引用\",{\"1\":{\"35\":1}}],[\"然后根据当前的环境参数\",{\"1\":{\"81\":1}}],[\"然后根据got中变量所对应的项找到变量的目标地址\",{\"1\":{\"77\":1}}],[\"然后程序开始执行\",{\"1\":{\"81\":1}}],[\"然后从头部中的\",{\"1\":{\"81\":1}}],[\"然后通过got\",{\"1\":{\"80\":1}}],[\"然后进行符号查找地址重定位等工作\",{\"1\":{\"80\":1}}],[\"然后再进行间接跳转\",{\"1\":{\"80\":1}}],[\"然后间接寻址\",{\"1\":{\"80\":1}}],[\"然后我们根据变量地址在got中的偏移量就可以得到变量的地址\",{\"1\":{\"77\":1}}],[\"然后填充got中的各个项\",{\"1\":{\"77\":1}}],[\"然后把控制权返还给进程\",{\"1\":{\"65\":1}}],[\"然后在物理内存中分配一个物理页面\",{\"1\":{\"65\":1}}],[\"然后将该物理页分别映射两次\",{\"1\":{\"69\":1}}],[\"然后将该\",{\"1\":{\"64\":1}}],[\"然后编写一个小的辅助代码工具来管理这些模块何时应该驻留内存何时应该被替换掉\",{\"1\":{\"61\":1}}],[\"然后是各个名称空间和类的名字\",{\"1\":{\"41\":1}}],[\"然后使用字符串在表中的偏移来引用字符串\",{\"1\":{\"34\":1}}],[\"然后安装需要将他们\",{\"1\":{\"12\":1}}],[\"变量p在装载时需要加上一个装载地址a\",{\"1\":{\"85\":1}}],[\"变量名等\",{\"1\":{\"34\":1}}],[\"变量var的地址确认为0x1000\",{\"1\":{\"14\":1}}],[\"表示代码段的重定位表\",{\"1\":{\"85\":1}}],[\"表示生成位置无关代码\",{\"1\":{\"73\":1}}],[\"表示产生共享对象\",{\"1\":{\"73\":1}}],[\"表示vma对应的segment在可执行文件中的偏移\",{\"1\":{\"68\":1}}],[\"表示共享\",{\"1\":{\"68\":1}}],[\"表示私有\",{\"1\":{\"68\":1}}],[\"表示可执行\",{\"1\":{\"68\":1}}],[\"表示可写\",{\"1\":{\"68\":1}}],[\"表示可读\",{\"1\":{\"68\":1}}],[\"表示该入口在要被重定位段中的位置\",{\"1\":{\"54\":1}}],[\"表示它作用于那个段\",{\"1\":{\"33\":1}}],[\"表示符号表的下标\",{\"1\":{\"33\":1}}],[\"一旦共享对象被装载到地址a\",{\"1\":{\"85\":1}}],[\"一旦模块装载地址确定\",{\"1\":{\"76\":1}}],[\"一旦变更\",{\"1\":{\"75\":1}}],[\"一旦该可执行文件被装载\",{\"1\":{\"64\":1}}],[\"一份seg0\",{\"1\":{\"69\":1}}],[\"一些类型的重定位要使用它对被修改引用的值做偏移调整\",{\"1\":{\"56\":1}}],[\"一个以地址无关方式编译的可执行文件被称为地址无关可执行文件\",{\"1\":{\"77\":1}}],[\"一个\",{\"1\":{\"67\":1}}],[\"一个pc相对地址就是距程序计数器\",{\"1\":{\"56\":1}}],[\"一个未解析的符号集合u\",{\"1\":{\"55\":1}}],[\"一个重定位表同时也是elf的一个段\",{\"1\":{\"33\":1}}],[\"一书中也有讲解\",{\"1\":{\"43\":1}}],[\"一般叫做外部符号\",{\"1\":{\"35\":1}}],[\"一种常见的做法是把字符串集中起来存放到一个表\",{\"1\":{\"34\":1}}],[\"一组目标文件\",{\"1\":{\"15\":1}}],[\"是对函数引用的修正\",{\"1\":{\"85\":1}}],[\"是数据段的重定位表\",{\"1\":{\"85\":1}}],[\"是lib\",{\"1\":{\"84\":1}}],[\"是program1的\",{\"1\":{\"84\":1}}],[\"是动态链接器在ld\",{\"1\":{\"80\":1}}],[\"是一个数组\",{\"1\":{\"80\":2}}],[\"是一个定义在动态共享对象中的函数\",{\"1\":{\"73\":1}}],[\"是从不同角度来划分同一个elf文件\",{\"1\":{\"67\":1}}],[\"是\",{\"1\":{\"33\":1,\"82\":1}}],[\"是否动态链接\",{\"1\":{\"18\":1}}],[\"是否静态链接\",{\"1\":{\"18\":1}}],[\"是否可执行等\",{\"1\":{\"31\":1}}],[\"是否可执行\",{\"1\":{\"18\":1}}],[\"为访问变量b\",{\"1\":{\"77\":1}}],[\"为那些已知的模块预留足够的空间\",{\"1\":{\"75\":1}}],[\"为了加快符号的查找过程\",{\"1\":{\"84\":1}}],[\"为了完成动态链接\",{\"1\":{\"84\":1}}],[\"为了能够使得链接过程正常进行\",{\"1\":{\"78\":1}}],[\"为了解决这个模块装载地址固定的问题\",{\"1\":{\"75\":1}}],[\"为了解决这个问题unix系统让那些各个段接壤部分共享一个物理页\",{\"1\":{\"69\":1}}],[\"为了实现动态链接\",{\"1\":{\"75\":1}}],[\"为\",{\"1\":{\"33\":1}}],[\"为1032\",{\"1\":{\"29\":1}}],[\"决定了该段在进程虚拟地址空间中的属性\",{\"1\":{\"31\":1}}],[\"之所以+0x04是因为内存对齐的原因\",{\"1\":{\"29\":1}}],[\"的地址为0x000008801234\",{\"1\":{\"85\":1}}],[\"的地址\",{\"1\":{\"83\":3,\"85\":2}}],[\"的地址也已经确定了\",{\"1\":{\"50\":1}}],[\"的缩写\",{\"1\":{\"82\":1}}],[\"的虚拟地址\",{\"1\":{\"81\":1}}],[\"的间接跳转会将控制直接转移到addvec\",{\"1\":{\"80\":1}}],[\"的方法来实现\",{\"1\":{\"80\":1}}],[\"的做法\",{\"1\":{\"80\":1}}],[\"的反汇编代码\",{\"1\":{\"77\":1}}],[\"的基本思想\",{\"1\":{\"72\":1}}],[\"的p\",{\"1\":{\"67\":1}}],[\"的部分则全部填充为\",{\"1\":{\"67\":1}}],[\"的信息\",{\"1\":{\"67\":1}}],[\"的角度来看就是执行视图\",{\"1\":{\"67\":1}}],[\"的角度来看elf文件就是链接视图\",{\"1\":{\"67\":1}}],[\"的结构叫程序头\",{\"1\":{\"67\":1}}],[\"的当前运行时值的偏移量\",{\"1\":{\"56\":1}}],[\"的\",{\"1\":{\"50\":2,\"55\":1}}],[\"的大括号内部的代码当作c语言代码处理\",{\"1\":{\"42\":1}}],[\"的工具来解析被修饰的名称\",{\"1\":{\"41\":1}}],[\"的这种方式\",{\"1\":{\"40\":1}}],[\"的重定位表\",{\"1\":{\"33\":1}}],[\"的段保存了代码段的重定位表\",{\"1\":{\"54\":1}}],[\"的段\",{\"1\":{\"33\":1,\"54\":1}}],[\"的偏移量为0x390文件大小为0x74\",{\"1\":{\"29\":1}}],[\"的包\",{\"1\":{\"15\":1}}],[\"字母就是\",{\"1\":{\"41\":1}}],[\"字节\",{\"1\":{\"29\":1}}],[\"字符串表\",{\"0\":{\"34\":1},\"1\":{\"34\":1}}],[\"字符串结尾包含字符串结束符\",{\"1\":{\"21\":1}}],[\"字符串字面量\",{\"1\":{\"21\":1}}],[\"数组元素个数为段个数\",{\"1\":{\"28\":1}}],[\"数据vam\",{\"1\":{\"68\":1}}],[\"数据段地址无关性\",{\"0\":{\"79\":1}}],[\"数据段结束地址\",{\"1\":{\"40\":1}}],[\"数据段和只读数据段\",{\"0\":{\"21\":1}}],[\"数据段和bss段\",{\"1\":{\"19\":1}}],[\"数据存储方式\",{\"1\":{\"25\":1}}],[\"when\",{\"1\":{\"86\":2}}],[\"while\",{\"1\":{\"67\":1}}],[\"we\",{\"1\":{\"86\":6}}],[\"weakref\",{\"1\":{\"44\":3}}],[\"weak2\",{\"1\":{\"43\":1}}],[\"weak\",{\"1\":{\"43\":4,\"44\":2,\"84\":4}}],[\"wimplicit\",{\"1\":{\"55\":1}}],[\"write\",{\"1\":{\"28\":1,\"67\":1,\"68\":1}}],[\"w\",{\"1\":{\"28\":1,\"58\":1,\"67\":1,\"68\":1}}],[\"wat\",{\"1\":{\"67\":2}}],[\"warning\",{\"1\":{\"55\":3,\"57\":1}}],[\"wa\",{\"1\":{\"28\":2,\"67\":7,\"77\":1,\"85\":3}}],[\"work\",{\"1\":{\"86\":2}}],[\"worker\",{\"1\":{\"68\":5,\"73\":10}}],[\"word\",{\"1\":{\"25\":2,\"29\":4,\"36\":1,\"67\":2,\"83\":1}}],[\"world\",{\"1\":{\"6\":2,\"82\":1}}],[\"机器类型\",{\"0\":{\"27\":1},\"1\":{\"27\":1}}],[\"程序的入口地址等\",{\"1\":{\"86\":1}}],[\"程序开始正式执行\",{\"1\":{\"81\":1}}],[\"程序调用进入plt\",{\"1\":{\"80\":1}}],[\"程序模块之间包含了大量的函数引用\",{\"1\":{\"80\":1}}],[\"程序首先计算出变量b的地址在got中的位置\",{\"1\":{\"77\":1}}],[\"程序会先找到got\",{\"1\":{\"77\":1}}],[\"程序与动态库之间真正的链接工作是由动态链接器完成的\",{\"1\":{\"72\":1}}],[\"程序头表也是一个结构体数组\",{\"1\":{\"67\":1}}],[\"程序员在编写程序时必须手工将程序分割成若干块\",{\"1\":{\"61\":1}}],[\"程序结束地址\",{\"1\":{\"40\":1}}],[\"程序起始地址\",{\"1\":{\"40\":1}}],[\"程序入口和长度\",{\"1\":{\"25\":1}}],[\"程序构建的核心\",{\"1\":{\"8\":1}}],[\"硬件平台版本\",{\"1\":{\"25\":1}}],[\"硬件平台\",{\"1\":{\"25\":1}}],[\"运行时引用符号地址\",{\"1\":{\"56\":1}}],[\"运行时引用符号的地址\",{\"1\":{\"56\":1}}],[\"运行时库\",{\"1\":{\"15\":1}}],[\"运行平台\",{\"1\":{\"25\":1}}],[\"版本\",{\"1\":{\"25\":1}}],[\"文件地址和属性\",{\"1\":{\"81\":1}}],[\"文件类型\",{\"0\":{\"26\":1},\"1\":{\"26\":1}}],[\"文件机器字节长度\",{\"1\":{\"25\":1}}],[\"文件头同时包括一个段表\",{\"1\":{\"18\":1}}],[\"文件头\",{\"0\":{\"25\":1},\"1\":{\"18\":1}}],[\"在linux中\",{\"1\":{\"82\":1}}],[\"在linux下\",{\"1\":{\"81\":1}}],[\"在静态链接情况下\",{\"1\":{\"81\":1}}],[\"在静态链接中就相当于普通函数的定义和引用\",{\"1\":{\"84\":1}}],[\"在静态链接中\",{\"1\":{\"73\":1,\"85\":1}}],[\"在把addvec的id\",{\"1\":{\"80\":1}}],[\"在第一次调用addvec时\",{\"1\":{\"80\":1}}],[\"在第一步的扫描和空间分配阶段\",{\"1\":{\"50\":1}}],[\"在这里就是动态符号字符串表\",{\"1\":{\"84\":1}}],[\"在这个过程中间又增加了一层间接跳转\",{\"1\":{\"80\":1}}],[\"在这种情况下\",{\"1\":{\"69\":1}}],[\"在glibc中\",{\"1\":{\"80\":1}}],[\"在一个程序运行过程中\",{\"1\":{\"80\":1}}],[\"在动态链接下\",{\"1\":{\"80\":1}}],[\"在动态链接的elf可执行文件中\",{\"1\":{\"82\":1}}],[\"在动态链接的实现中会提到\",{\"1\":{\"77\":1}}],[\"在动态链接的情况下\",{\"1\":{\"75\":1}}],[\"在它的\",{\"1\":{\"78\":1}}],[\"在某些平台上会有一些限制\",{\"1\":{\"77\":1}}],[\"在编译时\",{\"1\":{\"85\":1}}],[\"在编译时可以只使用\",{\"1\":{\"76\":1}}],[\"在编译器及连接器处理符号时\",{\"1\":{\"41\":1}}],[\"在系统开始运行program1之前\",{\"1\":{\"73\":1}}],[\"在内存中所分配的空间大小超过文件中实际的大小\",{\"1\":{\"67\":1}}],[\"在32为的intel\",{\"1\":{\"64\":1}}],[\"在处理弱引用时\",{\"1\":{\"44\":1}}],[\"在其它文件为弱符号\",{\"1\":{\"43\":1}}],[\"在名称空间或在类里面的\",{\"1\":{\"41\":1}}],[\"在可执行文件中\",{\"1\":{\"39\":1}}],[\"在目标文件中\",{\"1\":{\"39\":2}}],[\"在本文件中引用的全局符号\",{\"1\":{\"35\":1}}],[\"在链接时\",{\"1\":{\"76\":1}}],[\"在链接中将函数和变量称为符号\",{\"1\":{\"35\":1}}],[\"在链接过程中\",{\"1\":{\"14\":1}}],[\"在simplesection\",{\"1\":{\"33\":1}}],[\"在文件中的偏移\",{\"1\":{\"24\":1}}],[\"该模型假设可执行目标文件中的代码和数据的总体大小小于2gb\",{\"1\":{\"56\":1}}],[\"该重定位表作用的elf文件中的那个段relocation\",{\"1\":{\"54\":1}}],[\"该表记录了目标文件中所用的所有符号\",{\"1\":{\"35\":1}}],[\"该表描述了elf文件包含的所有段的信息\",{\"1\":{\"24\":1}}],[\"该段在文件中存在\",{\"1\":{\"19\":1}}],[\"其地址需要在运行是被解析\",{\"1\":{\"80\":1}}],[\"其余的每个条目对应于一个被调用的函数\",{\"1\":{\"80\":1}}],[\"其基本思想是当函数第一次被用到时才进行绑定\",{\"1\":{\"80\":1}}],[\"其实可执行文件的真正指令和数据都没有被装入到内存中\",{\"1\":{\"65\":1}}],[\"其中每个条目时8字节地址\",{\"1\":{\"80\":1}}],[\"其中每个条目时16字节代码\",{\"1\":{\"80\":1}}],[\"其中每个重定位表包含了一下信息\",{\"1\":{\"54\":1}}],[\"其中elf文件中与段有关的重要结构就是段表\",{\"1\":{\"24\":1}}],[\"其它几乎与普通程序一样\",{\"1\":{\"73\":1}}],[\"其它几个\",{\"1\":{\"55\":1}}],[\"其它的页都按照正常的页进行映射\",{\"1\":{\"69\":1}}],[\"其它类型的都是装载时起辅助作用\",{\"1\":{\"67\":1}}],[\"其它段\",{\"0\":{\"23\":1},\"1\":{\"23\":1}}],[\"其它\",{\"0\":{\"15\":1}}],[\"仅接着是elf各个段\",{\"1\":{\"24\":1}}],[\"它将开始做链接工作\",{\"1\":{\"86\":1}}],[\"它可能会包含绝对地址引用\",{\"1\":{\"85\":1}}],[\"它实际上位于\",{\"1\":{\"85\":1}}],[\"它所修正的位置位于\",{\"1\":{\"85\":2}}],[\"它所在的类和名称空间及其它信息\",{\"1\":{\"41\":1}}],[\"它初始化执行环境\",{\"1\":{\"80\":1}}],[\"它跳转到动态链接库中\",{\"1\":{\"80\":1}}],[\"它指向变量a\",{\"1\":{\"79\":1}}],[\"它引用这个全局变量的方式和普通数据访问方式一样\",{\"1\":{\"78\":1}}],[\"它位于0x3fc0\",{\"1\":{\"77\":1}}],[\"它们都是被操作系统用同样的方法映射至进程的虚拟地址空间\",{\"1\":{\"73\":1}}],[\"它们包含的分别是程序的可执行代码和初始化代码\",{\"1\":{\"67\":1}}],[\"它们在文件中和虚拟地址都要分配空间\",{\"1\":{\"49\":1}}],[\"它只关心一些和装载相关的问题\",{\"1\":{\"67\":1}}],[\"它对应elf文件中偏移为0的\",{\"1\":{\"64\":1}}],[\"它在每个进程都有一份独立的副本\",{\"1\":{\"79\":1}}],[\"它在虚拟空间中的地址为0x08040800~0x08049000\",{\"1\":{\"64\":1}}],[\"它在文件中的大小为0x000e1\",{\"1\":{\"64\":1}}],[\"它就将在指令中编码的32位值加上pc的当前运行时值\",{\"1\":{\"56\":1}}],[\"它会合并和重定位e中的目标文件\",{\"1\":{\"55\":1}}],[\"它的偏移为0x000000004018\",{\"1\":{\"85\":1}}],[\"它的属性为只读\",{\"1\":{\"64\":1}}],[\"它的虚拟地址为0x08048000\",{\"1\":{\"64\":1}}],[\"它的名称都是一样的\",{\"1\":{\"41\":1}}],[\"它的参数列表紧跟在\",{\"1\":{\"41\":1}}],[\"它的值就是该段的起始地址\",{\"1\":{\"35\":1}}],[\"它的\",{\"1\":{\"33\":1}}],[\"它的类型\",{\"1\":{\"33\":1}}],[\"它的类型为r\",{\"1\":{\"85\":1}}],[\"它的类型为\",{\"1\":{\"28\":1}}],[\"它包含了描述整个文件的基本属性\",{\"1\":{\"24\":1}}],[\"它是一种只读数据\",{\"1\":{\"21\":1}}],[\"符号查找\",{\"1\":{\"80\":1}}],[\"符号未定义错误\",{\"1\":{\"55\":1}}],[\"符号解析\",{\"0\":{\"55\":1}}],[\"符号解析与重定位\",{\"0\":{\"51\":1},\"1\":{\"49\":1}}],[\"符号地址的确定\",{\"0\":{\"50\":1}}],[\"符号global占8byte\",{\"1\":{\"43\":1}}],[\"符号的定义通常被称为强符号\",{\"1\":{\"43\":1}}],[\"符号修饰\",{\"0\":{\"41\":1}}],[\"符号修饰与函数签名\",{\"1\":{\"40\":1}}],[\"符号值\",{\"0\":{\"39\":1}}],[\"符号值就是它们的地址\",{\"1\":{\"35\":1}}],[\"符号所在段\",{\"0\":{\"38\":1},\"1\":{\"38\":1}}],[\"符号类型和绑定\",{\"1\":{\"37\":1}}],[\"符号类型和绑定类型\",{\"0\":{\"37\":1}}],[\"符号是链接中的粘合剂\",{\"1\":{\"35\":1}}],[\"符号表等\",{\"1\":{\"32\":1}}],[\"符号\",{\"0\":{\"35\":1},\"1\":{\"22\":1}}],[\"符号决议和重定位\",{\"1\":{\"13\":1}}],[\"96\",{\"1\":{\"77\":3}}],[\"9899\",{\"1\":{\"69\":1}}],[\"9\",{\"1\":{\"20\":1,\"22\":1,\"28\":2,\"39\":1,\"49\":1,\"67\":1}}],[\"9008018\",{\"1\":{\"40\":2}}],[\"9008010\",{\"1\":{\"40\":2}}],[\"9005205\",{\"1\":{\"40\":3}}],[\"9004000\",{\"1\":{\"40\":1}}],[\"90010000\",{\"1\":{\"20\":1}}],[\"90\",{\"1\":{\"20\":1}}],[\"90c9c3f3\",{\"1\":{\"20\":1}}],[\"<elf\",{\"1\":{\"86\":1}}],[\"<ext>\",{\"1\":{\"77\":2}}],[\"<ext\",{\"1\":{\"77\":5}}],[\"<dlfcn\",{\"1\":{\"80\":1}}],[\"<foo>\",{\"1\":{\"77\":3}}],[\"<func1+0x28>\",{\"1\":{\"20\":1}}],[\"<func1+0x1b>\",{\"1\":{\"20\":1}}],[\"<func1>\",{\"1\":{\"20\":1}}],[\"<b>\",{\"1\":{\"77\":3}}],[\"<bar>\",{\"1\":{\"77\":3}}],[\"<bar+0x2ecf>\",{\"1\":{\"77\":1,\"80\":1}}],[\"<bar\",{\"1\":{\"77\":3,\"80\":1}}],[\"<a>\",{\"1\":{\"77\":3}}],[\"<unistd\",{\"1\":{\"67\":1,\"73\":1}}],[\"<stdlib\",{\"1\":{\"80\":1}}],[\"<stdio\",{\"1\":{\"6\":1,\"40\":1,\"42\":1,\"44\":1,\"73\":2,\"80\":1,\"82\":1,\"84\":1}}],[\"<swap>\",{\"1\":{\"53\":2}}],[\"<shared>\",{\"1\":{\"53\":1}}],[\"<pthread\",{\"1\":{\"44\":1}}],[\"<main+0x4d>\",{\"1\":{\"52\":1}}],[\"<main+0x48>\",{\"1\":{\"52\":1,\"53\":1}}],[\"<main+0x31>\",{\"1\":{\"52\":2}}],[\"<main+0x32>\",{\"1\":{\"20\":1}}],[\"<main+0xf>\",{\"1\":{\"52\":1}}],[\"<main+0x1f>\",{\"1\":{\"20\":1}}],[\"<main+0x19>\",{\"1\":{\"20\":1}}],[\"<main>\",{\"1\":{\"20\":1,\"52\":1,\"53\":1}}],[\"<\",{\"1\":{\"20\":1,\"53\":1,\"80\":1}}],[\"time\",{\"1\":{\"76\":2}}],[\"tip\",{\"1\":{\"40\":1}}],[\"test|grep\",{\"1\":{\"82\":1}}],[\"test\",{\"1\":{\"82\":5,\"83\":2}}],[\"terminated\",{\"1\":{\"73\":1}}],[\"text为4097字节\",{\"1\":{\"67\":1}}],[\"textrel\",{\"1\":{\"55\":1}}],[\"text+0x39\",{\"1\":{\"55\":1}}],[\"text+0x29\",{\"1\":{\"55\":1}}],[\"text段的vma\",{\"1\":{\"64\":1}}],[\"text段对齐后实际占用的虚拟内存大小为0x1000\",{\"1\":{\"64\":1}}],[\"text段\",{\"1\":{\"48\":1}}],[\"text\",{\"1\":{\"18\":1,\"19\":2,\"20\":2,\"22\":1,\"28\":2,\"29\":1,\"33\":3,\"35\":1,\"39\":1,\"40\":2,\"49\":6,\"50\":3,\"52\":1,\"53\":1,\"54\":7,\"55\":2,\"58\":8,\"64\":2,\"67\":4,\"73\":1,\"85\":2}}],[\"tbss\",{\"1\":{\"67\":2}}],[\"tbl\",{\"1\":{\"29\":1,\"36\":1}}],[\"tdata\",{\"1\":{\"67\":4}}],[\"tmp\",{\"1\":{\"55\":2,\"57\":2}}],[\"tag类型\",{\"1\":{\"83\":1}}],[\"tag\",{\"1\":{\"49\":1,\"67\":3,\"83\":3}}],[\"table\",{\"1\":{\"22\":1,\"24\":1,\"25\":8,\"29\":1,\"34\":2,\"35\":1,\"39\":1,\"55\":1,\"67\":3,\"77\":2,\"80\":1,\"84\":5}}],[\"tls\",{\"1\":{\"28\":1,\"67\":2}}],[\"to\",{\"1\":{\"28\":1,\"29\":1,\"55\":2,\"67\":2,\"73\":1,\"86\":3}}],[\"though\",{\"1\":{\"86\":2}}],[\"that\",{\"1\":{\"86\":2}}],[\"than\",{\"1\":{\"57\":1}}],[\"them\",{\"1\":{\"86\":1}}],[\"these\",{\"1\":{\"86\":1}}],[\"the\",{\"1\":{\"86\":7}}],[\"there\",{\"1\":{\"28\":1,\"67\":2,\"73\":1,\"77\":1}}],[\"thread\",{\"1\":{\"44\":4}}],[\"this\",{\"1\":{\"25\":1,\"44\":4,\"86\":1}}],[\"types\",{\"1\":{\"86\":1}}],[\"typedef\",{\"1\":{\"25\":1,\"29\":1,\"36\":1,\"54\":1,\"56\":1,\"67\":1,\"83\":2,\"86\":2}}],[\"type\",{\"0\":{\"30\":1},\"1\":{\"22\":1,\"25\":3,\"28\":1,\"29\":2,\"30\":1,\"33\":2,\"36\":1,\"37\":1,\"39\":1,\"54\":5,\"55\":1,\"56\":3,\"67\":5,\"73\":2,\"77\":3,\"83\":3,\"84\":1,\"85\":2,\"86\":4}}],[\"t\",{\"1\":{\"20\":1,\"28\":1,\"35\":2,\"44\":2,\"58\":2,\"67\":1,\"86\":9}}],[\"认为它在elf文件中也不存在\",{\"1\":{\"19\":1}}],[\"段所指定的路径的共享对象\",{\"1\":{\"82\":1}}],[\"段所在的位置\",{\"1\":{\"19\":1}}],[\"段还有一个副本\",{\"1\":{\"78\":1}}],[\"段创建一个global变量的副本\",{\"1\":{\"78\":1}}],[\"段地址对齐\",{\"0\":{\"69\":1}}],[\"段和\",{\"1\":{\"67\":1}}],[\"段位于虚拟地址空间0x0000000000001060\",{\"1\":{\"50\":1}}],[\"段合并在一起看做是一个\",{\"1\":{\"67\":1}}],[\"段合并\",{\"1\":{\"49\":1}}],[\"段等\",{\"1\":{\"49\":1}}],[\"段\",{\"0\":{\"82\":1,\"83\":1},\"1\":{\"49\":2,\"69\":1,\"82\":1,\"83\":1}}],[\"段名叫\",{\"1\":{\"80\":1}}],[\"段名\",{\"1\":{\"35\":1}}],[\"段的地址\",{\"1\":{\"85\":1}}],[\"段的内容\",{\"1\":{\"83\":1}}],[\"段的结构\",{\"1\":{\"83\":1}}],[\"段的偏移量为x\",{\"1\":{\"50\":1}}],[\"段的起始地址为0x0000000000004000\",{\"1\":{\"50\":1}}],[\"段的起始地址为0x0000000000001060\",{\"1\":{\"50\":1}}],[\"段的装载地址和空间的对齐单位是页\",{\"1\":{\"48\":1}}],[\"段的链接信息\",{\"0\":{\"32\":1},\"1\":{\"32\":1}}],[\"段的标志位\",{\"0\":{\"31\":1},\"1\":{\"31\":1}}],[\"段的类型\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"段的长度\",{\"1\":{\"19\":1,\"24\":1}}],[\"段描述符的结构\",{\"0\":{\"29\":1}}],[\"段数量\",{\"1\":{\"25\":1}}],[\"段偏移\",{\"1\":{\"19\":1}}],[\"段表字符串表\",{\"1\":{\"34\":1}}],[\"段表的最后一个元素\",{\"1\":{\"29\":1}}],[\"段表的结构以elf64\",{\"1\":{\"28\":1}}],[\"段表结构解析\",{\"1\":{\"29\":1}}],[\"段表用于保存这些段的基本属性结构\",{\"1\":{\"28\":1}}],[\"段表用来描述一个文件中各个段的数组\",{\"1\":{\"18\":1}}],[\"段表\",{\"0\":{\"28\":1}}],[\"段表位置和长度\",{\"1\":{\"25\":1}}],[\"段表描述了文件中各个段在文件中的偏移位置及段的属性等\",{\"1\":{\"18\":1}}],[\"只保存了与动态链接相关的符号\",{\"1\":{\"84\":1}}],[\"只显示了部分数据\",{\"1\":{\"77\":1}}],[\"只是增加了一些全局函数或变量\",{\"1\":{\"75\":1}}],[\"只读\",{\"1\":{\"69\":1}}],[\"只读数据段\",{\"1\":{\"19\":1}}],[\"只在编译器内部可见\",{\"1\":{\"35\":1}}],[\"只有段的类型是与链接\",{\"1\":{\"32\":1}}],[\"只能将movq指令的目标地址置0\",{\"1\":{\"14\":1}}],[\"注意不是入口地址\",{\"1\":{\"40\":1}}],[\"注意编译时使用了\",{\"1\":{\"39\":1}}],[\"注意对于初始化为0的全局变量则不行\",{\"1\":{\"22\":1}}],[\"注释信息段\",{\"1\":{\"19\":1}}],[\"注\",{\"1\":{\"19\":1,\"24\":1,\"29\":1,\"41\":2,\"42\":1,\"43\":2,\"45\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"54\":1,\"55\":2,\"57\":1,\"58\":1,\"61\":1,\"62\":1,\"65\":1,\"67\":1,\"68\":1,\"73\":2,\"75\":1,\"77\":3,\"80\":2,\"82\":1,\"84\":1,\"86\":1}}],[\"7838362d\",{\"1\":{\"82\":1}}],[\"72\",{\"1\":{\"77\":2}}],[\"711\",{\"1\":{\"67\":1}}],[\"7c\",{\"1\":{\"52\":1,\"53\":1}}],[\"7ffe6cfeb000\",{\"1\":{\"73\":1}}],[\"7ffe6cfea000\",{\"1\":{\"73\":2}}],[\"7ffe6cfe6000\",{\"1\":{\"73\":1}}],[\"7ffe6cfc4000\",{\"1\":{\"73\":1}}],[\"7ffe6cfa3000\",{\"1\":{\"73\":1}}],[\"7ffdee9a4000\",{\"1\":{\"68\":1}}],[\"7ffdee9a3000\",{\"1\":{\"68\":2}}],[\"7ffdee99f000\",{\"1\":{\"68\":1}}],[\"7ffdee8c3000\",{\"1\":{\"68\":1}}],[\"7ffdee8a2000\",{\"1\":{\"68\":1}}],[\"7f066ed66000\",{\"1\":{\"73\":1}}],[\"7f066ed64000\",{\"1\":{\"73\":2}}],[\"7f066ed62000\",{\"1\":{\"73\":2}}],[\"7f066ed58000\",{\"1\":{\"73\":2}}],[\"7f066ed2d000\",{\"1\":{\"73\":2}}],[\"7f066ed2c000\",{\"1\":{\"73\":2}}],[\"7f066ed2a000\",{\"1\":{\"73\":2}}],[\"7f066ed29000\",{\"1\":{\"73\":2}}],[\"7f066ed28000\",{\"1\":{\"73\":2}}],[\"7f066ed27000\",{\"1\":{\"73\":2}}],[\"7f066ed26000\",{\"1\":{\"73\":2}}],[\"7f066ed25000\",{\"1\":{\"73\":1}}],[\"7f066ed1e000\",{\"1\":{\"73\":1}}],[\"7f066ed11000\",{\"1\":{\"73\":2}}],[\"7f066ed0f000\",{\"1\":{\"73\":2}}],[\"7f066ed0b000\",{\"1\":{\"73\":2}}],[\"7f066ecbc000\",{\"1\":{\"73\":2}}],[\"7f066eb34000\",{\"1\":{\"73\":2}}],[\"7f066eb0c000\",{\"1\":{\"73\":2}}],[\"7f066eb09000\",{\"1\":{\"73\":1}}],[\"7f\",{\"1\":{\"25\":1}}],[\"7d\",{\"1\":{\"20\":1}}],[\"75\",{\"1\":{\"52\":1,\"53\":1}}],[\"75342920\",{\"1\":{\"20\":1}}],[\"75203133\",{\"1\":{\"20\":1}}],[\"7\",{\"0\":{\"56\":2,\"88\":1},\"1\":{\"19\":1,\"22\":1,\"28\":1,\"39\":1,\"49\":1,\"55\":2,\"67\":1,\"80\":1,\"84\":1,\"85\":1}}],[\"xxxxxxxxxxxxxxxx为global的地址\",{\"1\":{\"78\":1}}],[\"xxxxxxxxxxxxxxxx\",{\"1\":{\"78\":1}}],[\"xp\",{\"1\":{\"68\":2,\"73\":5}}],[\"xor\",{\"1\":{\"52\":2,\"53\":2}}],[\"xword\",{\"1\":{\"29\":4,\"36\":1,\"54\":1,\"56\":1,\"67\":3,\"83\":1}}],[\"x\",{\"1\":{\"19\":1,\"20\":1,\"28\":2,\"40\":8,\"67\":2,\"68\":1,\"80\":2}}],[\"x86\",{\"1\":{\"8\":1,\"17\":3,\"19\":1,\"20\":1,\"25\":1,\"49\":3,\"52\":1,\"53\":1,\"54\":9,\"56\":4,\"58\":4,\"70\":1,\"73\":18,\"77\":1,\"79\":1,\"82\":3,\"83\":2,\"85\":14}}],[\"+\",{\"1\":{\"19\":3,\"20\":1,\"29\":2,\"53\":2,\"54\":3,\"56\":5,\"73\":1,\"77\":7,\"85\":7}}],[\"avoid\",{\"1\":{\"86\":1}}],[\"auxv\",{\"1\":{\"86\":3}}],[\"auxiliary\",{\"1\":{\"86\":2}}],[\"a内存地址进行了一次内存对齐\",{\"1\":{\"77\":1}}],[\"am\",{\"1\":{\"67\":1}}],[\"ai\",{\"1\":{\"67\":1}}],[\"a先于foo\",{\"1\":{\"55\":1}}],[\"against\",{\"1\":{\"55\":1}}],[\"a3\",{\"1\":{\"53\":1}}],[\"a1\",{\"1\":{\"53\":2}}],[\"an\",{\"1\":{\"86\":2}}],[\"anonymous\",{\"1\":{\"68\":1}}],[\"another\",{\"1\":{\"29\":1}}],[\"and\",{\"1\":{\"25\":1,\"36\":1,\"54\":1,\"56\":1,\"86\":3}}],[\"ax\",{\"1\":{\"28\":1,\"67\":4}}],[\"attr\",{\"1\":{\"44\":1}}],[\"attribute\",{\"1\":{\"43\":2,\"44\":4}}],[\"at\",{\"1\":{\"28\":1,\"29\":1,\"54\":2,\"67\":2,\"73\":1,\"77\":2,\"83\":1,\"85\":2}}],[\"arrangement\",{\"1\":{\"86\":1}}],[\"arraysz\",{\"1\":{\"83\":2}}],[\"array\",{\"1\":{\"49\":2,\"67\":8,\"73\":4,\"83\":2}}],[\"ar\",{\"1\":{\"58\":2}}],[\"area\",{\"1\":{\"64\":1,\"68\":1}}],[\"are\",{\"1\":{\"28\":1,\"67\":2,\"73\":1,\"77\":1,\"86\":1}}],[\"architecture\",{\"1\":{\"25\":1}}],[\"advanced\",{\"1\":{\"25\":1}}],[\"added\",{\"1\":{\"86\":2}}],[\"addend\",{\"1\":{\"54\":2,\"56\":5,\"77\":1,\"85\":2}}],[\"addvec第一次被调用时\",{\"1\":{\"80\":1}}],[\"addvec\",{\"1\":{\"80\":4}}],[\"additional\",{\"1\":{\"29\":1}}],[\"addralign\",{\"1\":{\"29\":1}}],[\"addr\",{\"1\":{\"25\":1,\"29\":3,\"36\":1,\"54\":1,\"56\":4,\"67\":2,\"83\":2}}],[\"address\",{\"1\":{\"25\":2,\"28\":1,\"54\":1,\"56\":1,\"67\":3,\"77\":1,\"83\":2}}],[\"add\",{\"1\":{\"20\":3,\"52\":1,\"53\":1,\"77\":3}}],[\"ab\",{\"1\":{\"49\":2,\"53\":2}}],[\"abi版本\",{\"1\":{\"25\":1}}],[\"abi\",{\"1\":{\"25\":2,\"49\":1,\"67\":3,\"86\":1}}],[\"abs\",{\"1\":{\"22\":1,\"39\":1,\"55\":1}}],[\"alignment\",{\"1\":{\"29\":1,\"57\":1,\"67\":1}}],[\"align\",{\"1\":{\"28\":1,\"67\":3,\"73\":1,\"77\":1}}],[\"alloc\",{\"1\":{\"19\":6,\"28\":1,\"49\":36,\"67\":1}}],[\"algn\",{\"1\":{\"19\":1,\"49\":3}}],[\"a\",{\"1\":{\"19\":2,\"28\":4,\"43\":1,\"46\":7,\"49\":2,\"50\":3,\"52\":2,\"54\":5,\"55\":22,\"58\":2,\"67\":8,\"77\":5,\"79\":2,\"85\":2,\"86\":7}}],[\"as\",{\"1\":{\"9\":1}}],[\"uint64\",{\"1\":{\"86\":2}}],[\"uint32\",{\"1\":{\"86\":2}}],[\"using\",{\"1\":{\"86\":2}}],[\"usually\",{\"1\":{\"86\":1}}],[\"usual\",{\"1\":{\"86\":1}}],[\"use\",{\"1\":{\"86\":2}}],[\"uses\",{\"1\":{\"86\":1}}],[\"used\",{\"1\":{\"86\":1}}],[\"user\",{\"1\":{\"70\":1}}],[\"usr\",{\"1\":{\"8\":1,\"25\":1,\"29\":1,\"36\":1,\"55\":4,\"57\":1,\"58\":2,\"70\":1,\"73\":12,\"86\":1}}],[\"u是非空的\",{\"1\":{\"55\":1}}],[\"un的含义\",{\"1\":{\"83\":1}}],[\"un\",{\"1\":{\"83\":2,\"86\":2}}],[\"unknown\",{\"1\":{\"28\":1,\"67\":1}}],[\"unsigned\",{\"1\":{\"25\":1,\"36\":2,\"56\":2}}],[\"union\",{\"1\":{\"83\":2,\"86\":2}}],[\"unix系统将elf的文件头也看做是系统的一个段\",{\"1\":{\"69\":1}}],[\"unix下c语言规定\",{\"1\":{\"40\":1}}],[\"unix\",{\"1\":{\"25\":1}}],[\"uninit\",{\"1\":{\"19\":1,\"22\":2,\"35\":1,\"39\":2}}],[\"undefined\",{\"1\":{\"55\":3}}],[\"underscore\",{\"1\":{\"40\":2}}],[\"und\",{\"1\":{\"22\":2,\"39\":2,\"55\":4,\"58\":2,\"84\":6}}],[\"ubuntu\",{\"1\":{\"20\":1}}],[\"u\",{\"1\":{\"20\":2,\"35\":1}}],[\"uh\",{\"1\":{\"20\":1}}],[\"8e\",{\"1\":{\"77\":1,\"80\":1}}],[\"88\",{\"1\":{\"55\":1}}],[\"8d\",{\"1\":{\"20\":1,\"52\":3,\"53\":3}}],[\"83\",{\"1\":{\"20\":2,\"52\":2,\"53\":2,\"77\":6}}],[\"83ec10c7\",{\"1\":{\"20\":1}}],[\"8602430d\",{\"1\":{\"20\":2}}],[\"8byte\",{\"1\":{\"43\":1}}],[\"8b\",{\"1\":{\"20\":5,\"52\":2,\"53\":4,\"77\":3}}],[\"8b45f801\",{\"1\":{\"20\":1}}],[\"8b050000\",{\"1\":{\"20\":1}}],[\"89\",{\"1\":{\"20\":6,\"52\":1,\"53\":1}}],[\"89c7b800\",{\"1\":{\"20\":1}}],[\"897dfc8b\",{\"1\":{\"20\":1}}],[\"8\",{\"1\":{\"19\":2,\"20\":1,\"22\":1,\"28\":7,\"39\":1,\"49\":1,\"52\":2,\"57\":1,\"67\":11,\"77\":2,\"83\":2,\"85\":4}}],[\"85\",{\"1\":{\"19\":1}}],[\"84\",{\"1\":{\"19\":1}}],[\"80386\",{\"1\":{\"17\":1}}],[\"挖掘simplesection\",{\"0\":{\"19\":1}}],[\"节省内存空间\",{\"1\":{\"18\":1}}],[\"提高cpu的缓存命中\",{\"1\":{\"18\":1}}],[\"提示\",{\"1\":{\"18\":2,\"19\":1,\"20\":1,\"21\":2,\"22\":2,\"28\":2,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":1,\"35\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":2,\"43\":1,\"44\":1}}],[\"利用缓存\",{\"1\":{\"18\":1}}],[\"记录所有为初始或者初始化为0的全局变量和静态变量的大小总和\",{\"1\":{\"18\":1}}],[\"已初始化的全局变量和局部静态变量\",{\"1\":{\"18\":1,\"21\":1}}],[\"等等\",{\"1\":{\"18\":1}}],[\"等待链接器再将目标文件a和b链接起来时再将其修正\",{\"1\":{\"14\":1}}],[\"目标操作系统\",{\"1\":{\"18\":1}}],[\"目标硬件\",{\"1\":{\"18\":1}}],[\"目标文件里面包含有专门由于表示重定位信息的重定位表\",{\"1\":{\"85\":1}}],[\"目标文件b声明符号\",{\"1\":{\"43\":1}}],[\"目标文件将信息按不同的属性进行存储\",{\"1\":{\"18\":1}}],[\"目标文件是什么样的\",{\"0\":{\"18\":1}}],[\"目标文件的格式\",{\"0\":{\"17\":1}}],[\"目标文件\",{\"0\":{\"16\":1}}],[\"入口地址\",{\"1\":{\"18\":1,\"25\":1}}],[\"源代码编译后的机器指令经常放于代码段\",{\"1\":{\"18\":1}}],[\"通常称之为节\",{\"1\":{\"18\":1}}],[\"通过got\",{\"1\":{\"80\":2}}],[\"通过got来实现变量访问\",{\"1\":{\"78\":1}}],[\"通过实际的分析发现函数的got表并不在\",{\"1\":{\"77\":1}}],[\"通过得到pc值然后加上偏移量\",{\"1\":{\"77\":1}}],[\"通过readelf查看lib\",{\"1\":{\"73\":1}}],[\"通过使用\",{\"1\":{\"44\":2}}],[\"通过使用readelf\",{\"1\":{\"25\":1}}],[\"通过使用链接器\",{\"1\":{\"10\":1}}],[\"通过file指令可以查看文件的存储格式\",{\"1\":{\"17\":1}}],[\"核心转储文件\",{\"1\":{\"17\":1}}],[\"可是在动态链接情况下\",{\"1\":{\"81\":1}}],[\"可能很多函数在程序执行完时都不会被用到\",{\"1\":{\"80\":1}}],[\"可向下扩展\",{\"1\":{\"68\":1}}],[\"可向上扩展\",{\"1\":{\"68\":1}}],[\"可写和可执行\",{\"1\":{\"67\":1}}],[\"可读可写\",{\"1\":{\"68\":1,\"69\":1}}],[\"可读可写可执行\",{\"1\":{\"68\":2}}],[\"可读可执行\",{\"1\":{\"68\":1,\"69\":1}}],[\"可读\",{\"1\":{\"67\":1}}],[\"可选\",{\"1\":{\"35\":1}}],[\"可以直接通过读写内存地址空间进行\",{\"1\":{\"69\":1}}],[\"可以把数据\",{\"1\":{\"67\":1}}],[\"可以注意到变量的类型并没有加入到修饰后的名称中去\",{\"1\":{\"41\":1}}],[\"可以通过got中的项进行间接跳转基本原理如下图\",{\"1\":{\"77\":1}}],[\"可以通过got中相对应的项间接引用\",{\"1\":{\"77\":1}}],[\"可以通过gcc编译器提供的\",{\"1\":{\"43\":1}}],[\"可以通过\",{\"1\":{\"41\":1}}],[\"可以被其它目标文件引用\",{\"1\":{\"35\":1}}],[\"可以使用readelf查看debug相关的段\",{\"1\":{\"45\":1}}],[\"可以使用readelf\",{\"1\":{\"28\":1}}],[\"可以给gcc选项加入\",{\"1\":{\"22\":1}}],[\"可以防止程序被恶意篡改\",{\"1\":{\"18\":1}}],[\"可执行文件对于很多\",{\"1\":{\"81\":1}}],[\"可执行文件与执行该可执行文件进程的虚拟空间映射关系如下\",{\"1\":{\"64\":1}}],[\"可执行文件的装载与静态链接情况基本一样\",{\"1\":{\"81\":1}}],[\"可执行文件的装载\",{\"0\":{\"59\":1}}],[\"可执行文件\",{\"1\":{\"17\":1}}],[\"可重定位文件\",{\"1\":{\"17\":1}}],[\"=>\",{\"1\":{\"83\":1}}],[\"==用来保存\",{\"1\":{\"67\":1}}],[\"==\",{\"1\":{\"56\":2,\"84\":1}}],[\"==来打开和关闭是否在c语言符号前加上\",{\"1\":{\"40\":1}}],[\"==的方法来解决多模块的符号冲突问题\",{\"1\":{\"40\":1}}],[\"=\",{\"1\":{\"19\":3,\"29\":1,\"42\":1,\"43\":4,\"46\":2,\"53\":2,\"56\":4,\"77\":7,\"78\":1,\"79\":1,\"80\":7,\"85\":2}}],[\"=595f7870a8165b3eb04c9ebda08a8ccba6f742c2\",{\"1\":{\"17\":1}}],[\"=2f77b36371c214e11670c7d9d92727e9a49f626b\",{\"1\":{\"17\":1}}],[\"does\",{\"1\":{\"86\":2}}],[\"do\",{\"1\":{\"86\":2}}],[\"don\",{\"1\":{\"86\":1}}],[\"double\",{\"1\":{\"42\":1}}],[\"dlclose\",{\"1\":{\"80\":1}}],[\"dlsym\",{\"1\":{\"80\":1}}],[\"dlerror\",{\"1\":{\"80\":3}}],[\"dlopen\",{\"1\":{\"80\":1}}],[\"dl\",{\"1\":{\"80\":1,\"85\":1}}],[\"dat\",{\"1\":{\"77\":1,\"79\":1,\"85\":5}}],[\"data段和\",{\"1\":{\"48\":1}}],[\"data段的大小正好为8个字节\",{\"1\":{\"21\":1,\"22\":1}}],[\"data\",{\"1\":{\"18\":2,\"19\":6,\"20\":1,\"21\":1,\"22\":1,\"25\":1,\"28\":1,\"35\":1,\"39\":1,\"40\":2,\"49\":30,\"50\":1,\"54\":2,\"67\":5,\"73\":1,\"85\":3}}],[\"d6\",{\"1\":{\"77\":1}}],[\"d5\",{\"1\":{\"77\":2}}],[\"directory\",{\"1\":{\"64\":1}}],[\"disassembly\",{\"1\":{\"20\":1,\"52\":1,\"53\":1,\"77\":1}}],[\"dt\",{\"1\":{\"55\":1,\"83\":13}}],[\"d查看反汇编结果\",{\"1\":{\"52\":1}}],[\"dynaminc\",{\"1\":{\"83\":1}}],[\"dynamic\",{\"0\":{\"83\":1},\"1\":{\"49\":1,\"72\":1,\"73\":4,\"81\":1,\"83\":6,\"84\":3,\"85\":1}}],[\"dynamically\",{\"1\":{\"17\":1}}],[\"dyn\",{\"1\":{\"49\":1,\"73\":2,\"77\":1,\"83\":2,\"85\":3}}],[\"dynstr\",{\"1\":{\"49\":1,\"73\":1,\"83\":1,\"84\":1}}],[\"dynsym\",{\"1\":{\"49\":1,\"73\":1,\"83\":1,\"84\":4}}],[\"d0\",{\"1\":{\"20\":1}}],[\"deregistertm\",{\"1\":{\"85\":1}}],[\"deregistert\",{\"1\":{\"84\":1}}],[\"debug\",{\"1\":{\"83\":1}}],[\"devices\",{\"1\":{\"25\":1}}],[\"definitions\",{\"1\":{\"86\":2}}],[\"definition\",{\"1\":{\"86\":1}}],[\"defined\",{\"1\":{\"86\":1}}],[\"define\",{\"1\":{\"7\":1,\"35\":1,\"73\":1}}],[\"default\",{\"1\":{\"22\":13,\"39\":13,\"55\":7,\"77\":1,\"84\":7}}],[\"declaration\",{\"1\":{\"55\":2}}],[\"decorated\",{\"1\":{\"41\":1}}],[\"decoration\",{\"1\":{\"41\":1}}],[\"dec\",{\"1\":{\"19\":1}}],[\"d\",{\"1\":{\"19\":1,\"20\":3,\"21\":1,\"28\":1,\"35\":2,\"42\":1,\"52\":1,\"53\":1,\"67\":1,\"73\":2,\"80\":2,\"83\":16,\"84\":1}}],[\"dump\",{\"1\":{\"17\":1}}],[\"platforms\",{\"1\":{\"86\":2}}],[\"plt的重定位\",{\"1\":{\"85\":1}}],[\"pltrel\",{\"1\":{\"83\":1}}],[\"pltrelsz\",{\"1\":{\"83\":1}}],[\"pltgot\",{\"1\":{\"83\":1}}],[\"plt在elf文件中以独立的段存放\",{\"1\":{\"80\":1}}],[\"plt为了实现延迟绑定\",{\"1\":{\"80\":1}}],[\"plt段中\",{\"1\":{\"77\":1}}],[\"plt32\",{\"1\":{\"54\":4}}],[\"plt>\",{\"1\":{\"53\":1,\"77\":8,\"80\":1}}],[\"plt\",{\"0\":{\"80\":1},\"1\":{\"49\":4,\"67\":6,\"73\":5,\"77\":2,\"80\":8,\"85\":7}}],[\"position\",{\"1\":{\"77\":2}}],[\"pointer\",{\"1\":{\"86\":2}}],[\"point\",{\"1\":{\"25\":2,\"67\":1,\"73\":1}}],[\"pic和pie\",{\"1\":{\"77\":1}}],[\"pic\",{\"1\":{\"77\":5}}],[\"pie\",{\"1\":{\"17\":2,\"55\":1,\"77\":1,\"83\":1}}],[\"path=\",{\"1\":{\"70\":1}}],[\"paddr\",{\"1\":{\"67\":1}}],[\"page\",{\"1\":{\"64\":1,\"65\":1}}],[\"pc值\",{\"1\":{\"77\":1}}],[\"pc值通常是下一条指令在内存中的值\",{\"1\":{\"56\":1}}],[\"pc\",{\"1\":{\"54\":1,\"56\":1}}],[\"pc32\",{\"1\":{\"54\":4,\"56\":2}}],[\"ptr表示所依赖的共享对象文件名\",{\"1\":{\"83\":1}}],[\"ptr表示\",{\"1\":{\"83\":3}}],[\"ptr\",{\"1\":{\"83\":2}}],[\"pt\",{\"1\":{\"44\":4}}],[\"pthread\",{\"1\":{\"44\":7}}],[\"phdr\",{\"1\":{\"67\":1}}],[\"physical\",{\"1\":{\"67\":1}}],[\"physaddr\",{\"1\":{\"67\":1,\"73\":1}}],[\"phnum\",{\"1\":{\"25\":1}}],[\"phentsize\",{\"1\":{\"25\":1}}],[\"phoff\",{\"1\":{\"25\":1}}],[\"push\",{\"1\":{\"20\":2}}],[\"p\",{\"1\":{\"20\":1,\"28\":1,\"67\":10,\"68\":9,\"73\":22,\"79\":1,\"85\":1}}],[\"printing\",{\"1\":{\"73\":3,\"84\":1}}],[\"printf\",{\"1\":{\"6\":1,\"19\":2,\"22\":1,\"35\":1,\"39\":1,\"40\":4,\"42\":1,\"44\":2,\"73\":2,\"80\":1,\"82\":1,\"84\":1,\"85\":4}}],[\"pr\",{\"1\":{\"28\":1,\"67\":1}}],[\"procedure\",{\"1\":{\"80\":1}}],[\"processing\",{\"1\":{\"28\":1,\"67\":1}}],[\"processor\",{\"1\":{\"25\":1,\"28\":1,\"67\":1}}],[\"proc\",{\"1\":{\"68\":1,\"73\":1}}],[\"prog\",{\"1\":{\"70\":2}}],[\"progbits\",{\"1\":{\"28\":6,\"67\":15,\"77\":1,\"85\":3}}],[\"program2\",{\"1\":{\"73\":3}}],[\"program1除了使用lib\",{\"1\":{\"73\":1}}],[\"program1\",{\"1\":{\"73\":12,\"84\":1}}],[\"program\",{\"1\":{\"25\":6,\"67\":4,\"73\":2,\"81\":1,\"82\":1,\"86\":2}}],[\"property\",{\"1\":{\"19\":1,\"20\":1,\"49\":3,\"67\":4,\"73\":4}}],[\"pragma编译指令\",{\"1\":{\"7\":1}}],[\"between\",{\"1\":{\"86\":1}}],[\"by\",{\"1\":{\"86\":1}}],[\"bytes\",{\"1\":{\"25\":6,\"29\":1,\"83\":7}}],[\"but\",{\"1\":{\"86\":1}}],[\"bu\",{\"1\":{\"67\":1}}],[\"build\",{\"1\":{\"49\":1,\"67\":2,\"73\":2}}],[\"buildid\",{\"1\":{\"17\":2}}],[\"bjdump\",{\"1\":{\"54\":1}}],[\"base\",{\"1\":{\"67\":2}}],[\"bash\",{\"1\":{\"17\":2}}],[\"bar静态函数时\",{\"1\":{\"77\":1}}],[\"bar为非静态函数时\",{\"1\":{\"77\":1}}],[\"bar\",{\"1\":{\"41\":1,\"77\":4}}],[\"b8\",{\"1\":{\"20\":2,\"77\":6}}],[\"b\",{\"1\":{\"19\":2,\"20\":1,\"35\":1,\"43\":1,\"46\":5,\"49\":2,\"77\":5}}],[\"bss段在目标文件和可执行文件中不占用文件的空间\",{\"1\":{\"49\":1}}],[\"bss段\",{\"0\":{\"22\":1},\"1\":{\"48\":1}}],[\"bss段没有表示bss段在elf文件中不存在内容\",{\"1\":{\"19\":1}}],[\"bss段只是为未初始化的全局变量和局部静态变量预留位置而已\",{\"1\":{\"18\":1}}],[\"bss\",{\"1\":{\"18\":1,\"19\":2,\"22\":2,\"28\":1,\"39\":1,\"49\":6,\"67\":2,\"73\":1,\"78\":2}}],[\"binding\",{\"1\":{\"36\":1,\"37\":1,\"80\":1}}],[\"bind\",{\"1\":{\"22\":1,\"39\":1,\"55\":1,\"77\":1,\"83\":1,\"84\":1}}],[\"bin\",{\"1\":{\"17\":2,\"55\":4,\"57\":1,\"70\":1}}],[\"bit\",{\"1\":{\"17\":3,\"86\":4}}],[\"vector\",{\"1\":{\"86\":4}}],[\"versa\",{\"1\":{\"86\":2}}],[\"versym\",{\"1\":{\"83\":1}}],[\"version\",{\"1\":{\"17\":3,\"25\":5,\"44\":4,\"49\":2,\"73\":2}}],[\"verneednum\",{\"1\":{\"83\":1}}],[\"verneed\",{\"1\":{\"83\":1}}],[\"vdso\",{\"1\":{\"68\":1,\"73\":1,\"83\":1}}],[\"vvar\",{\"1\":{\"68\":1,\"73\":1}}],[\"vprintf\",{\"1\":{\"58\":13}}],[\"vice\",{\"1\":{\"86\":2}}],[\"view\",{\"1\":{\"67\":3}}],[\"virtaddr\",{\"1\":{\"67\":1,\"73\":1}}],[\"virtual\",{\"1\":{\"25\":1,\"29\":1,\"64\":1,\"67\":1,\"68\":1}}],[\"visibility\",{\"1\":{\"36\":1}}],[\"vis\",{\"1\":{\"22\":1,\"39\":1,\"55\":1,\"77\":1,\"84\":1}}],[\"v\",{\"1\":{\"25\":1}}],[\"val表示大小\",{\"1\":{\"83\":1}}],[\"val\",{\"1\":{\"83\":2,\"86\":2}}],[\"value表示符号的虚拟地址\",{\"1\":{\"39\":1}}],[\"value表示该符号的对齐属性\",{\"1\":{\"39\":1}}],[\"value表示该符号在段中的偏移\",{\"1\":{\"39\":1}}],[\"value\",{\"0\":{\"39\":1},\"1\":{\"22\":1,\"35\":1,\"36\":2,\"39\":1,\"54\":4,\"55\":1,\"77\":2,\"83\":5,\"84\":1,\"85\":2,\"86\":2}}],[\"vaddr\",{\"1\":{\"67\":1}}],[\"vam\",{\"1\":{\"64\":1}}],[\"var和static\",{\"1\":{\"35\":1}}],[\"var2\",{\"1\":{\"19\":2,\"22\":2,\"35\":2,\"39\":1}}],[\"var\",{\"1\":{\"14\":1,\"19\":4,\"21\":2,\"22\":4,\"35\":3,\"39\":5,\"42\":4}}],[\"vma\",{\"1\":{\"19\":1,\"49\":4}}],[\"void\",{\"1\":{\"19\":1,\"44\":4,\"46\":1,\"73\":3,\"77\":6,\"80\":2,\"84\":1}}],[\"fully\",{\"1\":{\"86\":1}}],[\"func和var不会被c++的名称修饰规则修饰\",{\"1\":{\"42\":1}}],[\"func经过名称修饰后就是\",{\"1\":{\"41\":1}}],[\"function\",{\"1\":{\"41\":1,\"55\":4,\"80\":1,\"84\":2}}],[\"func\",{\"1\":{\"22\":2,\"39\":2,\"41\":8,\"42\":2,\"55\":1,\"84\":3}}],[\"func1\",{\"1\":{\"19\":2,\"22\":1,\"35\":1,\"39\":2}}],[\"fprintf\",{\"1\":{\"80\":3}}],[\"fpie\",{\"1\":{\"77\":2}}],[\"fpic的情况下\",{\"1\":{\"78\":1}}],[\"fpic和\",{\"1\":{\"77\":1}}],[\"fpic选项\",{\"1\":{\"76\":1}}],[\"fpic\",{\"1\":{\"73\":2,\"77\":7,\"84\":1}}],[\"f1\",{\"1\":{\"77\":1}}],[\"fe\",{\"1\":{\"77\":2}}],[\"from\",{\"1\":{\"73\":3}}],[\"frame\",{\"1\":{\"19\":1,\"20\":1,\"28\":2,\"49\":4,\"54\":2,\"67\":2,\"73\":4}}],[\"ff\",{\"1\":{\"53\":3,\"77\":19,\"80\":1}}],[\"fs\",{\"1\":{\"52\":2,\"53\":3}}],[\"finalize\",{\"1\":{\"85\":1}}],[\"finit\",{\"1\":{\"83\":1}}],[\"fini\",{\"1\":{\"49\":2,\"67\":6,\"73\":3,\"83\":3}}],[\"filesz\",{\"1\":{\"67\":3}}],[\"filesiz\",{\"1\":{\"67\":1,\"73\":1}}],[\"filename\",{\"1\":{\"19\":1}}],[\"file\",{\"1\":{\"17\":3,\"19\":3,\"20\":1,\"22\":1,\"25\":7,\"29\":1,\"39\":1,\"49\":6,\"52\":1,\"53\":1,\"54\":1,\"55\":1,\"58\":2,\"67\":4,\"73\":2,\"82\":1,\"86\":1}}],[\"fno\",{\"1\":{\"40\":1}}],[\"float\",{\"1\":{\"41\":2}}],[\"fleading\",{\"1\":{\"40\":1}}],[\"flags\",{\"0\":{\"31\":1},\"1\":{\"25\":3,\"28\":2,\"29\":2,\"30\":1,\"67\":5,\"73\":1,\"77\":1,\"83\":3}}],[\"f8\",{\"1\":{\"20\":2}}],[\"f\",{\"1\":{\"20\":1,\"52\":2,\"55\":1,\"58\":8,\"77\":1}}],[\"fcommon编译选项\",{\"1\":{\"39\":1}}],[\"fcommon\",{\"1\":{\"22\":1}}],[\"fcommon使未初始化的全局变量被定义为一个\",{\"1\":{\"22\":1}}],[\"fc\",{\"1\":{\"20\":3}}],[\"far\",{\"1\":{\"68\":5,\"73\":10}}],[\"fault\",{\"1\":{\"65\":1}}],[\"fail\",{\"1\":{\"53\":1,\"54\":2,\"55\":2}}],[\"fa\",{\"1\":{\"20\":2,\"52\":1,\"53\":1,\"77\":7,\"80\":1}}],[\"f3\",{\"1\":{\"20\":2,\"52\":1,\"53\":1,\"77\":7,\"80\":1}}],[\"f30f1efa\",{\"1\":{\"20\":1}}],[\"f0\",{\"1\":{\"19\":1}}],[\"found\",{\"1\":{\"89\":1}}],[\"foo\",{\"1\":{\"35\":3,\"40\":2,\"41\":1,\"44\":3,\"55\":5,\"77\":2,\"78\":1}}],[\"foobar\",{\"1\":{\"17\":2,\"73\":6,\"84\":5}}],[\"form\",{\"1\":{\"84\":1}}],[\"format\",{\"1\":{\"19\":2,\"20\":1,\"49\":3,\"52\":1,\"53\":1,\"54\":1,\"58\":2,\"82\":1}}],[\"fortran把这种空间叫common块\",{\"1\":{\"57\":1}}],[\"foreach\",{\"1\":{\"56\":2}}],[\"for\",{\"1\":{\"17\":1,\"54\":3,\"84\":1}}],[\"第五章\",{\"0\":{\"71\":1}}],[\"第五列表示可执行文件的节点号\",{\"1\":{\"68\":1}}],[\"第四列表示可执行文件所在设备的主设备号和次设备号\",{\"1\":{\"68\":1}}],[\"第四章\",{\"0\":{\"59\":1}}],[\"第三项保存的是\",{\"1\":{\"85\":1}}],[\"第三列是偏移\",{\"1\":{\"68\":1}}],[\"第三章\",{\"0\":{\"46\":1}}],[\"第二项保存的是本模块的id\",{\"1\":{\"85\":1}}],[\"第二个变量对应变量c等\",{\"1\":{\"77\":1}}],[\"第二列是vma的权限\",{\"1\":{\"68\":1}}],[\"第二章\",{\"0\":{\"16\":1}}],[\"第九章\",{\"1\":{\"62\":1}}],[\"第七章\",{\"1\":{\"55\":1}}],[\"第一项保存的是\",{\"1\":{\"85\":1}}],[\"第一条plt指令通过got\",{\"1\":{\"80\":1}}],[\"第一列是vma的地址范围\",{\"1\":{\"68\":1}}],[\"第一个元素是无效段描述符\",{\"1\":{\"28\":1}}],[\"第一章\",{\"0\":{\"5\":1}}],[\"库\",{\"1\":{\"15\":1}}],[\"支撑程序运行的基本函数集合\",{\"1\":{\"15\":1}}],[\"rpath\",{\"1\":{\"83\":1}}],[\"rtld\",{\"1\":{\"80\":1}}],[\"runtime\",{\"1\":{\"80\":1,\"85\":1}}],[\"rw\",{\"1\":{\"67\":2,\"68\":4,\"73\":12}}],[\"ro\",{\"1\":{\"67\":3}}],[\"rodata段的大小正好为四字节\",{\"1\":{\"21\":1}}],[\"rodata段\",{\"1\":{\"21\":1}}],[\"rodata\",{\"1\":{\"19\":2,\"20\":1,\"21\":1,\"22\":1,\"28\":1,\"39\":1,\"49\":1,\"67\":4,\"73\":1}}],[\"rsi\",{\"1\":{\"52\":2,\"53\":2}}],[\"rsp\",{\"1\":{\"20\":4,\"52\":6,\"53\":7,\"77\":6}}],[\"r\",{\"1\":{\"49\":1,\"54\":12,\"56\":17,\"67\":9,\"68\":7,\"73\":27,\"77\":2,\"79\":1,\"85\":13}}],[\"rdi\",{\"1\":{\"20\":1,\"52\":1,\"53\":1}}],[\"rax\",{\"1\":{\"20\":2,\"52\":4,\"53\":7,\"77\":11,\"80\":2}}],[\"rbp\",{\"1\":{\"20\":9}}],[\"rename\",{\"1\":{\"86\":1}}],[\"rebasing\",{\"1\":{\"85\":1}}],[\"registertmcl\",{\"1\":{\"85\":1}}],[\"registertmc\",{\"1\":{\"84\":1}}],[\"requesting\",{\"1\":{\"82\":1}}],[\"required\",{\"1\":{\"28\":1,\"67\":1}}],[\"resolve\",{\"1\":{\"80\":1,\"85\":1}}],[\"records\",{\"1\":{\"54\":3}}],[\"refaddr\",{\"1\":{\"56\":2}}],[\"refptr\",{\"1\":{\"56\":3}}],[\"reference\",{\"1\":{\"44\":3,\"55\":2}}],[\"refrence\",{\"1\":{\"35\":1}}],[\"relent\",{\"1\":{\"83\":1}}],[\"relro\",{\"1\":{\"67\":1,\"73\":1}}],[\"relative类型的重定位入口就是专门用来重定位指针变量p这种类型的\",{\"1\":{\"85\":1}}],[\"relative\",{\"1\":{\"85\":4}}],[\"relacount\",{\"1\":{\"83\":1}}],[\"relasz\",{\"1\":{\"83\":1}}],[\"relaent\",{\"1\":{\"83\":2}}],[\"rela\",{\"1\":{\"28\":4,\"33\":3,\"49\":2,\"54\":2,\"56\":1,\"67\":3,\"73\":2,\"77\":1,\"83\":3,\"85\":2}}],[\"rel\",{\"1\":{\"25\":1,\"33\":1,\"54\":3,\"67\":3,\"83\":1,\"85\":8}}],[\"reloc\",{\"1\":{\"19\":2,\"49\":3}}],[\"relocatable\",{\"1\":{\"17\":1,\"25\":1}}],[\"relocation\",{\"1\":{\"14\":2,\"54\":6,\"55\":1,\"56\":2,\"76\":2,\"77\":1,\"85\":2}}],[\"read\",{\"1\":{\"55\":1}}],[\"readelf指令可以查看重定位文件\",{\"1\":{\"54\":1}}],[\"readelf\",{\"1\":{\"22\":1,\"25\":1,\"28\":1,\"39\":1,\"54\":1,\"55\":1,\"67\":2,\"73\":1,\"77\":3,\"82\":1,\"83\":1,\"84\":1,\"85\":2}}],[\"readonly\",{\"1\":{\"19\":6,\"49\":31}}],[\"retain\",{\"1\":{\"67\":1}}],[\"ret\",{\"1\":{\"20\":2,\"52\":1,\"53\":1,\"77\":5}}],[\"returned\",{\"1\":{\"55\":1}}],[\"return\",{\"1\":{\"6\":1,\"19\":1,\"40\":1,\"42\":1,\"43\":1,\"46\":1,\"67\":1,\"73\":2,\"80\":1,\"82\":1,\"84\":1}}],[\"rip实际值为0x1147\",{\"1\":{\"77\":1}}],[\"rip既是对应的pc值\",{\"1\":{\"77\":1}}],[\"rip\",{\"1\":{\"14\":1,\"20\":3,\"52\":2,\"53\":2,\"77\":9,\"80\":1}}],[\"$0x8\",{\"1\":{\"77\":6}}],[\"$0x2\",{\"1\":{\"77\":2}}],[\"$0x2a\",{\"1\":{\"14\":1}}],[\"$0x64\",{\"1\":{\"52\":1,\"53\":1}}],[\"$0x18\",{\"1\":{\"52\":2,\"53\":2}}],[\"$0x1\",{\"1\":{\"20\":1,\"77\":3,\"78\":1}}],[\"$0x10\",{\"1\":{\"20\":2}}],[\"$0x0\",{\"1\":{\"20\":2,\"77\":6}}],[\"$>\",{\"1\":{\"6\":2,\"7\":2,\"8\":2,\"9\":2,\"17\":2,\"19\":2,\"20\":1,\"22\":2,\"25\":1,\"28\":1,\"35\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"44\":4,\"46\":1,\"49\":3,\"52\":1,\"53\":1,\"54\":2,\"55\":6,\"58\":2,\"67\":3,\"68\":2,\"70\":1,\"73\":7,\"77\":5,\"82\":2,\"83\":2,\"84\":1,\"85\":2}}],[\"memsz扩大\",{\"1\":{\"67\":1}}],[\"memsz大于p\",{\"1\":{\"67\":1}}],[\"memsz的值不可以小于p\",{\"1\":{\"67\":1}}],[\"memsz\",{\"1\":{\"67\":1}}],[\"memsiz\",{\"1\":{\"67\":1,\"73\":1}}],[\"memory\",{\"1\":{\"64\":1,\"67\":1,\"68\":1}}],[\"merge\",{\"1\":{\"28\":1,\"67\":1}}],[\"mcmodel=large\",{\"1\":{\"56\":1}}],[\"mcmodel=medium\",{\"1\":{\"56\":1}}],[\"module\",{\"1\":{\"80\":1}}],[\"model\",{\"1\":{\"56\":1}}],[\"movl\",{\"1\":{\"20\":1,\"52\":1,\"53\":1,\"77\":5}}],[\"mov\",{\"1\":{\"20\":13,\"52\":3,\"53\":5,\"77\":9}}],[\"movq\",{\"1\":{\"14\":2,\"78\":1}}],[\"multi\",{\"1\":{\"44\":2}}],[\"myname\",{\"1\":{\"42\":2}}],[\"mbind\",{\"1\":{\"28\":1,\"67\":1}}],[\"m\",{\"1\":{\"28\":1,\"67\":1}}],[\"ms\",{\"1\":{\"28\":1,\"67\":1}}],[\"micro\",{\"1\":{\"25\":1}}],[\"maps\",{\"1\":{\"68\":1,\"73\":1}}],[\"mapping\",{\"1\":{\"67\":1,\"73\":1}}],[\"manager\",{\"1\":{\"61\":1}}],[\"manualnamemangling\",{\"1\":{\"42\":4}}],[\"machine\",{\"1\":{\"25\":2}}],[\"magic\",{\"1\":{\"25\":2}}],[\"main\",{\"1\":{\"6\":1,\"19\":1,\"22\":1,\"35\":1,\"39\":2,\"40\":1,\"42\":1,\"43\":1,\"44\":2,\"46\":1,\"50\":3,\"55\":3,\"67\":1,\"73\":2,\"80\":2,\"82\":1,\"84\":1}}],[\"对\",{\"1\":{\"85\":2}}],[\"对应的段名就是\",{\"1\":{\"84\":1}}],[\"对应gcc选项\",{\"1\":{\"77\":1}}],[\"对比于这种导入导出函数\",{\"1\":{\"84\":1}}],[\"对所有绝对地址的引用不做重定位\",{\"1\":{\"76\":1}}],[\"对lib\",{\"1\":{\"73\":1}}],[\"对齐为0x1000\",{\"1\":{\"64\":1}}],[\"对存档文件中所有的成员目标文件都依次进行这个过程\",{\"1\":{\"55\":1}}],[\"对外部目标文件的符号引用在目标文件被最终链接成可执行文件时\",{\"1\":{\"44\":1}}],[\"对符号进行管理\",{\"1\":{\"35\":1}}],[\"对于这种绝对地址的引用\",{\"1\":{\"85\":1}}],[\"对于模块内部的符号\",{\"1\":{\"84\":1}}],[\"对于模块间的调用也要先定位got\",{\"1\":{\"80\":1}}],[\"对于模块间调用和跳转\",{\"1\":{\"77\":1}}],[\"对于共享对象来说\",{\"1\":{\"79\":1}}],[\"对于数据段来说\",{\"1\":{\"79\":1}}],[\"对于现代系统来说\",{\"1\":{\"77\":1}}],[\"对于可执行文件基本可以确定自己在进程虚拟空间中的起始位置\",{\"1\":{\"75\":1}}],[\"对于静态链接的可执行文件\",{\"1\":{\"73\":1}}],[\"对于链接器是如何知道foobar\",{\"1\":{\"73\":1}}],[\"对于一些必须要访问elf文件头的操作\",{\"1\":{\"69\":1}}],[\"对于一个函数来说\",{\"1\":{\"41\":1}}],[\"对于长度不足一页的按一页占用\",{\"1\":{\"69\":1}}],[\"对于命令行上的每个输入文件\",{\"1\":{\"55\":1}}],[\"对于\",{\"1\":{\"49\":2,\"67\":1}}],[\"对于x86的硬件来说\",{\"1\":{\"48\":1}}],[\"对于未定义的弱引用\",{\"1\":{\"44\":1}}],[\"对于int类型来说\",{\"1\":{\"41\":1}}],[\"对于嵌套的名字\",{\"1\":{\"41\":1}}],[\"对于变量和函数来说\",{\"1\":{\"35\":1}}],[\"对于每个需要重定位的段\",{\"1\":{\"33\":1}}],[\"对于编译器和链接器来说\",{\"1\":{\"30\":1}}],[\"对目标文件b有\",{\"1\":{\"14\":1}}],[\"对使用定义在其它目标文件中的变量也是如此\",{\"1\":{\"14\":1}}],[\"对定义在其它目标文件中的函数调用的指令需要被重新调整\",{\"1\":{\"14\":1}}],[\"起来的过程被称为链接\",{\"1\":{\"12\":1}}],[\"组装\",{\"1\":{\"12\":1}}],[\"lazy\",{\"1\":{\"80\":2}}],[\"large\",{\"1\":{\"28\":1,\"67\":1}}],[\"l指令查看elf文件的\",{\"1\":{\"67\":1}}],[\"lpthread\",{\"1\":{\"44\":1}}],[\"l\",{\"1\":{\"28\":2,\"67\":3,\"73\":1,\"82\":1}}],[\"local\",{\"1\":{\"22\":8,\"39\":8,\"55\":3,\"77\":1,\"84\":1}}],[\"load\",{\"1\":{\"19\":5,\"49\":33,\"67\":6,\"73\":4,\"76\":1}}],[\"leading\",{\"1\":{\"40\":1}}],[\"leave\",{\"1\":{\"20\":2}}],[\"lea\",{\"1\":{\"20\":1,\"52\":3,\"53\":3}}],[\"lma\",{\"1\":{\"19\":1,\"49\":4}}],[\"lsb\",{\"1\":{\"17\":3}}],[\"ldd\",{\"1\":{\"83\":1}}],[\"ld\",{\"1\":{\"10\":1,\"17\":3,\"55\":5,\"57\":1,\"73\":6,\"82\":2,\"83\":1}}],[\"little\",{\"1\":{\"25\":1}}],[\"linkage\",{\"1\":{\"80\":1}}],[\"linker\",{\"1\":{\"68\":5,\"73\":10,\"81\":1}}],[\"linked\",{\"1\":{\"17\":2}}],[\"linking\",{\"1\":{\"67\":1,\"72\":1}}],[\"link\",{\"0\":{\"32\":1},\"1\":{\"28\":2,\"29\":2,\"33\":1,\"67\":2,\"76\":1,\"77\":1}}],[\"linux中将进程虚拟空间中的一个段叫做虚拟内存区域\",{\"1\":{\"64\":1}}],[\"linux下的\",{\"1\":{\"17\":1}}],[\"linux下的主流文件存储格式为elf\",{\"1\":{\"17\":1}}],[\"linux的gcc编译器支持这种装载时重定位的方法\",{\"1\":{\"76\":1}}],[\"linux的\",{\"1\":{\"17\":2}}],[\"linux\",{\"1\":{\"8\":1,\"17\":5,\"58\":2,\"73\":18,\"80\":1,\"82\":2,\"83\":3}}],[\"libvector\",{\"1\":{\"80\":1}}],[\"libpic\",{\"1\":{\"77\":5}}],[\"library\",{\"1\":{\"75\":1,\"83\":1}}],[\"libc\",{\"1\":{\"58\":2,\"73\":6,\"80\":1,\"83\":3}}],[\"libb\",{\"1\":{\"55\":4}}],[\"liba\",{\"1\":{\"55\":9}}],[\"lib32\",{\"1\":{\"17\":2}}],[\"lib64\",{\"1\":{\"17\":1,\"82\":2,\"83\":1}}],[\"lib\",{\"1\":{\"8\":1,\"58\":2,\"73\":37,\"83\":1,\"84\":6,\"85\":2}}],[\"gmon\",{\"1\":{\"84\":1,\"85\":1}}],[\"glibc\",{\"1\":{\"84\":2,\"85\":2}}],[\"glob\",{\"1\":{\"77\":1,\"79\":1,\"85\":5}}],[\"global类型的符号\",{\"1\":{\"55\":1}}],[\"global为double\",{\"1\":{\"43\":1}}],[\"global为int\",{\"1\":{\"43\":1}}],[\"global\",{\"1\":{\"19\":2,\"21\":1,\"22\":8,\"35\":2,\"39\":9,\"43\":2,\"55\":4,\"77\":2,\"78\":2,\"84\":2}}],[\"grep\",{\"1\":{\"58\":1}}],[\"group\",{\"1\":{\"28\":1,\"67\":1}}],[\"got的重定位\",{\"1\":{\"85\":1}}],[\"got段中而是在一个名为\",{\"1\":{\"77\":1}}],[\"got中相应的项保存的是目标函数的地址\",{\"1\":{\"77\":1}}],[\"got在文件中的偏移为0x3fc0\",{\"1\":{\"77\":1}}],[\"got是如何实现指令的地址无关性的\",{\"1\":{\"77\":1}}],[\"got\",{\"1\":{\"49\":2,\"67\":5,\"73\":4,\"77\":3,\"80\":3,\"85\":7}}],[\"g++\",{\"1\":{\"42\":1}}],[\"g\",{\"1\":{\"28\":1,\"58\":7,\"67\":1}}],[\"gnu\",{\"1\":{\"8\":1,\"17\":2,\"19\":4,\"20\":2,\"28\":2,\"49\":9,\"58\":2,\"67\":10,\"73\":24,\"83\":2}}],[\"gcc默认使用小型代码模型\",{\"1\":{\"56\":1}}],[\"gcc编译器也可以通过==\",{\"1\":{\"40\":1}}],[\"gcc生成可执行文件的四个步骤\",{\"1\":{\"6\":1}}],[\"gcc\",{\"1\":{\"6\":1,\"7\":1,\"8\":2,\"9\":1,\"20\":1,\"22\":1,\"44\":2,\"46\":1,\"55\":5,\"67\":4,\"73\":3,\"77\":2,\"82\":1,\"84\":1}}],[\"supplement\",{\"1\":{\"86\":1}}],[\"sub\",{\"1\":{\"20\":2,\"52\":2,\"53\":2,\"77\":3}}],[\"slo一模一样\",{\"1\":{\"85\":1}}],[\"slo\",{\"1\":{\"85\":3}}],[\"sleep\",{\"1\":{\"67\":1,\"73\":1}}],[\"sd\",{\"1\":{\"84\":1}}],[\"sword\",{\"1\":{\"83\":1}}],[\"swap的地址\",{\"1\":{\"53\":1}}],[\"swap调用处的地址在反汇编代码的0x2c字节处同样被标记为0\",{\"1\":{\"52\":1}}],[\"swap\",{\"1\":{\"46\":2,\"50\":1,\"53\":1,\"54\":2,\"55\":4}}],[\"smaller\",{\"1\":{\"57\":1}}],[\"small\",{\"1\":{\"56\":1}}],[\"sxword\",{\"1\":{\"56\":1,\"83\":1}}],[\"s指令查看a\",{\"1\":{\"55\":1}}],[\"s指令来显示elf文件的各种段表结构\",{\"1\":{\"28\":1}}],[\"specify\",{\"1\":{\"86\":1}}],[\"specific\",{\"1\":{\"25\":1,\"28\":2,\"67\":2}}],[\"specialsymbol\",{\"1\":{\"40\":2}}],[\"s查看符号表\",{\"1\":{\"39\":1}}],[\"shndx的值会有些特殊\",{\"1\":{\"38\":1}}],[\"shndx\",{\"0\":{\"38\":1},\"1\":{\"36\":1}}],[\"shnum\",{\"1\":{\"25\":1}}],[\"shl\",{\"1\":{\"33\":1}}],[\"sh\",{\"0\":{\"30\":1,\"31\":1,\"32\":2},\"1\":{\"29\":10,\"30\":2,\"33\":5,\"38\":1}}],[\"shdr\",{\"1\":{\"29\":1}}],[\"shdr又被称为段描述符\",{\"1\":{\"28\":1}}],[\"shdr对应一个段属性描述\",{\"1\":{\"28\":1}}],[\"shdr结构的数组形式进行存储\",{\"1\":{\"28\":1}}],[\"shstrtab\",{\"1\":{\"28\":1,\"29\":1,\"34\":1,\"67\":1}}],[\"shstrndx\",{\"1\":{\"25\":1}}],[\"shentsize\",{\"1\":{\"25\":1}}],[\"shoff元素\",{\"1\":{\"29\":1}}],[\"shoff\",{\"1\":{\"25\":1}}],[\"shared选项而不使用\",{\"1\":{\"76\":1}}],[\"shared的地址\",{\"1\":{\"53\":1}}],[\"shared地址在反汇编代码的0x08字节处标记为0\",{\"1\":{\"52\":1}}],[\"shared\",{\"1\":{\"17\":1,\"46\":3,\"50\":1,\"53\":1,\"54\":2,\"55\":3,\"73\":3,\"75\":1,\"77\":2,\"83\":1,\"84\":1}}],[\"sha1\",{\"1\":{\"17\":2}}],[\"system\",{\"1\":{\"25\":1}}],[\"sysv\",{\"1\":{\"17\":2}}],[\"syment\",{\"1\":{\"83\":1}}],[\"sym\",{\"1\":{\"36\":1,\"54\":4,\"77\":2,\"85\":4}}],[\"symtab\",{\"1\":{\"22\":1,\"28\":2,\"39\":1,\"55\":1,\"67\":2,\"77\":1,\"83\":2,\"84\":4}}],[\"symbol\",{\"0\":{\"35\":1},\"1\":{\"22\":1,\"35\":5,\"36\":5,\"37\":2,\"39\":1,\"43\":2,\"54\":1,\"55\":1,\"56\":3,\"57\":1,\"77\":1,\"84\":5}}],[\"since\",{\"1\":{\"86\":2}}],[\"single\",{\"1\":{\"44\":2}}],[\"simpledynamicallinking\",{\"1\":{\"73\":10}}],[\"simplesection\",{\"1\":{\"19\":4,\"20\":2,\"21\":2,\"22\":4,\"25\":1,\"28\":1,\"35\":2,\"39\":2}}],[\"signature\",{\"1\":{\"41\":1}}],[\"sizes\",{\"1\":{\"86\":1}}],[\"size\",{\"1\":{\"19\":3,\"22\":1,\"25\":6,\"28\":1,\"29\":3,\"36\":2,\"39\":1,\"49\":3,\"55\":1,\"67\":3,\"77\":2,\"84\":1}}],[\"server\",{\"1\":{\"86\":1}}],[\"seg2\",{\"1\":{\"69\":1}}],[\"seg1\",{\"1\":{\"69\":1}}],[\"seg0\",{\"1\":{\"69\":1}}],[\"segment\",{\"1\":{\"18\":1,\"67\":22,\"73\":2,\"80\":1,\"81\":1,\"86\":1}}],[\"sec\",{\"1\":{\"49\":1,\"73\":1,\"77\":1}}],[\"sectionmapping\",{\"1\":{\"67\":7,\"68\":6}}],[\"sections\",{\"1\":{\"19\":1,\"49\":3,\"67\":1,\"73\":1}}],[\"section\",{\"1\":{\"18\":3,\"20\":7,\"21\":2,\"22\":5,\"24\":1,\"25\":8,\"28\":2,\"29\":10,\"34\":1,\"36\":2,\"39\":4,\"52\":1,\"53\":1,\"54\":2,\"55\":2,\"56\":1,\"67\":7,\"73\":1,\"77\":4,\"82\":1,\"83\":2,\"85\":2}}],[\"stderr\",{\"1\":{\"80\":3}}],[\"st\",{\"0\":{\"37\":1,\"38\":1,\"39\":1},\"1\":{\"36\":6,\"39\":2}}],[\"strsz\",{\"1\":{\"83\":2}}],[\"strong\",{\"1\":{\"43\":2,\"44\":2}}],[\"strtab\",{\"1\":{\"28\":3,\"34\":1,\"67\":3,\"83\":2,\"84\":1}}],[\"struct\",{\"1\":{\"25\":1,\"29\":1,\"36\":1,\"54\":1,\"56\":1,\"67\":1,\"83\":2,\"86\":2}}],[\"strings\",{\"1\":{\"28\":1,\"67\":1}}],[\"string\",{\"1\":{\"25\":2,\"29\":1,\"34\":2,\"36\":1,\"84\":2}}],[\"stripped\",{\"1\":{\"17\":3}}],[\"standard\",{\"1\":{\"86\":1}}],[\"stapsdt\",{\"1\":{\"67\":3}}],[\"status\",{\"1\":{\"55\":1}}],[\"static\",{\"1\":{\"17\":1,\"19\":6,\"21\":1,\"22\":3,\"35\":2,\"39\":2,\"55\":4,\"67\":2,\"75\":1,\"77\":3,\"79\":2,\"85\":2}}],[\"startup\",{\"1\":{\"52\":1,\"54\":5}}],[\"starting\",{\"1\":{\"28\":1,\"67\":2,\"73\":1,\"77\":1}}],[\"start\",{\"1\":{\"25\":2,\"40\":5,\"80\":1,\"84\":1,\"85\":1}}],[\"stack虽然有但是长度为0\",{\"1\":{\"19\":1}}],[\"stack\",{\"1\":{\"19\":2,\"28\":1,\"49\":2,\"53\":1,\"54\":2,\"55\":2,\"67\":1,\"68\":1,\"73\":2}}],[\"so导出\",{\"1\":{\"84\":1}}],[\"so它实际上是定义了foobar\",{\"1\":{\"84\":1}}],[\"soname\",{\"1\":{\"83\":1}}],[\"so实际上是一个共享对象\",{\"1\":{\"81\":1}}],[\"so模块的入口点\",{\"1\":{\"80\":1}}],[\"so和bar\",{\"1\":{\"80\":1}}],[\"so中第一次调用bar\",{\"1\":{\"80\":1}}],[\"so中的bar\",{\"1\":{\"80\":1}}],[\"so需要调用libc\",{\"1\":{\"80\":1}}],[\"so外\",{\"1\":{\"73\":1}}],[\"so与program1一样\",{\"1\":{\"73\":1}}],[\"so的\",{\"1\":{\"84\":1}}],[\"so的最终装载地址并不是0x0000000000000000\",{\"1\":{\"73\":1}}],[\"so的装载属性\",{\"1\":{\"73\":1}}],[\"so的动态符号\",{\"1\":{\"73\":1}}],[\"so的原因\",{\"1\":{\"73\":1}}],[\"so也作为链接的输入文件之一\",{\"1\":{\"73\":1}}],[\"so也参与了链接过程\",{\"1\":{\"73\":1}}],[\"so保留了完整的符号信息\",{\"1\":{\"73\":1}}],[\"so共享对象文件\",{\"1\":{\"73\":1}}],[\"so文件\",{\"1\":{\"17\":1}}],[\"so\",{\"1\":{\"17\":3,\"73\":24,\"77\":5,\"80\":1,\"82\":2,\"83\":6,\"84\":4,\"85\":3,\"86\":1}}],[\"s\",{\"1\":{\"8\":3,\"9\":2,\"20\":2,\"22\":1,\"25\":1,\"28\":2,\"39\":1,\"55\":1,\"56\":3,\"67\":2,\"68\":1,\"77\":2,\"80\":3,\"82\":1,\"85\":1}}],[\"生成的代码要小\",{\"1\":{\"77\":1}}],[\"生成的代码要大\",{\"1\":{\"77\":1}}],[\"生成目标文件\",{\"1\":{\"9\":1}}],[\"生成汇编文件\",{\"1\":{\"8\":1}}],[\"生成预处理文件\",{\"1\":{\"7\":1}}],[\"语义分析及优化后生成汇编的过程\",{\"1\":{\"8\":1}}],[\"语法分析\",{\"1\":{\"8\":1}}],[\"将控制权交给动态链接器的入口地址\",{\"1\":{\"81\":1}}],[\"将共享对象中的地址引用按照是否跨模块分为\",{\"1\":{\"77\":1}}],[\"将program1\",{\"1\":{\"73\":1}}],[\"将其映射到进程的地址空间\",{\"1\":{\"69\":1}}],[\"将进程与中该虚拟内存页与分配的物理内存页建立映射关系\",{\"1\":{\"65\":1}}],[\"将cpu的指令寄存器设置成可执行文件的入口地址\",{\"1\":{\"64\":1}}],[\"将shared地址写入第二个参数\",{\"1\":{\"52\":1}}],[\"将所有包含指令的段反汇编\",{\"1\":{\"20\":1}}],[\"将所有段的内容以十六进制的方式打印\",{\"1\":{\"20\":1}}],[\"将每个源代码模块独立编译\",{\"1\":{\"12\":1}}],[\"将每一条汇编指令翻译成对应机器码的过程\",{\"1\":{\"9\":1}}],[\"将预处理文件经过一系列词法分析\",{\"1\":{\"8\":1}}],[\"将被包含的文件插入到该预处理指令的位置\",{\"1\":{\"7\":1}}],[\">\",{\"1\":{\"7\":1}}],[\"6中\",{\"1\":{\"85\":1}}],[\"6f2e3200\",{\"1\":{\"82\":1}}],[\"6e75782d\",{\"1\":{\"82\":1}}],[\"66\",{\"1\":{\"77\":3,\"80\":1}}],[\"669\",{\"1\":{\"68\":2}}],[\"63\",{\"1\":{\"20\":1}}],[\"62\",{\"1\":{\"20\":1}}],[\"62756e74\",{\"1\":{\"20\":2}}],[\"64位\",{\"1\":{\"83\":1}}],[\"642d6c69\",{\"1\":{\"82\":1}}],[\"64应该为rip\",{\"1\":{\"70\":1}}],[\"64小型代码模型\",{\"1\":{\"56\":1}}],[\"64\",{\"1\":{\"8\":1,\"17\":5,\"19\":1,\"20\":1,\"25\":3,\"29\":1,\"49\":3,\"52\":4,\"53\":5,\"54\":9,\"56\":4,\"58\":4,\"67\":2,\"73\":19,\"77\":1,\"79\":1,\"82\":3,\"83\":2,\"85\":14,\"86\":2}}],[\"6\",{\"0\":{\"45\":1,\"87\":1},\"1\":{\"7\":1,\"19\":1,\"22\":1,\"28\":1,\"39\":1,\"49\":3,\"55\":2,\"67\":1,\"69\":1,\"73\":6,\"83\":3,\"84\":1}}],[\"比如可执行文件有几个段\",{\"1\":{\"86\":1}}],[\"比如用于保存符号名的字符串表\",{\"1\":{\"84\":1}}],[\"比如是私有变量则不保存\",{\"1\":{\"84\":1}}],[\"比如是否可写\",{\"1\":{\"31\":1}}],[\"比如program1程序依赖于lib\",{\"1\":{\"84\":1}}],[\"比如依赖于那些共享对象\",{\"1\":{\"83\":1}}],[\"比如bar\",{\"1\":{\"80\":1}}],[\"比如一些错误处理函数或者是一些用户很少用到的功能模块等\",{\"1\":{\"80\":1}}],[\"比如一个c函数\",{\"1\":{\"40\":1}}],[\"比如全局符号的数量或者代码的长度等\",{\"1\":{\"77\":1}}],[\"比如第一个地址对应变量b\",{\"1\":{\"77\":1}}],[\"比如其它模块中定义的全局变量\",{\"1\":{\"77\":1}}],[\"比如模块中定义的全局变量\",{\"1\":{\"77\":1}}],[\"比如0x1000到0x2000分配给模块a\",{\"1\":{\"75\":1}}],[\"比如动态链接器就必须读取elf文件头\",{\"1\":{\"69\":1}}],[\"比如seg0和seg1的接壤部分的那个物理页\",{\"1\":{\"69\":1}}],[\"比如simplesection\",{\"1\":{\"39\":2}}],[\"比如上面提到的\",{\"1\":{\"67\":1}}],[\"比如有两个段分别叫\",{\"1\":{\"67\":1}}],[\"比如这个就是代码段\",{\"1\":{\"54\":1}}],[\"比如代码段\",{\"1\":{\"54\":1}}],[\"比如我们假设\",{\"1\":{\"50\":1}}],[\"比如将所有输入文件的\",{\"1\":{\"49\":1}}],[\"比如文件foo\",{\"1\":{\"55\":1}}],[\"比如文件a声明符号\",{\"1\":{\"43\":1}}],[\"比如文件b用到了目标a中的函数\",{\"1\":{\"35\":1}}],[\"比如main\",{\"1\":{\"41\":1}}],[\"比如foo命名空间下的bar变量\",{\"1\":{\"41\":1}}],[\"比如n\",{\"1\":{\"41\":1}}],[\"比如段名\",{\"1\":{\"34\":1}}],[\"比如每个段的段名\",{\"1\":{\"24\":1}}],[\"比如\",{\"1\":{\"7\":1,\"14\":1,\"33\":1,\"50\":1,\"85\":1}}],[\"添加行号和文件名标号\",{\"1\":{\"7\":1}}],[\"57\",{\"1\":{\"22\":1,\"39\":1}}],[\"5d\",{\"1\":{\"20\":2}}],[\"58\",{\"1\":{\"20\":1}}],[\"5611c5471000\",{\"1\":{\"73\":1}}],[\"5611c5450000\",{\"1\":{\"73\":1}}],[\"5611c3c7e000\",{\"1\":{\"73\":1}}],[\"5611c3c7d000\",{\"1\":{\"73\":2}}],[\"5611c3c7c000\",{\"1\":{\"73\":2}}],[\"5611c3c7b000\",{\"1\":{\"73\":2}}],[\"5611c3c7a000\",{\"1\":{\"73\":2}}],[\"5611c3c79000\",{\"1\":{\"73\":1}}],[\"56\",{\"1\":{\"20\":1}}],[\"54\",{\"1\":{\"20\":1}}],[\"54000000\",{\"1\":{\"20\":1}}],[\"51\",{\"1\":{\"20\":1}}],[\"55\",{\"1\":{\"20\":2}}],[\"55000000\",{\"1\":{\"20\":1}}],[\"554889e5\",{\"1\":{\"20\":1}}],[\"5\",{\"0\":{\"35\":1,\"36\":1,\"37\":1,\"38\":1,\"39\":1,\"40\":1,\"41\":1,\"42\":1,\"43\":2,\"45\":1,\"79\":1,\"81\":1,\"82\":1,\"83\":1,\"84\":1,\"85\":1,\"86\":2},\"1\":{\"7\":1,\"19\":1,\"20\":1,\"22\":2,\"28\":1,\"39\":2,\"40\":1,\"49\":3,\"55\":3,\"67\":1,\"84\":3,\"85\":2}}],[\"删除所有注释\",{\"1\":{\"7\":1}}],[\"404\",{\"1\":{\"89\":1}}],[\"4020\",{\"1\":{\"85\":1}}],[\"4014\",{\"1\":{\"77\":1}}],[\"401c\",{\"1\":{\"77\":2}}],[\"4010\",{\"1\":{\"53\":1}}],[\"4008\",{\"1\":{\"77\":1,\"80\":1}}],[\"4000\",{\"1\":{\"77\":2}}],[\"49446\",{\"1\":{\"73\":5}}],[\"49449\",{\"1\":{\"73\":5}}],[\"4d\",{\"1\":{\"52\":1}}],[\"47\",{\"1\":{\"52\":1}}],[\"474e5500\",{\"1\":{\"20\":1}}],[\"41\",{\"1\":{\"52\":1}}],[\"4byte\",{\"1\":{\"43\":1}}],[\"42\",{\"1\":{\"42\":2}}],[\"46\",{\"1\":{\"25\":1}}],[\"43\",{\"1\":{\"22\":1,\"39\":1,\"52\":1,\"84\":1}}],[\"4f\",{\"1\":{\"20\":1}}],[\"4c\",{\"1\":{\"20\":1,\"25\":1}}],[\"4a\",{\"1\":{\"20\":2}}],[\"44\",{\"1\":{\"20\":2,\"52\":3,\"53\":4,\"77\":3,\"80\":1}}],[\"45\",{\"1\":{\"20\":4,\"25\":1}}],[\"45f80100\",{\"1\":{\"20\":1}}],[\"45fc89c6\",{\"1\":{\"20\":1}}],[\"48\",{\"1\":{\"20\":6,\"52\":11,\"53\":11,\"77\":9}}],[\"4889e548\",{\"1\":{\"20\":1}}],[\"488d0500\",{\"1\":{\"20\":1}}],[\"4883ec10\",{\"1\":{\"20\":1}}],[\"4\",{\"0\":{\"10\":1,\"15\":1,\"24\":1,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"33\":1,\"34\":2,\"42\":1,\"56\":1,\"58\":1,\"70\":1,\"78\":1,\"80\":1,\"85\":1},\"1\":{\"7\":1,\"19\":1,\"20\":1,\"22\":7,\"28\":3,\"39\":7,\"49\":7,\"52\":1,\"54\":3,\"55\":1,\"57\":1,\"67\":6,\"77\":1,\"80\":4,\"84\":1}}],[\"递归的执行\",{\"1\":{\"7\":1}}],[\"处理\",{\"1\":{\"7\":1}}],[\"处理所有预编译指令\",{\"1\":{\"7\":1}}],[\"34\",{\"1\":{\"69\":1}}],[\"3fc0\",{\"1\":{\"77\":3}}],[\"3f\",{\"1\":{\"52\":1}}],[\"3d\",{\"1\":{\"52\":1}}],[\"36342e73\",{\"1\":{\"82\":1}}],[\"36342f6c\",{\"1\":{\"82\":1}}],[\"36\",{\"1\":{\"52\":1}}],[\"31\",{\"1\":{\"52\":5,\"53\":2}}],[\"31332e32\",{\"1\":{\"20\":1}}],[\"35\",{\"1\":{\"52\":2,\"53\":2}}],[\"3e\",{\"1\":{\"20\":1}}],[\"37\",{\"1\":{\"20\":1}}],[\"33\",{\"1\":{\"20\":1}}],[\"30\",{\"1\":{\"20\":1}}],[\"39000000\",{\"1\":{\"20\":1}}],[\"3c000000\",{\"1\":{\"20\":1}}],[\"3a202855\",{\"1\":{\"20\":1}}],[\"32位\",{\"1\":{\"83\":1}}],[\"32\",{\"1\":{\"17\":1,\"56\":2,\"67\":5,\"86\":2}}],[\"3\",{\"0\":{\"9\":1,\"14\":1,\"19\":1,\"20\":1,\"21\":1,\"22\":2,\"23\":2,\"27\":1,\"32\":1,\"33\":1,\"39\":1,\"41\":1,\"50\":1,\"55\":1,\"57\":1,\"66\":1,\"67\":1,\"68\":1,\"69\":2,\"70\":1,\"74\":1,\"75\":1,\"76\":1,\"77\":2,\"78\":1,\"79\":1,\"84\":1},\"1\":{\"7\":1,\"17\":1,\"19\":3,\"22\":4,\"28\":1,\"39\":4,\"40\":1,\"49\":19,\"54\":1,\"55\":3,\"67\":1,\"80\":1,\"83\":1,\"84\":1,\"85\":1}}],[\"ef\",{\"1\":{\"77\":2}}],[\"error\",{\"1\":{\"55\":1,\"80\":3}}],[\"etext\",{\"1\":{\"40\":9}}],[\"export\",{\"1\":{\"84\":2}}],[\"exectuion\",{\"1\":{\"67\":1}}],[\"exec\",{\"1\":{\"67\":1,\"86\":1}}],[\"execution\",{\"1\":{\"29\":1}}],[\"execute\",{\"1\":{\"28\":1,\"67\":1}}],[\"executable\",{\"1\":{\"17\":1,\"40\":7,\"67\":1,\"77\":1}}],[\"except\",{\"1\":{\"67\":2}}],[\"exclude\",{\"1\":{\"28\":1,\"67\":1}}],[\"exit\",{\"1\":{\"55\":1,\"80\":3}}],[\"ext\",{\"1\":{\"43\":1,\"77\":5}}],[\"extern\",{\"0\":{\"42\":1},\"1\":{\"40\":4,\"42\":4,\"43\":1,\"46\":1,\"77\":4,\"78\":1}}],[\"external\",{\"1\":{\"35\":1}}],[\"extra\",{\"1\":{\"28\":1,\"67\":1}}],[\"ei\",{\"1\":{\"25\":1}}],[\"edata\",{\"1\":{\"40\":6}}],[\"edx\",{\"1\":{\"20\":4}}],[\"edi\",{\"1\":{\"20\":2}}],[\"e8\",{\"1\":{\"20\":2,\"52\":3,\"53\":3,\"77\":6}}],[\"e8000000\",{\"1\":{\"20\":1}}],[\"esi\",{\"1\":{\"20\":1}}],[\"eax\",{\"1\":{\"20\":11,\"52\":4,\"53\":4,\"77\":6}}],[\"ec\",{\"1\":{\"20\":2,\"52\":1,\"53\":1,\"77\":3}}],[\"e5\",{\"1\":{\"20\":2}}],[\"ehdr的e\",{\"1\":{\"29\":1}}],[\"ehdr\",{\"1\":{\"25\":1}}],[\"ehsize\",{\"1\":{\"25\":1}}],[\"eh\",{\"1\":{\"19\":1,\"20\":1,\"28\":2,\"49\":4,\"54\":2,\"67\":2,\"73\":4}}],[\"entsize\",{\"1\":{\"28\":1,\"29\":1,\"67\":1,\"77\":1}}],[\"entries\",{\"1\":{\"22\":1,\"39\":1,\"54\":1,\"55\":1,\"77\":2,\"83\":1,\"84\":1,\"85\":1}}],[\"entry\",{\"1\":{\"14\":1,\"25\":7,\"29\":1,\"54\":2,\"56\":1,\"67\":1,\"73\":1,\"83\":3,\"85\":1,\"86\":2}}],[\"end\",{\"1\":{\"40\":12}}],[\"endian\",{\"1\":{\"25\":1}}],[\"endif\",{\"1\":{\"7\":1,\"73\":1}}],[\"endbr64\",{\"1\":{\"20\":2,\"52\":1,\"53\":1,\"77\":7,\"80\":1}}],[\"e\",{\"1\":{\"7\":1,\"20\":6,\"25\":14,\"28\":1,\"41\":2,\"67\":2,\"73\":1}}],[\"elements\",{\"1\":{\"86\":2}}],[\"elf中表示这种模块间符号导入导出的关系就叫做\",{\"1\":{\"84\":1}}],[\"elf32\",{\"1\":{\"83\":4,\"86\":1}}],[\"elf使用\",{\"1\":{\"80\":1}}],[\"elf共享库在编译时\",{\"1\":{\"78\":1}}],[\"elf的做法是在数据段里面创建一个指向这些变量的指针数组\",{\"1\":{\"77\":1}}],[\"elf与linux进程虚拟空间映射关系\",{\"1\":{\"68\":1}}],[\"elf可执行文件有一个专门的数据结构叫做==程序头表\",{\"1\":{\"67\":1}}],[\"elf可执行文件与进程虚拟空间映射关系\",{\"1\":{\"67\":1}}],[\"elf可执行文件引入了一个概念叫做\",{\"1\":{\"67\":1}}],[\"elf定义了32种不同的重定位类型\",{\"1\":{\"56\":1}}],[\"elf符号表结构\",{\"0\":{\"36\":1},\"1\":{\"36\":1}}],[\"elf重定位类型\",{\"1\":{\"25\":1}}],[\"elf魔数\",{\"1\":{\"25\":1}}],[\"elf目标文件的最前部是elf文件头\",{\"1\":{\"24\":1}}],[\"elf64\",{\"1\":{\"19\":1,\"20\":1,\"25\":15,\"29\":12,\"36\":5,\"49\":3,\"52\":1,\"53\":1,\"54\":4,\"56\":4,\"58\":2,\"67\":9,\"82\":1,\"83\":4,\"86\":1}}],[\"elf文件链接视图和执行视图\",{\"0\":{\"67\":1}}],[\"elf文件中用到了很多字符串\",{\"1\":{\"34\":1}}],[\"elf文件头中保存有入口地址\",{\"1\":{\"64\":1}}],[\"elf文件头中指出了段表位于文件的偏移\",{\"1\":{\"29\":1}}],[\"elf文件头结构成员含义\",{\"1\":{\"25\":1}}],[\"elf文件头定义了\",{\"1\":{\"25\":1}}],[\"elf文件结构\",{\"1\":{\"24\":1}}],[\"elf文件结构描述\",{\"0\":{\"24\":1}}],[\"elf文件的开头是一个\",{\"1\":{\"18\":1}}],[\"elf文件标准里采用elf格式的文件\",{\"1\":{\"17\":1}}],[\"elf\",{\"1\":{\"17\":3,\"24\":1,\"25\":3,\"29\":1,\"36\":1,\"67\":6,\"68\":6,\"73\":1,\"86\":1}}],[\"else\",{\"1\":{\"7\":1,\"44\":1}}],[\"elif\",{\"1\":{\"7\":1}}],[\"it\",{\"1\":{\"86\":4}}],[\"itm\",{\"1\":{\"84\":2,\"85\":2}}],[\"image\",{\"1\":{\"84\":1}}],[\"import\",{\"1\":{\"84\":2}}],[\"implicit\",{\"1\":{\"55\":1}}],[\"ia32下一般为4096字节\",{\"1\":{\"64\":1}}],[\"is\",{\"1\":{\"44\":4,\"57\":1,\"67\":1,\"73\":1,\"86\":2}}],[\"id\",{\"1\":{\"49\":1,\"67\":2,\"73\":2}}],[\"ident\",{\"1\":{\"25\":1}}],[\"idx\",{\"1\":{\"19\":1,\"49\":3}}],[\"i\",{\"1\":{\"7\":3,\"8\":2,\"19\":2,\"28\":3,\"41\":1,\"67\":1,\"73\":5,\"84\":2}}],[\"ifndef\",{\"1\":{\"73\":1}}],[\"ifdef\",{\"1\":{\"7\":1}}],[\"if\",{\"1\":{\"7\":1,\"29\":1,\"44\":2,\"56\":2,\"80\":3}}],[\"independent\",{\"1\":{\"77\":2}}],[\"index\",{\"1\":{\"25\":2,\"29\":1,\"36\":2,\"54\":1,\"56\":1}}],[\"in\",{\"1\":{\"25\":1,\"29\":1,\"55\":4,\"57\":2,\"67\":2,\"86\":2}}],[\"information\",{\"1\":{\"29\":1}}],[\"info\",{\"0\":{\"32\":1,\"37\":1},\"1\":{\"25\":1,\"28\":2,\"29\":1,\"33\":1,\"36\":1,\"54\":3,\"56\":1,\"67\":2,\"77\":2,\"85\":2}}],[\"init为512字节\",{\"1\":{\"67\":1}}],[\"init\",{\"1\":{\"19\":1,\"21\":1,\"22\":1,\"35\":1,\"39\":2,\"49\":2,\"67\":8,\"73\":3,\"83\":4}}],[\"into\",{\"1\":{\"25\":2}}],[\"integer\",{\"1\":{\"83\":2,\"86\":2}}],[\"interna\",{\"1\":{\"58\":1}}],[\"internal\",{\"1\":{\"58\":2}}],[\"interposition\",{\"1\":{\"77\":1}}],[\"interp\",{\"0\":{\"82\":1},\"1\":{\"49\":1,\"82\":6}}],[\"interpreter\",{\"1\":{\"17\":1,\"82\":3,\"86\":2}}],[\"intel\",{\"1\":{\"17\":1}}],[\"int\",{\"1\":{\"6\":1,\"19\":9,\"40\":1,\"41\":12,\"42\":8,\"43\":6,\"44\":3,\"46\":6,\"67\":1,\"73\":5,\"77\":4,\"78\":2,\"79\":2,\"80\":8,\"82\":1,\"84\":2,\"85\":2}}],[\"include预编译指令\",{\"1\":{\"7\":1}}],[\"include\",{\"1\":{\"6\":1,\"25\":1,\"29\":1,\"36\":1,\"40\":1,\"42\":1,\"44\":2,\"67\":1,\"73\":5,\"80\":3,\"82\":1,\"84\":2,\"86\":1}}],[\"2e\",{\"1\":{\"77\":6}}],[\"2e3000\",{\"1\":{\"20\":1}}],[\"2e322e30\",{\"1\":{\"20\":1}}],[\"27\",{\"1\":{\"67\":1,\"77\":1,\"83\":1}}],[\"2c\",{\"1\":{\"52\":2}}],[\"26\",{\"1\":{\"49\":1,\"67\":2}}],[\"25\",{\"1\":{\"49\":1,\"52\":2,\"53\":3,\"67\":1,\"77\":3,\"80\":1}}],[\"25640a00\",{\"1\":{\"20\":1}}],[\"24\",{\"1\":{\"49\":1,\"52\":5,\"53\":5,\"67\":1,\"83\":3,\"85\":1}}],[\"240\",{\"1\":{\"19\":1}}],[\"22\",{\"1\":{\"49\":1,\"67\":1,\"77\":1,\"85\":1}}],[\"224\",{\"1\":{\"19\":1}}],[\"21\",{\"1\":{\"49\":1,\"67\":1}}],[\"20\",{\"1\":{\"49\":1,\"67\":2}}],[\"2f6c6962\",{\"1\":{\"82\":1}}],[\"2f\",{\"1\":{\"20\":1,\"53\":2,\"77\":3,\"80\":1}}],[\"2b\",{\"1\":{\"20\":1,\"52\":2,\"53\":1}}],[\"2b000000\",{\"1\":{\"20\":1}}],[\"29\",{\"1\":{\"20\":1,\"77\":1}}],[\"28\",{\"1\":{\"20\":2,\"52\":2,\"53\":3,\"67\":1}}],[\"23\",{\"1\":{\"20\":1,\"49\":1,\"67\":1,\"85\":1}}],[\"23ubuntu4\",{\"1\":{\"20\":1}}],[\"2d323375\",{\"1\":{\"20\":1}}],[\"2a\",{\"1\":{\"14\":1,\"20\":1}}],[\"2\",{\"0\":{\"8\":1,\"11\":1,\"12\":1,\"13\":2,\"14\":1,\"15\":1,\"18\":1,\"21\":1,\"26\":1,\"28\":1,\"29\":1,\"30\":1,\"31\":2,\"32\":1,\"38\":1,\"40\":1,\"49\":1,\"51\":1,\"52\":1,\"54\":2,\"55\":1,\"56\":1,\"62\":1,\"63\":1,\"64\":1,\"65\":2,\"68\":1,\"73\":1,\"76\":1,\"83\":1},\"1\":{\"7\":3,\"17\":4,\"19\":11,\"20\":2,\"22\":1,\"25\":1,\"28\":1,\"39\":1,\"43\":2,\"49\":51,\"55\":1,\"67\":1,\"73\":7,\"77\":2,\"80\":12,\"82\":2,\"83\":1,\"84\":7,\"85\":4}}],[\"展开所有宏定义\",{\"1\":{\"7\":1}}],[\"汇编\",{\"0\":{\"9\":1},\"1\":{\"6\":1}}],[\"编译器会产生这样的代码\",{\"1\":{\"78\":1}}],[\"编译器还不知道foobar\",{\"1\":{\"73\":1}}],[\"编译\",{\"0\":{\"8\":1},\"1\":{\"6\":1}}],[\"编译和链接\",{\"0\":{\"5\":1}}],[\"预处理\",{\"0\":{\"7\":1},\"1\":{\"6\":1}}],[\"o链接成可执行文件时\",{\"1\":{\"73\":1}}],[\"o链接到一起\",{\"1\":{\"73\":1}}],[\"o时\",{\"1\":{\"73\":1}}],[\"o没有被链接起来\",{\"1\":{\"73\":1}}],[\"o和lib\",{\"1\":{\"73\":1}}],[\"o被链接成可执行文件这一步\",{\"1\":{\"73\":1}}],[\"o之后\",{\"1\":{\"73\":1}}],[\"on\",{\"1\":{\"68\":1,\"86\":2}}],[\"only\",{\"1\":{\"55\":1,\"86\":1}}],[\"overlay\",{\"1\":{\"61\":1}}],[\"obstack\",{\"1\":{\"58\":6}}],[\"objdump\",{\"1\":{\"19\":1,\"20\":1,\"49\":3,\"52\":1,\"53\":1,\"58\":1,\"82\":1}}],[\"object\",{\"1\":{\"17\":1,\"22\":4,\"25\":2,\"39\":4,\"73\":1,\"77\":1}}],[\"o的符号表\",{\"1\":{\"55\":1}}],[\"o2\",{\"1\":{\"46\":1}}],[\"o中所有要重定位的地方\",{\"1\":{\"54\":1}}],[\"o中的foobar\",{\"1\":{\"73\":1}}],[\"o中的\",{\"1\":{\"39\":2}}],[\"o中有一个叫做\",{\"1\":{\"33\":1}}],[\"o共有10个有效段\",{\"1\":{\"28\":1}}],[\"order\",{\"1\":{\"28\":1,\"67\":1}}],[\"other\",{\"1\":{\"25\":1,\"36\":1}}],[\"os\",{\"1\":{\"25\":1,\"28\":2,\"67\":2}}],[\"of\",{\"1\":{\"20\":7,\"25\":7,\"52\":1,\"53\":1,\"55\":1,\"57\":1,\"77\":1,\"82\":1,\"86\":1}}],[\"offset\",{\"1\":{\"19\":1,\"25\":2,\"28\":2,\"29\":2,\"54\":8,\"56\":3,\"67\":6,\"73\":2,\"77\":5,\"83\":1,\"85\":4}}],[\"off\",{\"1\":{\"19\":1,\"25\":2,\"29\":1,\"49\":3,\"67\":1}}],[\"o文件的static\",{\"1\":{\"35\":1}}],[\"o文件\",{\"1\":{\"17\":1}}],[\"o后缀的文件\",{\"1\":{\"15\":1}}],[\"o\",{\"0\":{\"19\":1},\"1\":{\"6\":1,\"7\":1,\"8\":1,\"9\":5,\"17\":2,\"19\":4,\"20\":2,\"22\":1,\"25\":1,\"28\":3,\"35\":1,\"39\":1,\"42\":1,\"44\":2,\"49\":4,\"50\":3,\"52\":2,\"54\":4,\"55\":3,\"57\":2,\"58\":2,\"67\":4,\"73\":4,\"77\":2,\"82\":1,\"84\":1}}],[\"09\",{\"1\":{\"67\":1,\"73\":1,\"77\":2}}],[\"0328\",{\"1\":{\"82\":1}}],[\"0318\",{\"1\":{\"82\":1}}],[\"03\",{\"1\":{\"67\":1,\"73\":1,\"77\":1}}],[\"03000000\",{\"1\":{\"20\":1}}],[\"07\",{\"1\":{\"52\":1,\"53\":1,\"67\":1,\"73\":1}}],[\"08\",{\"1\":{\"52\":2,\"53\":3,\"67\":1,\"68\":5,\"73\":21,\"77\":6}}],[\"08000000\",{\"1\":{\"20\":2}}],[\"04\",{\"1\":{\"52\":4,\"53\":5,\"67\":1,\"73\":1}}],[\"04000000\",{\"1\":{\"20\":2}}],[\"02\",{\"1\":{\"25\":1,\"67\":1,\"73\":1,\"77\":2}}],[\"020000c0\",{\"1\":{\"20\":1}}],[\"0f\",{\"1\":{\"20\":2,\"52\":1,\"53\":4,\"77\":10,\"80\":2}}],[\"0f1efa55\",{\"1\":{\"20\":1}}],[\"06\",{\"1\":{\"67\":1,\"73\":1}}],[\"06700c07\",{\"1\":{\"20\":1}}],[\"06620c07\",{\"1\":{\"20\":1}}],[\"01edd000\",{\"1\":{\"68\":1}}],[\"01ebb000\",{\"1\":{\"68\":1}}],[\"01\",{\"1\":{\"20\":4,\"25\":2,\"53\":2,\"67\":1,\"73\":1,\"77\":3}}],[\"01781001\",{\"1\":{\"20\":1}}],[\"017a5200\",{\"1\":{\"20\":1}}],[\"01d089c7\",{\"1\":{\"20\":1}}],[\"0x510\",{\"1\":{\"85\":1}}],[\"0x50e\",{\"1\":{\"83\":1}}],[\"0x520\",{\"1\":{\"83\":1}}],[\"0x550\",{\"1\":{\"83\":1}}],[\"0x610\",{\"1\":{\"83\":1}}],[\"0x3fb8\",{\"1\":{\"83\":1}}],[\"0x3fc0\",{\"1\":{\"77\":1}}],[\"0x3b0\",{\"1\":{\"83\":1}}],[\"0x3d8\",{\"1\":{\"83\":1}}],[\"0x3dc0\",{\"1\":{\"83\":1}}],[\"0x3db8\",{\"1\":{\"83\":1}}],[\"0x3548\",{\"1\":{\"77\":1}}],[\"0x390\",{\"1\":{\"29\":1}}],[\"0xbf510\",{\"1\":{\"67\":1}}],[\"0x2dc8\",{\"1\":{\"83\":1}}],[\"0x2e96\",{\"1\":{\"77\":1}}],[\"0x2ef1\",{\"1\":{\"77\":1}}],[\"0x2e72\",{\"1\":{\"77\":4}}],[\"0x2ed5\",{\"1\":{\"77\":3}}],[\"0x2f8e\",{\"1\":{\"77\":1,\"80\":1}}],[\"0x2f96\",{\"1\":{\"77\":2}}],[\"0x2fa1\",{\"1\":{\"53\":3}}],[\"0x230\",{\"1\":{\"54\":1}}],[\"0x28\",{\"1\":{\"52\":2,\"53\":3}}],[\"0x2a\",{\"1\":{\"14\":1}}],[\"0x74\",{\"1\":{\"29\":1}}],[\"0x1168\",{\"1\":{\"83\":1}}],[\"0x114e\",{\"1\":{\"77\":1}}],[\"0x1147\",{\"1\":{\"77\":1}}],[\"0x11a0\",{\"1\":{\"53\":1}}],[\"0x1e8\",{\"1\":{\"54\":1}}],[\"0x1064代码处调用\",{\"1\":{\"77\":1}}],[\"0x106f\",{\"1\":{\"53\":1}}],[\"0x10\",{\"1\":{\"67\":1,\"73\":1}}],[\"0x10003fc0\",{\"1\":{\"77\":1}}],[\"0x1000401c\",{\"1\":{\"77\":1}}],[\"0x10000000\",{\"1\":{\"77\":1}}],[\"0x1000\",{\"1\":{\"67\":4,\"73\":4,\"83\":1}}],[\"0x1091\",{\"1\":{\"53\":1}}],[\"0x1\",{\"1\":{\"25\":1,\"67\":1,\"73\":1,\"80\":1}}],[\"0x8\",{\"1\":{\"20\":2,\"52\":2,\"53\":3,\"67\":3,\"73\":3}}],[\"0x468\",{\"1\":{\"85\":1}}],[\"0x480\",{\"1\":{\"83\":1}}],[\"0x458\",{\"1\":{\"77\":1}}],[\"0x401720\",{\"1\":{\"67\":1}}],[\"0x4010\",{\"1\":{\"53\":1}}],[\"0x408\",{\"1\":{\"28\":1,\"29\":1}}],[\"0x4\",{\"1\":{\"20\":3,\"52\":2,\"53\":2,\"67\":1,\"73\":2}}],[\"0x00007f796754d000\",{\"1\":{\"83\":1}}],[\"0x00007f7967314000\",{\"1\":{\"83\":1}}],[\"0x00007ffe6d77b000\",{\"1\":{\"83\":1}}],[\"0x000000006ffffff9\",{\"1\":{\"83\":1}}],[\"0x000000006ffffff0\",{\"1\":{\"83\":1}}],[\"0x000000006fffffff\",{\"1\":{\"83\":1}}],[\"0x000000006ffffffe\",{\"1\":{\"83\":1}}],[\"0x000000006ffffffb\",{\"1\":{\"83\":1}}],[\"0x000000006ffffef5\",{\"1\":{\"83\":1}}],[\"0x00000000004a5f50\",{\"1\":{\"67\":6}}],[\"0x000000000047f000\",{\"1\":{\"67\":2}}],[\"0x00000000004002a0\",{\"1\":{\"67\":2}}],[\"0x0000000000400270\",{\"1\":{\"67\":4}}],[\"0x0000000000400000\",{\"1\":{\"67\":2}}],[\"0x0000000000401000\",{\"1\":{\"67\":2}}],[\"0x00000000000a4f50\",{\"1\":{\"67\":3}}],[\"0x00000000000259ec\",{\"1\":{\"67\":2}}],[\"0x000000000007f000\",{\"1\":{\"67\":1}}],[\"0x000000000007d6b1\",{\"1\":{\"67\":2}}],[\"0x0000000000004000\",{\"1\":{\"85\":1}}],[\"0x00000000000040b0\",{\"1\":{\"67\":2}}],[\"0x0000000000003e08\",{\"1\":{\"73\":2}}],[\"0x0000000000003df8\",{\"1\":{\"73\":4}}],[\"0x000000000000201c\",{\"1\":{\"73\":3}}],[\"0x0000000000002000\",{\"1\":{\"73\":3}}],[\"0x0000000000002e08\",{\"1\":{\"73\":1}}],[\"0x0000000000002df8\",{\"1\":{\"73\":2}}],[\"0x000000000000b2f8\",{\"1\":{\"67\":1}}],[\"0x0000000000005b78\",{\"1\":{\"67\":1}}],[\"0x0000000000001000\",{\"1\":{\"67\":1,\"73\":3}}],[\"0x00000000000001c0\",{\"1\":{\"73\":2}}],[\"0x000000000000017d\",{\"1\":{\"73\":2}}],[\"0x0000000000000560\",{\"1\":{\"73\":2}}],[\"0x0000000000000208\",{\"1\":{\"73\":2}}],[\"0x00000000000002c8\",{\"1\":{\"73\":3}}],[\"0x00000000000002a8\",{\"1\":{\"73\":6}}],[\"0x00000000000002a0\",{\"1\":{\"67\":1}}],[\"0x0000000000000228\",{\"1\":{\"73\":1}}],[\"0x0000000000000220\",{\"1\":{\"73\":1}}],[\"0x0000000000000270\",{\"1\":{\"67\":2}}],[\"0x000000000000001e\",{\"1\":{\"83\":1}}],[\"0x0000000000000017\",{\"1\":{\"83\":1}}],[\"0x0000000000000014\",{\"1\":{\"83\":1}}],[\"0x0000000000000015\",{\"1\":{\"83\":1}}],[\"0x000000000000001c\",{\"1\":{\"83\":1}}],[\"0x000000000000001a\",{\"1\":{\"83\":1}}],[\"0x000000000000001b\",{\"1\":{\"83\":1}}],[\"0x0000000000000019\",{\"1\":{\"83\":1}}],[\"0x0000000000000018\",{\"1\":{\"67\":1}}],[\"0x000000000000002c\",{\"1\":{\"73\":2}}],[\"0x0000000000000024\",{\"1\":{\"73\":2}}],[\"0x0000000000000020\",{\"1\":{\"73\":4}}],[\"0x00000000000000dc\",{\"1\":{\"73\":2}}],[\"0x0000000000000058\",{\"1\":{\"67\":1}}],[\"0x0000000000000044\",{\"1\":{\"67\":2}}],[\"0x0000000000000030\",{\"1\":{\"67\":4}}],[\"0x0000000000000009\",{\"1\":{\"83\":1}}],[\"0x0000000000000008\",{\"1\":{\"83\":1}}],[\"0x0000000000000007\",{\"1\":{\"83\":1}}],[\"0x0000000000000002\",{\"1\":{\"83\":1}}],[\"0x0000000000000003\",{\"1\":{\"83\":1}}],[\"0x000000000000000b\",{\"1\":{\"83\":1}}],[\"0x000000000000000a\",{\"1\":{\"83\":1}}],[\"0x0000000000000006\",{\"1\":{\"83\":1}}],[\"0x0000000000000005\",{\"1\":{\"83\":1}}],[\"0x000000000000000d\",{\"1\":{\"83\":1}}],[\"0x000000000000000c\",{\"1\":{\"83\":1}}],[\"0x0000000000000001\",{\"1\":{\"83\":1}}],[\"0x0000000000000000\",{\"1\":{\"67\":6,\"73\":8,\"83\":1}}],[\"0x0000000000000004\",{\"1\":{\"54\":3}}],[\"0x00000000000004f8\",{\"1\":{\"67\":2}}],[\"0x04\",{\"1\":{\"54\":1}}],[\"0x04正好是段表在elf文件中的偏移\",{\"1\":{\"29\":1}}],[\"0x010f\",{\"1\":{\"53\":1}}],[\"0x0\",{\"1\":{\"14\":1,\"20\":3,\"25\":2,\"52\":2,\"73\":1,\"77\":3,\"80\":1,\"83\":2}}],[\"001fe000\",{\"1\":{\"73\":1}}],[\"001b0000\",{\"1\":{\"73\":1}}],[\"0010\",{\"1\":{\"20\":4}}],[\"000500000006\",{\"1\":{\"85\":1}}],[\"000500000004\",{\"1\":{\"54\":1}}],[\"000400000006\",{\"1\":{\"85\":1}}],[\"000400000002\",{\"1\":{\"54\":1}}],[\"000100000006\",{\"1\":{\"85\":1}}],[\"000300000006\",{\"1\":{\"85\":1}}],[\"00038000\",{\"1\":{\"73\":1}}],[\"00036000\",{\"1\":{\"73\":1}}],[\"000200000007\",{\"1\":{\"85\":1}}],[\"000200000006\",{\"1\":{\"77\":1}}],[\"000200000002\",{\"1\":{\"54\":1}}],[\"0002c000\",{\"1\":{\"73\":1}}],[\"00028000\",{\"1\":{\"73\":1}}],[\"000bf3ff\",{\"1\":{\"67\":1}}],[\"000b7ca0\",{\"1\":{\"67\":1}}],[\"000a9000\",{\"1\":{\"68\":1}}],[\"000a90c0\",{\"1\":{\"67\":1}}],[\"000ac090\",{\"1\":{\"67\":1}}],[\"000aaaf0\",{\"1\":{\"67\":1}}],[\"000aaac8\",{\"1\":{\"67\":2}}],[\"000a8fe8\",{\"1\":{\"67\":1}}],[\"000a8f48\",{\"1\":{\"67\":1}}],[\"000a4000\",{\"1\":{\"68\":1}}],[\"000a4f80\",{\"1\":{\"67\":1}}],[\"000a4f70\",{\"1\":{\"67\":1}}],[\"000a4f68\",{\"1\":{\"67\":2}}],[\"000a4f50\",{\"1\":{\"67\":1}}],[\"000a4910\",{\"1\":{\"67\":1}}],[\"0009b220\",{\"1\":{\"67\":1}}],[\"0009b1c0\",{\"1\":{\"67\":1}}],[\"0009b1a4\",{\"1\":{\"67\":1}}],[\"0007f000\",{\"1\":{\"67\":1,\"68\":1}}],[\"0007e6a4\",{\"1\":{\"67\":1}}],[\"000600000004\",{\"1\":{\"54\":1}}],[\"00003020\",{\"1\":{\"85\":1}}],[\"00003014\",{\"1\":{\"49\":2}}],[\"00003000\",{\"1\":{\"49\":1,\"73\":2,\"85\":1}}],[\"00002fe0\",{\"1\":{\"85\":1}}],[\"00002fc0\",{\"1\":{\"77\":1}}],[\"00002fb8\",{\"1\":{\"49\":1}}],[\"00002dc8\",{\"1\":{\"49\":1}}],[\"00002dc0\",{\"1\":{\"49\":1}}],[\"00002db8\",{\"1\":{\"49\":1}}],[\"00002040\",{\"1\":{\"49\":1}}],[\"00002004\",{\"1\":{\"49\":1}}],[\"00002000\",{\"1\":{\"49\":1,\"73\":4}}],[\"00001180\",{\"1\":{\"67\":1}}],[\"000011f0\",{\"1\":{\"49\":1}}],[\"00001060\",{\"1\":{\"49\":1}}],[\"00001050\",{\"1\":{\"49\":1}}],[\"00001040\",{\"1\":{\"49\":1}}],[\"00001020\",{\"1\":{\"49\":1,\"67\":1}}],[\"00001000\",{\"1\":{\"49\":1,\"67\":1,\"68\":1,\"73\":3}}],[\"0000c9c3\",{\"1\":{\"20\":1}}],[\"00000638\",{\"1\":{\"49\":1}}],[\"00000578\",{\"1\":{\"49\":1}}],[\"00000538\",{\"1\":{\"49\":1}}],[\"00000524\",{\"1\":{\"49\":1}}],[\"00000480\",{\"1\":{\"49\":1}}],[\"000003d8\",{\"1\":{\"49\":1}}],[\"000003b0\",{\"1\":{\"49\":1}}],[\"0000038c\",{\"1\":{\"49\":1}}],[\"00000368\",{\"1\":{\"49\":1}}],[\"00000360\",{\"1\":{\"28\":1}}],[\"00000338\",{\"1\":{\"49\":1}}],[\"00000318\",{\"1\":{\"49\":1}}],[\"00000390\",{\"1\":{\"28\":1}}],[\"000002c4\",{\"1\":{\"67\":1}}],[\"000002a0\",{\"1\":{\"67\":1}}],[\"00000270\",{\"1\":{\"67\":1}}],[\"00000288\",{\"1\":{\"28\":1}}],[\"000002e8\",{\"1\":{\"28\":1,\"67\":1}}],[\"000001f0\",{\"1\":{\"49\":1}}],[\"00000190\",{\"1\":{\"49\":1}}],[\"00000150\",{\"1\":{\"28\":1}}],[\"000001c2\",{\"1\":{\"20\":1}}],[\"000000cc\",{\"1\":{\"49\":1}}],[\"000000c0\",{\"1\":{\"49\":3}}],[\"00000014\",{\"1\":{\"49\":1}}],[\"00000010\",{\"1\":{\"49\":2}}],[\"0000001b\",{\"1\":{\"49\":1}}],[\"00000018\",{\"1\":{\"49\":1}}],[\"0000001c\",{\"1\":{\"49\":1}}],[\"0000003c\",{\"1\":{\"49\":1}}],[\"00000030\",{\"1\":{\"49\":1}}],[\"00000038\",{\"1\":{\"49\":2}}],[\"00000094\",{\"1\":{\"49\":2}}],[\"00000090\",{\"1\":{\"49\":1}}],[\"00000098\",{\"1\":{\"49\":3}}],[\"000000e0\",{\"1\":{\"49\":2}}],[\"000000e8\",{\"1\":{\"20\":1}}],[\"000000bb\",{\"1\":{\"49\":1}}],[\"000000bf\",{\"1\":{\"49\":1}}],[\"000000b0\",{\"1\":{\"19\":1,\"28\":1}}],[\"0000004f\",{\"1\":{\"49\":1}}],[\"00000048\",{\"1\":{\"20\":1,\"49\":1}}],[\"00000040\",{\"1\":{\"19\":1,\"28\":1,\"49\":3}}],[\"000000f8\",{\"1\":{\"19\":1,\"28\":1}}],[\"00000058\",{\"1\":{\"19\":1,\"49\":1}}],[\"000000d8\",{\"1\":{\"19\":1,\"28\":1}}],[\"000000d7\",{\"1\":{\"19\":1,\"28\":1}}],[\"00000026\",{\"1\":{\"49\":1}}],[\"00000024\",{\"1\":{\"49\":2}}],[\"00000020\",{\"1\":{\"19\":1,\"49\":4}}],[\"00000027\",{\"1\":{\"19\":1,\"49\":2}}],[\"000000a3\",{\"1\":{\"49\":1}}],[\"000000a8\",{\"1\":{\"49\":1}}],[\"000000ac\",{\"1\":{\"19\":2,\"28\":2}}],[\"000000a4\",{\"1\":{\"19\":1,\"28\":1}}],[\"0000000d\",{\"1\":{\"49\":1}}],[\"0000000e\",{\"1\":{\"49\":1}}],[\"000000004018\",{\"1\":{\"85\":2}}],[\"000000004020\",{\"1\":{\"85\":1}}],[\"000000003ff8\",{\"1\":{\"85\":1}}],[\"000000003ff0\",{\"1\":{\"85\":1}}],[\"000000003fe8\",{\"1\":{\"85\":1}}],[\"000000003fe0\",{\"1\":{\"85\":1}}],[\"000000003fc0\",{\"1\":{\"77\":1}}],[\"000000003e18\",{\"1\":{\"85\":1}}],[\"000000003e10\",{\"1\":{\"85\":1}}],[\"00000000004abae0\",{\"1\":{\"67\":1}}],[\"00000000004aa0c0\",{\"1\":{\"67\":1}}],[\"00000000004a9fe8\",{\"1\":{\"67\":1}}],[\"00000000004a9f48\",{\"1\":{\"67\":1}}],[\"00000000004a5f80\",{\"1\":{\"67\":1}}],[\"00000000004a5f70\",{\"1\":{\"67\":1}}],[\"00000000004a5f68\",{\"1\":{\"67\":2}}],[\"00000000004a5f50\",{\"1\":{\"67\":1}}],[\"00000000004a4910\",{\"1\":{\"67\":1}}],[\"000000000047f000\",{\"1\":{\"67\":1}}],[\"000000000047e6a4\",{\"1\":{\"67\":1}}],[\"0000000000401180\",{\"1\":{\"67\":1}}],[\"0000000000401020\",{\"1\":{\"67\":1}}],[\"0000000000401000\",{\"1\":{\"67\":1}}],[\"00000000004002e8\",{\"1\":{\"67\":1}}],[\"00000000004002c4\",{\"1\":{\"67\":1}}],[\"00000000004002a0\",{\"1\":{\"67\":1}}],[\"0000000000400270\",{\"1\":{\"67\":1}}],[\"000000000049b220\",{\"1\":{\"67\":1}}],[\"000000000049b1c0\",{\"1\":{\"67\":1}}],[\"000000000049b1a4\",{\"1\":{\"67\":1}}],[\"000000000049\",{\"1\":{\"54\":1}}],[\"000000000020\",{\"1\":{\"54\":1}}],[\"00000000002d\",{\"1\":{\"54\":1}}],[\"000000000008\",{\"1\":{\"85\":3}}],[\"000000000001c1a4\",{\"1\":{\"67\":1}}],[\"000000000007d521\",{\"1\":{\"67\":1}}],[\"00000000000b\",{\"1\":{\"54\":1}}],[\"000000000000775f\",{\"1\":{\"67\":1}}],[\"000000000000bc10\",{\"1\":{\"67\":1}}],[\"0000000000005768\",{\"1\":{\"67\":1}}],[\"00000000000096f0\",{\"1\":{\"67\":1}}],[\"0000000000004020\",{\"1\":{\"85\":1}}],[\"000000000000401c\",{\"1\":{\"77\":1}}],[\"0000000000004014\",{\"1\":{\"49\":2}}],[\"0000000000004000\",{\"1\":{\"49\":2,\"85\":1}}],[\"0000000000003fe0\",{\"1\":{\"85\":1}}],[\"0000000000003fc0\",{\"1\":{\"77\":1}}],[\"0000000000003fc8\",{\"1\":{\"67\":1}}],[\"0000000000003fb8\",{\"1\":{\"49\":2}}],[\"0000000000003dc8\",{\"1\":{\"49\":2}}],[\"0000000000003dc0\",{\"1\":{\"49\":2}}],[\"0000000000003db8\",{\"1\":{\"49\":2}}],[\"0000000000002040\",{\"1\":{\"49\":2}}],[\"0000000000002004\",{\"1\":{\"49\":2}}],[\"0000000000002000\",{\"1\":{\"49\":2}}],[\"0000000000001131\",{\"1\":{\"77\":1}}],[\"0000000000001139\",{\"1\":{\"77\":1}}],[\"0000000000001119\",{\"1\":{\"77\":1,\"84\":1}}],[\"0000000000001155\",{\"1\":{\"77\":2}}],[\"00000000000011f0\",{\"1\":{\"49\":2}}],[\"00000000000015a0\",{\"1\":{\"67\":1}}],[\"0000000000001a08\",{\"1\":{\"67\":1}}],[\"0000000000001070\",{\"1\":{\"77\":1,\"80\":1}}],[\"0000000000001060\",{\"1\":{\"49\":2,\"53\":1,\"77\":2}}],[\"0000000000001050\",{\"1\":{\"49\":2}}],[\"0000000000001040\",{\"1\":{\"49\":2}}],[\"0000000000001020\",{\"1\":{\"49\":2}}],[\"0000000000001000\",{\"1\":{\"49\":2}}],[\"0000000000000210\",{\"1\":{\"67\":1}}],[\"000000000000010c\",{\"1\":{\"67\":1}}],[\"00000000000001c4\",{\"1\":{\"58\":2}}],[\"00000000000001c9\",{\"1\":{\"58\":1}}],[\"0000000000000160\",{\"1\":{\"58\":1,\"67\":1}}],[\"0000000000000138\",{\"1\":{\"28\":1}}],[\"0000000000000638\",{\"1\":{\"49\":2}}],[\"0000000000000578\",{\"1\":{\"49\":2}}],[\"0000000000000538\",{\"1\":{\"49\":2}}],[\"0000000000000524\",{\"1\":{\"49\":2}}],[\"0000000000000480\",{\"1\":{\"49\":2}}],[\"0000000000000330\",{\"1\":{\"58\":2}}],[\"0000000000000338\",{\"1\":{\"49\":2}}],[\"00000000000003d8\",{\"1\":{\"49\":2}}],[\"00000000000003b0\",{\"1\":{\"49\":2}}],[\"000000000000038c\",{\"1\":{\"49\":2}}],[\"0000000000000368\",{\"1\":{\"49\":2}}],[\"0000000000000318\",{\"1\":{\"49\":2}}],[\"00000000000000c8\",{\"1\":{\"67\":1}}],[\"0000000000000090\",{\"1\":{\"67\":1}}],[\"0000000000000040\",{\"1\":{\"67\":1}}],[\"0000000000000049\",{\"1\":{\"54\":1}}],[\"00000000000000dc\",{\"1\":{\"67\":1}}],[\"0000000000000010\",{\"1\":{\"67\":1}}],[\"000000000000001b\",{\"1\":{\"67\":1}}],[\"000000000000001c\",{\"1\":{\"58\":1}}],[\"0000000000000019\",{\"1\":{\"58\":2}}],[\"0000000000000018\",{\"1\":{\"28\":3,\"58\":2,\"67\":3}}],[\"0000000000000074\",{\"1\":{\"28\":1}}],[\"0000000000000078\",{\"1\":{\"28\":1}}],[\"0000000000000060\",{\"1\":{\"28\":1,\"67\":1}}],[\"0000000000000064\",{\"1\":{\"28\":1}}],[\"0000000000000030\",{\"1\":{\"28\":1,\"67\":1}}],[\"0000000000000058\",{\"1\":{\"28\":1}}],[\"0000000000000028\",{\"1\":{\"77\":1}}],[\"0000000000000026\",{\"1\":{\"67\":1}}],[\"0000000000000024\",{\"1\":{\"67\":1}}],[\"000000000000002d\",{\"1\":{\"54\":1}}],[\"0000000000000020\",{\"1\":{\"28\":1,\"54\":1,\"67\":2,\"85\":2}}],[\"0000000000000027\",{\"1\":{\"28\":1}}],[\"000000000000002b\",{\"1\":{\"20\":1,\"22\":1,\"35\":1,\"39\":1}}],[\"000000000000000d\",{\"1\":{\"67\":1}}],[\"000000000000000b\",{\"1\":{\"54\":1}}],[\"0000000000000001\",{\"1\":{\"28\":1,\"67\":2}}],[\"0000000000000008\",{\"1\":{\"28\":1,\"67\":4,\"77\":1,\"85\":3}}],[\"0000000000000004\",{\"1\":{\"22\":2,\"28\":2,\"35\":2,\"39\":2}}],[\"0000000000000000\",{\"1\":{\"19\":16,\"20\":1,\"22\":10,\"28\":26,\"35\":3,\"39\":10,\"49\":30,\"52\":1,\"54\":4,\"55\":7,\"58\":9,\"67\":28,\"77\":1,\"84\":6,\"85\":6}}],[\"00000000\",{\"1\":{\"19\":1,\"20\":6,\"28\":1,\"49\":5,\"67\":1,\"68\":6,\"73\":11}}],[\"00000004\",{\"1\":{\"19\":1,\"49\":3}}],[\"00000008\",{\"1\":{\"19\":2,\"49\":2}}],[\"00000064\",{\"1\":{\"19\":1}}],[\"00008b15\",{\"1\":{\"20\":1}}],[\"0000\",{\"1\":{\"20\":6}}],[\"004b2000\",{\"1\":{\"68\":1}}],[\"004ac000\",{\"1\":{\"68\":2}}],[\"004aa000\",{\"1\":{\"68\":2}}],[\"004a5000\",{\"1\":{\"68\":2}}],[\"0047f000\",{\"1\":{\"68\":2}}],[\"00474343\",{\"1\":{\"20\":1}}],[\"00450e10\",{\"1\":{\"20\":2}}],[\"00401000\",{\"1\":{\"68\":2}}],[\"00400000\",{\"1\":{\"68\":1}}],[\"0040\",{\"1\":{\"20\":2}}],[\"0060\",{\"1\":{\"20\":1}}],[\"00b80000\",{\"1\":{\"20\":1}}],[\"0050\",{\"1\":{\"20\":2}}],[\"0030\",{\"1\":{\"20\":2}}],[\"00202000\",{\"1\":{\"73\":1}}],[\"0020\",{\"1\":{\"20\":3}}],[\"00\",{\"1\":{\"14\":4,\"20\":31,\"25\":9,\"52\":29,\"53\":19,\"67\":1,\"68\":10,\"73\":15,\"77\":65,\"80\":4}}],[\"05000000\",{\"1\":{\"20\":1}}],[\"05\",{\"1\":{\"14\":1,\"20\":2,\"67\":1,\"73\":1,\"77\":6}}],[\"0\",{\"1\":{\"6\":1,\"17\":1,\"19\":6,\"20\":3,\"22\":9,\"25\":4,\"28\":24,\"35\":1,\"39\":9,\"40\":1,\"42\":1,\"43\":1,\"46\":1,\"49\":16,\"52\":1,\"54\":1,\"55\":7,\"67\":57,\"68\":5,\"73\":9,\"77\":3,\"80\":7,\"82\":1,\"84\":8,\"85\":10}}],[\"needed\",{\"1\":{\"83\":1}}],[\"need\",{\"1\":{\"83\":1}}],[\"nm\",{\"1\":{\"35\":1}}],[\"null\",{\"1\":{\"28\":2,\"67\":1,\"80\":1,\"83\":1}}],[\"number\",{\"1\":{\"25\":3}}],[\"num\",{\"1\":{\"22\":1,\"39\":1,\"55\":1,\"77\":1,\"84\":1}}],[\"nr\",{\"1\":{\"28\":1,\"67\":1,\"77\":1}}],[\"nident\",{\"1\":{\"25\":1}}],[\"ndx\",{\"1\":{\"22\":1,\"39\":1,\"55\":1,\"77\":1,\"84\":1}}],[\"normally\",{\"1\":{\"86\":1}}],[\"now\",{\"1\":{\"83\":2}}],[\"nobits\",{\"1\":{\"28\":1,\"67\":2}}],[\"nopw\",{\"1\":{\"77\":3,\"80\":1}}],[\"nopl\",{\"1\":{\"53\":1}}],[\"nop\",{\"1\":{\"20\":1}}],[\"notype\",{\"1\":{\"22\":2,\"39\":2,\"55\":4,\"84\":4}}],[\"note\",{\"1\":{\"19\":4,\"20\":1,\"28\":3,\"49\":7,\"67\":17,\"73\":7}}],[\"not\",{\"1\":{\"17\":1,\"86\":3,\"89\":1}}],[\"namespace\",{\"1\":{\"40\":1,\"41\":1,\"42\":1}}],[\"name\",{\"1\":{\"19\":1,\"22\":1,\"28\":1,\"29\":2,\"35\":1,\"36\":2,\"39\":1,\"41\":2,\"49\":3,\"54\":2,\"55\":1,\"67\":1,\"77\":3,\"83\":2,\"84\":1,\"85\":2,\"86\":1}}],[\"n\",{\"1\":{\"6\":1,\"19\":1,\"21\":1,\"40\":4,\"41\":3,\"42\":1,\"44\":2,\"73\":2,\"80\":4,\"82\":1,\"84\":1}}],[\"hurt\",{\"1\":{\"86\":1}}],[\"hook\",{\"0\":{\"88\":1}}],[\"home=\",{\"1\":{\"70\":1}}],[\"home\",{\"1\":{\"68\":5,\"70\":1,\"73\":10}}],[\"holds\",{\"1\":{\"29\":1}}],[\"hidden\",{\"1\":{\"58\":3}}],[\"hdr\",{\"1\":{\"49\":1,\"73\":2}}],[\"have\",{\"1\":{\"86\":2}}],[\"handle\",{\"1\":{\"80\":5}}],[\"hash似乎已经不用了\",{\"1\":{\"84\":1}}],[\"hash\",{\"1\":{\"49\":1,\"73\":1,\"83\":3,\"84\":1}}],[\"half\",{\"1\":{\"25\":8}}],[\"h来查看elf文件中包含的段\",{\"1\":{\"28\":1}}],[\"h指令即可查看elf文件头\",{\"1\":{\"25\":1}}],[\"h指令打印elf文件的各个段的基本信息\",{\"1\":{\"19\":1}}],[\"here\",{\"1\":{\"86\":3}}],[\"heap\",{\"1\":{\"68\":1,\"73\":1}}],[\"headers\",{\"1\":{\"25\":6,\"28\":2,\"67\":4,\"73\":2,\"77\":2}}],[\"header\",{\"1\":{\"24\":2,\"25\":11,\"34\":1,\"67\":2,\"81\":1}}],[\"hex\",{\"1\":{\"19\":1}}],[\"hello\",{\"1\":{\"6\":6,\"7\":5,\"8\":3,\"9\":4,\"82\":1}}],[\"h\",{\"1\":{\"19\":1,\"20\":5,\"25\":2,\"29\":1,\"36\":1,\"49\":3,\"67\":1,\"73\":5,\"84\":1,\"86\":1}}],[\"h>\",{\"1\":{\"6\":1,\"40\":1,\"42\":1,\"44\":2,\"67\":1,\"73\":3,\"80\":3,\"82\":1,\"84\":1,\"86\":1}}],[\"1f\",{\"1\":{\"52\":1,\"53\":1,\"77\":3,\"80\":1}}],[\"1d\",{\"1\":{\"52\":1}}],[\"192\",{\"1\":{\"83\":1}}],[\"1988\",{\"1\":{\"69\":1}}],[\"19\",{\"1\":{\"49\":1,\"67\":1,\"77\":1}}],[\"18\",{\"1\":{\"49\":1,\"52\":3,\"53\":2,\"67\":1}}],[\"17\",{\"1\":{\"49\":1,\"67\":1}}],[\"164\",{\"1\":{\"69\":1}}],[\"16\",{\"1\":{\"49\":1,\"52\":1,\"67\":2}}],[\"15\",{\"1\":{\"20\":1,\"49\":1,\"67\":1}}],[\"1b\",{\"1\":{\"20\":2}}],[\"1b0c0708\",{\"1\":{\"20\":1}}],[\"141\",{\"1\":{\"83\":1}}],[\"14\",{\"1\":{\"20\":1,\"25\":1,\"28\":1,\"49\":1,\"67\":1,\"84\":1}}],[\"14000000\",{\"1\":{\"20\":1}}],[\"12小节\",{\"1\":{\"80\":1}}],[\"123\",{\"1\":{\"70\":2}}],[\"127\",{\"1\":{\"69\":1}}],[\"12\",{\"1\":{\"20\":1,\"22\":1,\"28\":2,\"39\":1,\"49\":1,\"67\":1}}],[\"10d0\",{\"1\":{\"85\":1}}],[\"10370\",{\"1\":{\"73\":4}}],[\"1032\",{\"1\":{\"25\":1}}],[\"1050\",{\"1\":{\"53\":1,\"77\":1}}],[\"10ad\",{\"1\":{\"53\":1}}],[\"10a7\",{\"1\":{\"53\":1}}],[\"10a3\",{\"1\":{\"53\":1}}],[\"10a1\",{\"1\":{\"53\":1}}],[\"10a8\",{\"1\":{\"53\":2}}],[\"109f\",{\"1\":{\"53\":1}}],[\"109d\",{\"1\":{\"53\":1}}],[\"1096\",{\"1\":{\"53\":1}}],[\"1091\",{\"1\":{\"53\":2}}],[\"108c\",{\"1\":{\"53\":2}}],[\"108b\",{\"1\":{\"53\":1}}],[\"1084\",{\"1\":{\"53\":1}}],[\"107a\",{\"1\":{\"77\":1,\"80\":1}}],[\"1074\",{\"1\":{\"77\":1,\"80\":1}}],[\"1070\",{\"1\":{\"77\":3,\"80\":1}}],[\"107f\",{\"1\":{\"53\":1}}],[\"107d\",{\"1\":{\"53\":1}}],[\"1078\",{\"1\":{\"53\":1}}],[\"1076\",{\"1\":{\"53\":1}}],[\"106a\",{\"1\":{\"77\":2}}],[\"106f\",{\"1\":{\"53\":2}}],[\"1068\",{\"1\":{\"53\":2}}],[\"1064\",{\"1\":{\"53\":1,\"77\":2}}],[\"1060\",{\"1\":{\"53\":1,\"77\":4}}],[\"1000\",{\"1\":{\"67\":1}}],[\"10000000\",{\"1\":{\"20\":1}}],[\"100\",{\"1\":{\"46\":1}}],[\"10\",{\"1\":{\"20\":2,\"22\":1,\"28\":1,\"39\":1,\"49\":1,\"67\":2,\"68\":5,\"73\":21,\"77\":1}}],[\"1e\",{\"1\":{\"20\":3,\"52\":1,\"53\":1,\"77\":7,\"80\":1}}],[\"1c000000\",{\"1\":{\"20\":3}}],[\"13\",{\"1\":{\"20\":2,\"22\":1,\"25\":1,\"28\":1,\"39\":1,\"49\":1,\"67\":1}}],[\"1110\",{\"1\":{\"85\":1}}],[\"1119\",{\"1\":{\"77\":2}}],[\"112a\",{\"1\":{\"77\":1}}],[\"1123\",{\"1\":{\"77\":1}}],[\"1120\",{\"1\":{\"77\":1}}],[\"1175\",{\"1\":{\"77\":2}}],[\"1171\",{\"1\":{\"77\":2}}],[\"117001\",{\"1\":{\"73\":5}}],[\"1151\",{\"1\":{\"77\":1}}],[\"115d\",{\"1\":{\"77\":2}}],[\"1159\",{\"1\":{\"77\":2}}],[\"1155\",{\"1\":{\"77\":2}}],[\"1154\",{\"1\":{\"77\":1}}],[\"114d\",{\"1\":{\"77\":1}}],[\"1148\",{\"1\":{\"77\":1}}],[\"1143\",{\"1\":{\"77\":1}}],[\"114e\",{\"1\":{\"77\":1}}],[\"1147\",{\"1\":{\"77\":2}}],[\"1144\",{\"1\":{\"77\":2}}],[\"113e\",{\"1\":{\"77\":1}}],[\"1135\",{\"1\":{\"77\":1}}],[\"1131\",{\"1\":{\"77\":1}}],[\"1130\",{\"1\":{\"77\":1}}],[\"113d\",{\"1\":{\"77\":2}}],[\"1139\",{\"1\":{\"77\":2}}],[\"116c\",{\"1\":{\"77\":2}}],[\"1167\",{\"1\":{\"77\":2}}],[\"1162\",{\"1\":{\"77\":2}}],[\"116994\",{\"1\":{\"73\":5}}],[\"116178\",{\"1\":{\"68\":5}}],[\"11a0\",{\"1\":{\"53\":2}}],[\"11\",{\"1\":{\"8\":1,\"22\":1,\"28\":3,\"39\":1,\"49\":1,\"67\":1,\"73\":1}}],[\"1\",{\"0\":{\"6\":1,\"7\":2,\"8\":1,\"9\":1,\"10\":1,\"12\":1,\"17\":1,\"20\":1,\"25\":1,\"26\":1,\"27\":1,\"29\":1,\"30\":2,\"31\":1,\"32\":1,\"36\":1,\"37\":2,\"38\":1,\"39\":1,\"41\":1,\"47\":1,\"48\":2,\"49\":1,\"50\":1,\"52\":1,\"60\":1,\"61\":2,\"62\":1,\"64\":1,\"67\":1,\"72\":1,\"75\":1,\"82\":1},\"1\":{\"7\":1,\"17\":3,\"19\":2,\"22\":5,\"25\":1,\"28\":8,\"35\":1,\"39\":5,\"43\":2,\"46\":1,\"49\":4,\"54\":1,\"55\":4,\"67\":7,\"68\":1,\"73\":5,\"77\":5,\"78\":1,\"80\":9,\"83\":3,\"84\":2,\"85\":1}}],[\"链接过程会把program1\",{\"1\":{\"73\":1}}],[\"链接成为可指向文件program1\",{\"1\":{\"73\":1}}],[\"链接器会在创建可执行文件时\",{\"1\":{\"78\":1}}],[\"链接器会判断f是一个目标文件还是一个存档文件\",{\"1\":{\"55\":1}}],[\"链接器在装载模块的时候会查找每个变量所在的地址\",{\"1\":{\"77\":1}}],[\"链接器在解析符号时就可以知道\",{\"1\":{\"73\":1}}],[\"链接器维护一个可重定位目标文件的集合e\",{\"1\":{\"55\":1}}],[\"链接器是从左到右按照它们在编译器取得程序命令行上出现的顺序来扫描可重定位目标文件和存档文件\",{\"1\":{\"55\":1}}],[\"链接器就会报服啊后未定义的错误\",{\"1\":{\"44\":1}}],[\"链接的输入目标只有program1\",{\"1\":{\"73\":1}}],[\"链接的接口\",{\"0\":{\"35\":1}}],[\"链接的过程就是将几个输入目标文件加工合并成一个输出文件的过程\",{\"1\":{\"47\":1}}],[\"链接的过程就是把多个不同的目标文件之间相互衔接的过程\",{\"1\":{\"35\":1}}],[\"链接的过程\",{\"0\":{\"13\":1}}],[\"链接的本质就是把一些指令对其它符号地址的引用加以修改\",{\"1\":{\"12\":1}}],[\"链接的基本定义\",{\"0\":{\"12\":1}}],[\"链接一堆文件生成最终的可执行文件的过程\",{\"1\":{\"10\":1}}],[\"链接\",{\"0\":{\"4\":1,\"10\":1},\"1\":{\"6\":1}}],[\"cxa\",{\"1\":{\"85\":1}}],[\"c是共享对象的一部分\",{\"1\":{\"78\":1}}],[\"c是程序可执行文件的一部分\",{\"1\":{\"78\":1}}],[\"c是这样引用的\",{\"1\":{\"78\":1}}],[\"c时\",{\"1\":{\"78\":1}}],[\"c的foobar\",{\"1\":{\"73\":1}}],[\"c被编译成program1\",{\"1\":{\"73\":2}}],[\"c被链接成lib\",{\"1\":{\"73\":1}}],[\"c编译成一个共享对象文件\",{\"1\":{\"73\":1}}],[\"cannot\",{\"1\":{\"86\":2}}],[\"can\",{\"1\":{\"86\":1}}],[\"cat\",{\"1\":{\"68\":1,\"73\":1}}],[\"call\",{\"1\":{\"20\":2,\"52\":3,\"53\":3,\"77\":6}}],[\"cst32\",{\"1\":{\"67\":2}}],[\"csapp提到的另一种重定位结构\",{\"1\":{\"56\":1}}],[\"csapp\",{\"1\":{\"43\":1,\"55\":1}}],[\"cpu将控制权交给操作系统\",{\"1\":{\"65\":1}}],[\"cpu直接使用在指令中编码的32值作为有效地址\",{\"1\":{\"56\":1}}],[\"cpu执行一条使用pc相对寻址的指令时\",{\"1\":{\"56\":1}}],[\"cpp\",{\"1\":{\"7\":1}}],[\"c依赖的文件不会并入集合中\",{\"1\":{\"55\":1}}],[\"c依赖与liba\",{\"1\":{\"55\":1}}],[\"c文件所以就会执行上述的存档文件的操作导致foo\",{\"1\":{\"55\":1}}],[\"creating\",{\"1\":{\"55\":1}}],[\"create\",{\"1\":{\"44\":2}}],[\"chapter04\",{\"1\":{\"68\":5,\"73\":10}}],[\"char\",{\"1\":{\"19\":1,\"25\":1,\"36\":2,\"40\":4,\"80\":1}}],[\"chk\",{\"1\":{\"53\":1,\"54\":2,\"55\":2,\"58\":4}}],[\"c4\",{\"1\":{\"52\":1,\"53\":1,\"77\":3}}],[\"c0\",{\"1\":{\"52\":2,\"53\":2}}],[\"ccvefqsm\",{\"1\":{\"57\":1}}],[\"ccjfgl1q\",{\"1\":{\"57\":1}}],[\"ccwmm6jl\",{\"1\":{\"55\":2}}],[\"cc\",{\"1\":{\"42\":2}}],[\"cc1\",{\"1\":{\"8\":1}}],[\"c语言源代码文件中的所有全局的变量和函数经过编译后\",{\"1\":{\"40\":1}}],[\"current\",{\"1\":{\"25\":1}}],[\"class\",{\"1\":{\"25\":1,\"41\":3}}],[\"c代码中用在调用printf时用到了字符字面量\",{\"1\":{\"21\":1}}],[\"c代码中一共有两个这样的变量\",{\"1\":{\"21\":1,\"22\":1}}],[\"c2\",{\"1\":{\"20\":2,\"41\":1}}],[\"c28b45fc\",{\"1\":{\"20\":1}}],[\"c3\",{\"1\":{\"20\":2,\"52\":1,\"53\":1,\"77\":5}}],[\"c9\",{\"1\":{\"20\":2}}],[\"c6\",{\"1\":{\"20\":1}}],[\"copy\",{\"1\":{\"68\":1}}],[\"cow\",{\"1\":{\"68\":1}}],[\"collect2\",{\"1\":{\"55\":1}}],[\"count\",{\"1\":{\"25\":2}}],[\"compressed\",{\"1\":{\"28\":1,\"67\":1}}],[\"complement\",{\"1\":{\"25\":1}}],[\"com\",{\"1\":{\"22\":1,\"39\":1}}],[\"common选项即可\",{\"1\":{\"57\":1}}],[\"common块的机制来源于fortran\",{\"1\":{\"57\":1}}],[\"common块\",{\"0\":{\"57\":1},\"1\":{\"39\":2}}],[\"common\",{\"1\":{\"22\":1}}],[\"comment\",{\"1\":{\"19\":2,\"20\":1,\"28\":1,\"49\":3,\"67\":1}}],[\"code\",{\"1\":{\"19\":1,\"49\":8,\"56\":1,\"77\":1}}],[\"conflicts\",{\"1\":{\"86\":1}}],[\"contains\",{\"1\":{\"22\":1,\"39\":1,\"54\":2,\"55\":1,\"77\":2,\"83\":1,\"84\":1,\"85\":2}}],[\"contents\",{\"1\":{\"19\":8,\"20\":6,\"49\":38,\"82\":1}}],[\"const变量\",{\"1\":{\"21\":1}}],[\"const\",{\"1\":{\"19\":1,\"44\":1}}],[\"core\",{\"1\":{\"17\":1}}],[\"c7\",{\"1\":{\"14\":1,\"20\":3,\"52\":1,\"53\":1,\"77\":5}}],[\"c++编译器默认函数和初始化了的全局变量为强符号\",{\"1\":{\"43\":1}}],[\"c++编译器会将extern\",{\"1\":{\"42\":1}}],[\"c++中的全局变量和静态变量也有同样的机制\",{\"1\":{\"41\":1}}],[\"c++filt\",{\"1\":{\"41\":2}}],[\"c++名称修饰\",{\"1\":{\"41\":1}}],[\"c++\",{\"0\":{\"1\":1,\"41\":1},\"2\":{\"2\":1,\"3\":1}}],[\"c\",{\"0\":{\"1\":1,\"42\":1},\"1\":{\"6\":2,\"7\":3,\"9\":1,\"20\":3,\"22\":3,\"28\":1,\"35\":1,\"39\":1,\"40\":1,\"41\":5,\"42\":5,\"43\":3,\"44\":3,\"46\":5,\"55\":11,\"67\":4,\"73\":7,\"77\":3,\"82\":2,\"84\":3},\"2\":{\"2\":1,\"3\":1}}],[\"介绍页\",{\"0\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const u=bt[s];e==="suggest"?self.postMessage([e,o,tt(t,u,n)]):e==="search"?self.postMessage([e,o,Z(t,u,n)]):self.postMessage({suggestions:[e,o,tt(t,u,n)],results:[e,o,Z(t,u,n)]})};
//# sourceMappingURL=index.js.map
