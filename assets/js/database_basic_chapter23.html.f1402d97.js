"use strict";(self.webpackChunkfar_blog=self.webpackChunkfar_blog||[]).push([[9049],{6262:(i,s)=>{s.A=(i,s)=>{const a=i.__vccOpts||i;for(const[i,e]of s)a[i]=e;return a}},8437:(i,s,a)=>{a.r(s),a.d(s,{comp:()=>l,data:()=>h});var e=a(641);const t=[(0,e.Fv)('<h2 id="_23-1-触发器" tabindex="-1"><a class="header-anchor" href="#_23-1-触发器"><span>23.1 触发器</span></a></h2><div class="hint-container important"><p class="hint-container-title">重要</p><p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：</p><ul><li>DELETE</li><li>INSERT</li><li>UPDATE</li></ul></div><h2 id="_23-2-创建触发器" tabindex="-1"><a class="header-anchor" href="#_23-2-创建触发器"><span>23.2 创建触发器</span></a></h2><p>在创建触发器时，需要给出4条信息：</p><ol><li>唯一的触发器名；</li><li>触发器关联的表；</li><li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li><li>触发器何时执行（处理之前或之后）。</li></ol><div class="hint-container tip"><p class="hint-container-title">提示</p><p>保持每个数据库的触发器名唯一: 在MySQL 5中，触发器名必须在每个表中唯一，但不是在每个数据库中唯一。这表示同一数据库中的两个表可具有相同名字的触发器。这在其他每个数据库触发器名必须唯一的DBMS中是不允许的，而且以后的MySQL版本很可能会使命名规则更为严格。因此，现在最好是在数据库范围内使用唯一的触发器名。</p></div><p>触发器用CREATE TRIGGER语句创建。下面是一个简单的例子：</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TRIGGER</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> newproduct</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AFTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> INSERT</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> products</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> EACH </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ROW</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> SELECT</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> &#39;Product added&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container note"><p class="hint-container-title">注</p><p>CREATE TRIGGER用来创建名为newproduct的新触发器。<br> 触发器可在一个操作发生之前或之后执行，这里给出了AFTER INSERT，所以此触发器将在INSERT语句成功执行后执行。<br> 这个触发器还指定FOREACH ROW，因此代码对每个插入行执行。<br> 在这个例子中，文本Product added将对每个插入的行显示一次。</p></div><div class="hint-container note"><p class="hint-container-title">注</p><p>仅支持表: 只有表才支持触发器，视图不支持（临时表也不支持）。</p></div><div class="hint-container warning"><p class="hint-container-title">注意</p><p>触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。因此，每个表最多支持6个触发器（每条INSERT、UPDATE和DELETE的之前和之后）。单一触发器不能与多个事件或多个表关联，所以，如果你需要一个对INSERT和UPDATE操作执行的触发器，则应该定义两个触发器。</p></div><div class="hint-container note"><p class="hint-container-title">注</p><p>触发器失败 如果BEFORE触发器失败，则MySQL将不执行请求的操作。此外，如果BEFORE触发器或语句本身失败，MySQL将不执行AFTER触发器（如果有的话）。</p></div><h2 id="_23-3-删除触发器" tabindex="-1"><a class="header-anchor" href="#_23-3-删除触发器"><span>23.3 删除触发器</span></a></h2><div class="hint-container important"><p class="hint-container-title">重要</p><p>使用ROP TRIGGER [trigger_name];语句除触发器</p></div><p>触发器不能更新或覆盖。为了修改一个触发器，必须先删除它，然后再重新创建。</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">DROP</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TRIGGER</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> newproduct;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="_23-4-使用触发器" tabindex="-1"><a class="header-anchor" href="#_23-4-使用触发器"><span>23.4 使用触发器</span></a></h2><h3 id="_23-4-1-insert触发器" tabindex="-1"><a class="header-anchor" href="#_23-4-1-insert触发器"><span>23.4.1 INSERT触发器</span></a></h3><p>INSERT触发器在INSERT语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行；</li><li>在BEFORE INSERT触发器中，NEW中的值也可以被更新（允许更改被插入的值）；</li><li>对于AUTO_INCREMENT列，NEW在INSERT执行之前包含0，在INSERT执行之后包含新的自动生成值。</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 创建一个名为neworder的触发器</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 它按照AFTER INSERT ON orders执行。</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 在插入一个新订单到orders表时，MySQL生成一个新订单号并保存到order_num中。</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 触发器从NEW. order_num取得这个值并返回它。此触发器必须按照AFTER INSERT执行，因为在BEFORE INSERT语句执行之前，新order_num还没有生成。对于orders的每次插入使用这个触发器将总是返回新的订单号。</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TRIGGER</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> neworder</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> AFTER</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> INSERT</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> orders</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> EACH </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ROW</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> SELECT</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> NEW</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">order_num</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="hint-container tip"><p class="hint-container-title">提示</p><p>BEFORE或AFTER？ 通常，将BEFORE用于数据验证和净化（目的是保证插入表中的数据确实是需要的数据）。本提示也适用于UPDATE触发器。</p></div><h3 id="_23-4-2-delete触发器" tabindex="-1"><a class="header-anchor" href="#_23-4-2-delete触发器"><span>23.4.2 DELETE触发器</span></a></h3><p>DELETE触发器在DELETE语句执行之前或之后执行。需要知道以下两点：</p><ol><li>在DELETE触发器代码内，你可以引用一个名为OLD的虚拟表，访问被删除的行；</li><li>OLD中的值全都是只读的，不能更新。</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">-- 在任意订单被删除前将执行此触发器。它使用一条INSERT语句将OLD中的值（要被删除的订单）保存到一个名为archive_orders的存档表中（为实际使用这个例子，你需要用与orders相同的列创建一个名为archive_orders的表）。</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TRIGGER</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> deleteorder</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> BEFORE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> DELETE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> orders</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> EACH </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ROW</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">BEGIN</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  INSERT INTO</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> archive_orders(order_num, order_date, cust_id)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  VALUES</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">OLD</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">order_num</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">OLD</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">order_date</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">OLD</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">cust_id</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">END</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用BEFORE DELETE触发器的优点（相对于AFTER DELETE触发器来说）为，如果由于某种原因，订单不能存档，DELETE本身将被放弃。</p><h3 id="_23-4-3-update触发器" tabindex="-1"><a class="header-anchor" href="#_23-4-3-update触发器"><span>23.4.3 UPDATE触发器</span></a></h3><p>UPDATE触发器在UPDATE语句执行之前或之后执行。需要知道以下几点：</p><ol><li>在UPDATE触发器代码中，你可以引用一个名为OLD的虚拟表访问以前（UPDATE语句前）的值，引用一个名为NEW的虚拟表访问新更新的值；</li><li>在BEFORE UPDATE触发器中，NEW中的值可能也被更新（允许更改将要用于UPDATE语句中的值）；</li><li>OLD中的值全都是只读的，不能更新。</li></ol><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" data-title="sql" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> TRIGGER</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> updatevendor</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> BEFORE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> UPDATE</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> ON</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> vendors</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">FOR</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> EACH </span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">ROW</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> SET</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> NEW</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">vend_state</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#56B6C2;"> UPPER</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">NEW</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">vend_state</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>显然，任何数据净化都需要在UPDATE语句之前进行，就像这个例子中一样。每次更新一个行时，NEW.vend_state中的值（将用来更新表行的值）都用UPPER(NEW.vend_state)替换。</p>',32)],n={},l=(0,a(6262).A)(n,[["render",function(i,s){return(0,e.uX)(),(0,e.CE)("div",null,t)}]]),h=JSON.parse('{"path":"/database/basic/chapter23.html","title":"第二十三章 触发器","lang":"zh-CN","frontmatter":{"title":"第二十三章 触发器","date":"2025-08-24T00:00:00.000Z","tags":["计算机基础","数据库"],"categories":"mysql","isOriginal":true,"order":24,"dir":{"order":24},"description":"23.1 触发器 重要 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE INSERT UPDATE 23.2 创建触发器 在创建触发器时，需要给出4条信息： 唯一的触发器名； 触发器关联的表； 触发器应该响应的活动（DELETE、INSERT或UPDATE）； 触发器何时执...","head":[["meta",{"property":"og:url","content":"https://hncat.github.io/database/basic/chapter23.html"}],["meta",{"property":"og:site_name","content":"far"}],["meta",{"property":"og:title","content":"第二十三章 触发器"}],["meta",{"property":"og:description","content":"23.1 触发器 重要 触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）： DELETE INSERT UPDATE 23.2 创建触发器 在创建触发器时，需要给出4条信息： 唯一的触发器名； 触发器关联的表； 触发器应该响应的活动（DELETE、INSERT或UPDATE）； 触发器何时执..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-08-27T14:41:37.000Z"}],["meta",{"property":"article:author","content":"Mr.far"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"数据库"}],["meta",{"property":"article:published_time","content":"2025-08-24T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-27T14:41:37.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第二十三章 触发器\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-08-24T00:00:00.000Z\\",\\"dateModified\\":\\"2025-08-27T14:41:37.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.far\\",\\"url\\":\\"https://hncat.github.io\\"}]}"]]},"headers":[{"level":2,"title":"23.1 触发器","slug":"_23-1-触发器","link":"#_23-1-触发器","children":[]},{"level":2,"title":"23.2 创建触发器","slug":"_23-2-创建触发器","link":"#_23-2-创建触发器","children":[]},{"level":2,"title":"23.3 删除触发器","slug":"_23-3-删除触发器","link":"#_23-3-删除触发器","children":[]},{"level":2,"title":"23.4 使用触发器","slug":"_23-4-使用触发器","link":"#_23-4-使用触发器","children":[{"level":3,"title":"23.4.1 INSERT触发器","slug":"_23-4-1-insert触发器","link":"#_23-4-1-insert触发器","children":[]},{"level":3,"title":"23.4.2 DELETE触发器","slug":"_23-4-2-delete触发器","link":"#_23-4-2-delete触发器","children":[]},{"level":3,"title":"23.4.3 UPDATE触发器","slug":"_23-4-3-update触发器","link":"#_23-4-3-update触发器","children":[]}]}],"git":{"createdTime":1756101952000,"updatedTime":1756305697000,"contributors":[{"name":"far","email":"v19991123v@163.com","commits":2}]},"readingTime":{"minutes":4.58,"words":1375},"filePathRelative":"database/basic/chapter23.md","localizedDate":"2025年8月24日","excerpt":"<h2>23.1 触发器</h2>\\n<div class=\\"hint-container important\\">\\n<p class=\\"hint-container-title\\">重要</p>\\n<p>触发器是MySQL响应以下任意语句而自动执行的一条MySQL语句（或位于BEGIN和END语句之间的一组语句）：</p>\\n<ul>\\n<li>DELETE</li>\\n<li>INSERT</li>\\n<li>UPDATE</li>\\n</ul>\\n</div>\\n<h2>23.2 创建触发器</h2>\\n<p>在创建触发器时，需要给出4条信息：</p>\\n<ol>\\n<li>唯一的触发器名；</li>\\n<li>触发器关联的表；</li>\\n<li>触发器应该响应的活动（DELETE、INSERT或UPDATE）；</li>\\n<li>触发器何时执行（处理之前或之后）。</li>\\n</ol>","autoDesc":true}')}}]);