"use strict";(self.webpackChunkfar_blog=self.webpackChunkfar_blog||[]).push([[684],{6262:(e,t)=>{t.A=(e,t)=>{const a=e.__vccOpts||e;for(const[e,i]of t)a[e]=i;return a}},5587:(e,t,a)=>{a.r(t),a.d(t,{comp:()=>l,data:()=>s});var i=a(641);const n=[(0,i.Fv)('<h2 id="_1-装载的方式" tabindex="-1"><a class="header-anchor" href="#_1-装载的方式"><span>1. 装载的方式</span></a></h2><h3 id="_1-1-覆盖装入" tabindex="-1"><a class="header-anchor" href="#_1-1-覆盖装入"><span>1.1 覆盖装入</span></a></h3><div class="hint-container note"><p class="hint-container-title">注</p><p>覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手工将程序分割成若干块，然后编写一个小的辅助代码工具来管理这些模块何时应该驻留内存何时应该被替换掉。这个小的辅助代码就是所谓的<mark>覆盖管理器(Overlay Manager)</mark>。</p></div><h3 id="_1-2-页映射" tabindex="-1"><a class="header-anchor" href="#_1-2-页映射"><span>1.2 页映射</span></a></h3><div class="hint-container note"><p class="hint-container-title">注</p><p>建议阅读csapp 第九章 虚拟内存</p></div><h2 id="_2-从操作系统角度看可执行文件的装载" tabindex="-1"><a class="header-anchor" href="#_2-从操作系统角度看可执行文件的装载"><span>2. 从操作系统角度看可执行文件的装载</span></a></h2><h3 id="_2-1-进程的建立" tabindex="-1"><a class="header-anchor" href="#_2-1-进程的建立"><span>2.1 进程的建立</span></a></h3><ul><li>创建一个独立的虚拟地址空间。</li></ul><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>创建虚拟地址空间实际上只是分配一个页目录(Page Directory)就可以了，甚至不需要设置页映射关系。这些映射关系可以等到页错误时再进行映射。这一步中映射的是虚拟空间到实际物理内存的映射关系。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li></ul><div class="language-text line-numbers-mode" data-highlighter="shiki" data-ext="text" data-title="text" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>这一步所做的是虚拟空间与可执行文件的映射关系。当程序执行发生页错误时，操作系统将从物理内存中分配一个物理页，然后将该“缺页”从磁盘中读取到内存中，再设置缺页的虚拟页和物理页的映射关系，这样程序才得以正确运行。所以当操作系统捕获到也错误发生时，应当知道所需的页在可执行文件中的那一个位置。这就是传统意义的“装载”过程。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li></ul><h3 id="_2-2-页错误" tabindex="-1"><a class="header-anchor" href="#_2-2-页错误"><span>2.2 页错误</span></a></h3><h2 id="_3-进程虚拟空间分布" tabindex="-1"><a class="header-anchor" href="#_3-进程虚拟空间分布"><span>3. 进程虚拟空间分布</span></a></h2>',14)],r={},l=(0,a(6262).A)(r,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,n)}]]),s=JSON.parse('{"path":"/cs/linker/chapter04.html","title":"第四章 可执行文件的装载","lang":"zh-CN","frontmatter":{"title":"第四章 可执行文件的装载","date":"2024-07-03T00:00:00.000Z","tags":["计算机基础","c/c++"],"categories":"链接、装载与库","isOriginal":true,"order":4,"dir":{"order":4},"description":"1. 装载的方式 1.1 覆盖装入 注 覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手工将程序分割成若干块，然后编写一个小的辅助代码工具来管理这些模块何时应该驻留内存何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器(Overlay Manager)。 1.2 页映射 注 建议阅读csapp 第九章 虚拟内存 2. 从操作...","head":[["meta",{"property":"og:url","content":"https://hncat.github.io/cs/linker/chapter04.html"}],["meta",{"property":"og:site_name","content":"far"}],["meta",{"property":"og:title","content":"第四章 可执行文件的装载"}],["meta",{"property":"og:description","content":"1. 装载的方式 1.1 覆盖装入 注 覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手工将程序分割成若干块，然后编写一个小的辅助代码工具来管理这些模块何时应该驻留内存何时应该被替换掉。这个小的辅助代码就是所谓的覆盖管理器(Overlay Manager)。 1.2 页映射 注 建议阅读csapp 第九章 虚拟内存 2. 从操作..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-07-04T13:51:16.000Z"}],["meta",{"property":"article:author","content":"Mr.far"}],["meta",{"property":"article:tag","content":"计算机基础"}],["meta",{"property":"article:tag","content":"c/c++"}],["meta",{"property":"article:published_time","content":"2024-07-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-07-04T13:51:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第四章 可执行文件的装载\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-07-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-07-04T13:51:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.far\\",\\"url\\":\\"https://hncat.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. 装载的方式","slug":"_1-装载的方式","link":"#_1-装载的方式","children":[{"level":3,"title":"1.1 覆盖装入","slug":"_1-1-覆盖装入","link":"#_1-1-覆盖装入","children":[]},{"level":3,"title":"1.2 页映射","slug":"_1-2-页映射","link":"#_1-2-页映射","children":[]}]},{"level":2,"title":"2. 从操作系统角度看可执行文件的装载","slug":"_2-从操作系统角度看可执行文件的装载","link":"#_2-从操作系统角度看可执行文件的装载","children":[{"level":3,"title":"2.1 进程的建立","slug":"_2-1-进程的建立","link":"#_2-1-进程的建立","children":[]},{"level":3,"title":"2.2 页错误","slug":"_2-2-页错误","link":"#_2-2-页错误","children":[]}]},{"level":2,"title":"3. 进程虚拟空间分布","slug":"_3-进程虚拟空间分布","link":"#_3-进程虚拟空间分布","children":[]}],"git":{"createdTime":1720018867000,"updatedTime":1720101076000,"contributors":[{"name":"far","email":"v19991123v@163.com","commits":2}]},"readingTime":{"minutes":1.66,"words":497},"filePathRelative":"cs/linker/chapter04.md","localizedDate":"2024年7月3日","excerpt":"<h2>1. 装载的方式</h2>\\n<h3>1.1 覆盖装入</h3>\\n<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>覆盖装入的方法把挖掘内存潜力的任务交给了程序员，程序员在编写程序时必须手工将程序分割成若干块，然后编写一个小的辅助代码工具来管理这些模块何时应该驻留内存何时应该被替换掉。这个小的辅助代码就是所谓的<mark>覆盖管理器(Overlay Manager)</mark>。</p>\\n</div>\\n<h3>1.2 页映射</h3>\\n<div class=\\"hint-container note\\">\\n<p class=\\"hint-container-title\\">注</p>\\n<p>建议阅读csapp 第九章 虚拟内存</p>\\n</div>","autoDesc":true}')}}]);